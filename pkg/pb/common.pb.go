// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		common.proto
		ctp.proto
		market_data.proto
		mini_trade.proto
		others.proto
		spider-news.proto
		spider-rpc.proto
		stock_option.proto

	It has these top-level messages:
		Symbol
		ProductID
		Kline
		KlineSeries
		BrokerRoute
		BrokerRouteList
		InstrumentInfo
		SimpleTimePeriod
		MarketTimeRule
		ProductInfo
		TradingInstrument
		TradingInstrumentList
		ProductInfoList
		ReqSetTradingInstrumentList
		ReqSetProductInfoList
		ReqUpdateTIOpenDate
		ReqUpdateTIOpenDateList
		AccountMoneySummary
		AccountMoneySummaryList
		MoneyTransferRecord
		MTRList
		CTPOrderID
		CTPOrder
		CTPOrderList
		JointOrder
		CTPOrderLink
		CTPCancelOrderRequest
		CTPOnRtnCancelOrder
		CTPTradeReport
		CTPTradeReportList
		CTPPositionSummation
		CTPPosition
		CTPPositionList
		CTPCloseTradeRecord
		CTPCloseTradeRecordList
		CTPMarginRate
		CTPMarginItem
		CTPCommissionRateItem
		CTPCommissionRate
		CTPTradingUnit
		CTPForceCloseTimeRule
		CTPTradingUnitOption
		MarginCheckRule
		SettlementUnitOption
		CTPTradingAccount
		CTPTradingAccountSnapshot
		OrderBook
		MarketDataSnapshot
		MdsList
		MiniTradeOrder
		MiniTradeUnit
		MiniTradeAccount
		NetInAmountDetail
		RealtimeMoneyTrendItem
		RealtimeMoneyTrendItemList
		NewsItemPage
		Arthur
		NewsItem
		NewsDetail
		ReqOptionQuote
		OptionQuote
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ExchangeType int32

const (
	// / 上海期货交易所
	ExchangeType_SHFE ExchangeType = 0
	// / 郑州商品交易所
	ExchangeType_CZCE ExchangeType = 1
	// / 大连商品期货交易所
	ExchangeType_DCE ExchangeType = 2
	// / 中金所
	ExchangeType_CFFEX ExchangeType = 3
	// / 上海证券交易所
	ExchangeType_SSE ExchangeType = 4
	// / 深圳证券交易所
	ExchangeType_SZE ExchangeType = 5
	// / 香港证券交易所
	ExchangeType_HKG ExchangeType = 6
	// / 香港期货交易所
	ExchangeType_HKFE ExchangeType = 7
	// / 各类指数
	ExchangeType_INDEX ExchangeType = 8
	// / 上证期权
	ExchangeType_OPTION_SSE ExchangeType = 9
)

var ExchangeType_name = map[int32]string{
	0: "SHFE",
	1: "CZCE",
	2: "DCE",
	3: "CFFEX",
	4: "SSE",
	5: "SZE",
	6: "HKG",
	7: "HKFE",
	8: "INDEX",
	9: "OPTION_SSE",
}
var ExchangeType_value = map[string]int32{
	"SHFE":       0,
	"CZCE":       1,
	"DCE":        2,
	"CFFEX":      3,
	"SSE":        4,
	"SZE":        5,
	"HKG":        6,
	"HKFE":       7,
	"INDEX":      8,
	"OPTION_SSE": 9,
}

func (x ExchangeType) String() string {
	return proto.EnumName(ExchangeType_name, int32(x))
}
func (ExchangeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

type PeriodType int32

const (
	// Tick
	PeriodType_TICK PeriodType = 0
	// 分钟
	PeriodType_M1 PeriodType = 1
	// 3分钟
	PeriodType_M3 PeriodType = 2
	// 5分钟
	PeriodType_M5 PeriodType = 3
	// 10分钟
	PeriodType_M10 PeriodType = 4
	// 15分钟
	PeriodType_M15 PeriodType = 5
	// 小时
	PeriodType_H1 PeriodType = 6
	// 3小时
	PeriodType_H3 PeriodType = 7
	// 日线
	PeriodType_D1 PeriodType = 8
	// 周线
	PeriodType_W1 PeriodType = 9
	// 月线
	PeriodType_MON1 PeriodType = 10
)

var PeriodType_name = map[int32]string{
	0:  "TICK",
	1:  "M1",
	2:  "M3",
	3:  "M5",
	4:  "M10",
	5:  "M15",
	6:  "H1",
	7:  "H3",
	8:  "D1",
	9:  "W1",
	10: "MON1",
}
var PeriodType_value = map[string]int32{
	"TICK": 0,
	"M1":   1,
	"M3":   2,
	"M5":   3,
	"M10":  4,
	"M15":  5,
	"H1":   6,
	"H3":   7,
	"D1":   8,
	"W1":   9,
	"MON1": 10,
}

func (x PeriodType) String() string {
	return proto.EnumName(PeriodType_name, int32(x))
}
func (PeriodType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

type AccountType int32

const (
	AccountType_CN_FUTURE AccountType = 0
	AccountType_CN_STOCK  AccountType = 1
)

var AccountType_name = map[int32]string{
	0: "CN_FUTURE",
	1: "CN_STOCK",
}
var AccountType_value = map[string]int32{
	"CN_FUTURE": 0,
	"CN_STOCK":  1,
}

func (x AccountType) String() string {
	return proto.EnumName(AccountType_name, int32(x))
}
func (AccountType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

type CurrencyType int32

const (
	CurrencyType_CNY CurrencyType = 0
	CurrencyType_USD CurrencyType = 1
)

var CurrencyType_name = map[int32]string{
	0: "CNY",
	1: "USD",
}
var CurrencyType_value = map[string]int32{
	"CNY": 0,
	"USD": 1,
}

func (x CurrencyType) String() string {
	return proto.EnumName(CurrencyType_name, int32(x))
}
func (CurrencyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

// 合约代码
type Symbol struct {
	Exchange ExchangeType `protobuf:"varint,1,opt,name=exchange,proto3,enum=pb.ExchangeType" json:"exchange"`
	Code     string       `protobuf:"bytes,2,opt,name=code,proto3" json:"code"`
}

func (m *Symbol) Reset()                    { *m = Symbol{} }
func (m *Symbol) String() string            { return proto.CompactTextString(m) }
func (*Symbol) ProtoMessage()               {}
func (*Symbol) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

func (m *Symbol) GetExchange() ExchangeType {
	if m != nil {
		return m.Exchange
	}
	return ExchangeType_SHFE
}

func (m *Symbol) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// 品种
type ProductID struct {
	Exchange ExchangeType `protobuf:"varint,1,opt,name=exchange,proto3,enum=pb.ExchangeType" json:"exchange"`
	Code     string       `protobuf:"bytes,2,opt,name=code,proto3" json:"code"`
}

func (m *ProductID) Reset()                    { *m = ProductID{} }
func (m *ProductID) String() string            { return proto.CompactTextString(m) }
func (*ProductID) ProtoMessage()               {}
func (*ProductID) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

func (m *ProductID) GetExchange() ExchangeType {
	if m != nil {
		return m.Exchange
	}
	return ExchangeType_SHFE
}

func (m *ProductID) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// K线
type Kline struct {
	// 时间
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time"`
	// 开盘
	Open float64 `protobuf:"fixed64,2,opt,name=open,proto3" json:"open"`
	// 最高
	High float64 `protobuf:"fixed64,3,opt,name=high,proto3" json:"high"`
	// 最低
	Low float64 `protobuf:"fixed64,4,opt,name=low,proto3" json:"low"`
	// 收盘
	Close float64 `protobuf:"fixed64,5,opt,name=close,proto3" json:"close"`
	// 成交量
	Volume float64 `protobuf:"fixed64,6,opt,name=volume,proto3" json:"volume"`
	// 成交额
	Amount float64 `protobuf:"fixed64,7,opt,name=amount,proto3" json:"amount"`
	// 持仓量
	Position float64 `protobuf:"fixed64,8,opt,name=position,proto3" json:"position"`
}

func (m *Kline) Reset()                    { *m = Kline{} }
func (m *Kline) String() string            { return proto.CompactTextString(m) }
func (*Kline) ProtoMessage()               {}
func (*Kline) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

func (m *Kline) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Kline) GetOpen() float64 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *Kline) GetHigh() float64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *Kline) GetLow() float64 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *Kline) GetClose() float64 {
	if m != nil {
		return m.Close
	}
	return 0
}

func (m *Kline) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *Kline) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Kline) GetPosition() float64 {
	if m != nil {
		return m.Position
	}
	return 0
}

// KlineSeries K线序列
type KlineSeries struct {
	Symbol Symbol     `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	Period PeriodType `protobuf:"varint,2,opt,name=period,proto3,enum=pb.PeriodType" json:"period"`
	List   []Kline    `protobuf:"bytes,3,rep,name=list" json:"list"`
}

func (m *KlineSeries) Reset()                    { *m = KlineSeries{} }
func (m *KlineSeries) String() string            { return proto.CompactTextString(m) }
func (*KlineSeries) ProtoMessage()               {}
func (*KlineSeries) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

func (m *KlineSeries) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *KlineSeries) GetPeriod() PeriodType {
	if m != nil {
		return m.Period
	}
	return PeriodType_TICK
}

func (m *KlineSeries) GetList() []Kline {
	if m != nil {
		return m.List
	}
	return nil
}

// 经纪商信息
type BrokerRoute struct {
	Id             string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Type           int32    `protobuf:"varint,2,opt,name=type,proto3" json:"type"`
	Name           string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	MdFrontList    []string `protobuf:"bytes,4,rep,name=md_front_list,json=mdFrontList" json:"mdFrontList"`
	TradeFrontList []string `protobuf:"bytes,5,rep,name=trade_front_list,json=tradeFrontList" json:"tradeFrontList"`
}

func (m *BrokerRoute) Reset()                    { *m = BrokerRoute{} }
func (m *BrokerRoute) String() string            { return proto.CompactTextString(m) }
func (*BrokerRoute) ProtoMessage()               {}
func (*BrokerRoute) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

func (m *BrokerRoute) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BrokerRoute) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BrokerRoute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BrokerRoute) GetMdFrontList() []string {
	if m != nil {
		return m.MdFrontList
	}
	return nil
}

func (m *BrokerRoute) GetTradeFrontList() []string {
	if m != nil {
		return m.TradeFrontList
	}
	return nil
}

type BrokerRouteList struct {
	List []BrokerRoute `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *BrokerRouteList) Reset()                    { *m = BrokerRouteList{} }
func (m *BrokerRouteList) String() string            { return proto.CompactTextString(m) }
func (*BrokerRouteList) ProtoMessage()               {}
func (*BrokerRouteList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5} }

func (m *BrokerRouteList) GetList() []BrokerRoute {
	if m != nil {
		return m.List
	}
	return nil
}

// 合约行情信息
type InstrumentInfo struct {
	// / 合约名称.
	SymbolName string `protobuf:"bytes,1,opt,name=symbol_name,json=symbolName,proto3" json:"symbolName"`
	// / 是否单边大保
	PositionRank int32 `protobuf:"varint,2,opt,name=position_rank,json=positionRank,proto3" json:"positionRank"`
	// / 更新时间.
	UpdateTime int64 `protobuf:"varint,3,opt,name=update_time,json=updateTime,proto3" json:"updateTime"`
	// 交易日
	UpdateTradingDay int32 `protobuf:"varint,4,opt,name=update_trading_day,json=updateTradingDay,proto3" json:"updateTradingDay"`
	// / 涨停价.
	UpperLimitPrice float64 `protobuf:"fixed64,5,opt,name=upper_limit_price,json=upperLimitPrice,proto3" json:"upperLimitPrice"`
	// / 跌停价.
	LowerLimitPrice float64 `protobuf:"fixed64,6,opt,name=lower_limit_price,json=lowerLimitPrice,proto3" json:"lowerLimitPrice"`
	// 昨收
	PreClosePrice float64 `protobuf:"fixed64,7,opt,name=pre_close_price,json=preClosePrice,proto3" json:"preClosePrice"`
	// 昨结
	PreSettlementPrice float64 `protobuf:"fixed64,8,opt,name=pre_settlement_price,json=preSettlementPrice,proto3" json:"preSettlementPrice"`
	// 昨成交
	PreVolume int32 `protobuf:"varint,9,opt,name=pre_volume,json=preVolume,proto3" json:"preVolume"`
	// 昨持仓
	PrePosition int32 `protobuf:"varint,10,opt,name=pre_position,json=prePosition,proto3" json:"prePosition"`
	// 今天结算价
	SettlementPrice float64 `protobuf:"fixed64,11,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlementPrice"`
	// 创建日期
	CreateDate int32 `protobuf:"varint,12,opt,name=create_date,json=createDate,proto3" json:"createDate"`
	// 上市日期
	OpenDate int32 `protobuf:"varint,13,opt,name=open_date,json=openDate,proto3" json:"openDate"`
	// 到期日期
	ExpireDate int32 `protobuf:"varint,14,opt,name=expire_date,json=expireDate,proto3" json:"expireDate"`
	// 开始交割日期
	StartDeliverDate int32 `protobuf:"varint,15,opt,name=start_deliver_date,json=startDeliverDate,proto3" json:"startDeliverDate"`
	// 结束交割日期
	EndDeliverDate int32 `protobuf:"varint,16,opt,name=end_deliver_date,json=endDeliverDate,proto3" json:"endDeliverDate"`
	// 是否T+0
	IsCloseTodayAllowed int32 `protobuf:"varint,17,opt,name=is_close_today_allowed,json=isCloseTodayAllowed,proto3" json:"isCloseTodayAllowed"`
	// 市价最大下单量
	MaxMarketOrderVolume int32 `protobuf:"varint,18,opt,name=max_market_order_volume,json=maxMarketOrderVolume,proto3" json:"maxMarketOrderVolume"`
	// 市价最小下单量
	MinMarketOrderVolume int32 `protobuf:"varint,19,opt,name=min_market_order_volume,json=minMarketOrderVolume,proto3" json:"minMarketOrderVolume"`
	// 限价最大下单量
	MaxLimitOrderVolume int32 `protobuf:"varint,20,opt,name=max_limit_order_volume,json=maxLimitOrderVolume,proto3" json:"maxLimitOrderVolume"`
	// 限价最小下单量
	MinLimitOrderVolume int32 `protobuf:"varint,21,opt,name=min_limit_order_volume,json=minLimitOrderVolume,proto3" json:"minLimitOrderVolume"`
	// 基础合约
	BaseSymbol Symbol `protobuf:"bytes,22,opt,name=base_symbol,json=baseSymbol" json:"baseSymbol"`
	// 行权价
	StrikePrice float64 `protobuf:"fixed64,23,opt,name=strike_price,json=strikePrice,proto3" json:"strikePrice"`
}

func (m *InstrumentInfo) Reset()                    { *m = InstrumentInfo{} }
func (m *InstrumentInfo) String() string            { return proto.CompactTextString(m) }
func (*InstrumentInfo) ProtoMessage()               {}
func (*InstrumentInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{6} }

func (m *InstrumentInfo) GetSymbolName() string {
	if m != nil {
		return m.SymbolName
	}
	return ""
}

func (m *InstrumentInfo) GetPositionRank() int32 {
	if m != nil {
		return m.PositionRank
	}
	return 0
}

func (m *InstrumentInfo) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *InstrumentInfo) GetUpdateTradingDay() int32 {
	if m != nil {
		return m.UpdateTradingDay
	}
	return 0
}

func (m *InstrumentInfo) GetUpperLimitPrice() float64 {
	if m != nil {
		return m.UpperLimitPrice
	}
	return 0
}

func (m *InstrumentInfo) GetLowerLimitPrice() float64 {
	if m != nil {
		return m.LowerLimitPrice
	}
	return 0
}

func (m *InstrumentInfo) GetPreClosePrice() float64 {
	if m != nil {
		return m.PreClosePrice
	}
	return 0
}

func (m *InstrumentInfo) GetPreSettlementPrice() float64 {
	if m != nil {
		return m.PreSettlementPrice
	}
	return 0
}

func (m *InstrumentInfo) GetPreVolume() int32 {
	if m != nil {
		return m.PreVolume
	}
	return 0
}

func (m *InstrumentInfo) GetPrePosition() int32 {
	if m != nil {
		return m.PrePosition
	}
	return 0
}

func (m *InstrumentInfo) GetSettlementPrice() float64 {
	if m != nil {
		return m.SettlementPrice
	}
	return 0
}

func (m *InstrumentInfo) GetCreateDate() int32 {
	if m != nil {
		return m.CreateDate
	}
	return 0
}

func (m *InstrumentInfo) GetOpenDate() int32 {
	if m != nil {
		return m.OpenDate
	}
	return 0
}

func (m *InstrumentInfo) GetExpireDate() int32 {
	if m != nil {
		return m.ExpireDate
	}
	return 0
}

func (m *InstrumentInfo) GetStartDeliverDate() int32 {
	if m != nil {
		return m.StartDeliverDate
	}
	return 0
}

func (m *InstrumentInfo) GetEndDeliverDate() int32 {
	if m != nil {
		return m.EndDeliverDate
	}
	return 0
}

func (m *InstrumentInfo) GetIsCloseTodayAllowed() int32 {
	if m != nil {
		return m.IsCloseTodayAllowed
	}
	return 0
}

func (m *InstrumentInfo) GetMaxMarketOrderVolume() int32 {
	if m != nil {
		return m.MaxMarketOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetMinMarketOrderVolume() int32 {
	if m != nil {
		return m.MinMarketOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetMaxLimitOrderVolume() int32 {
	if m != nil {
		return m.MaxLimitOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetMinLimitOrderVolume() int32 {
	if m != nil {
		return m.MinLimitOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetBaseSymbol() Symbol {
	if m != nil {
		return m.BaseSymbol
	}
	return Symbol{}
}

func (m *InstrumentInfo) GetStrikePrice() float64 {
	if m != nil {
		return m.StrikePrice
	}
	return 0
}

type SimpleTimePeriod struct {
	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end"`
}

func (m *SimpleTimePeriod) Reset()                    { *m = SimpleTimePeriod{} }
func (m *SimpleTimePeriod) String() string            { return proto.CompactTextString(m) }
func (*SimpleTimePeriod) ProtoMessage()               {}
func (*SimpleTimePeriod) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{7} }

func (m *SimpleTimePeriod) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SimpleTimePeriod) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

type MarketTimeRule struct {
	SendRule     []SimpleTimePeriod `protobuf:"bytes,1,rep,name=send_rule,json=sendRule" json:"sendRule"`
	CancelRule   []SimpleTimePeriod `protobuf:"bytes,2,rep,name=cancel_rule,json=cancelRule" json:"cancelRule"`
	MatchingRule []SimpleTimePeriod `protobuf:"bytes,3,rep,name=matching_rule,json=matchingRule" json:"matchingRule"`
}

func (m *MarketTimeRule) Reset()                    { *m = MarketTimeRule{} }
func (m *MarketTimeRule) String() string            { return proto.CompactTextString(m) }
func (*MarketTimeRule) ProtoMessage()               {}
func (*MarketTimeRule) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{8} }

func (m *MarketTimeRule) GetSendRule() []SimpleTimePeriod {
	if m != nil {
		return m.SendRule
	}
	return nil
}

func (m *MarketTimeRule) GetCancelRule() []SimpleTimePeriod {
	if m != nil {
		return m.CancelRule
	}
	return nil
}

func (m *MarketTimeRule) GetMatchingRule() []SimpleTimePeriod {
	if m != nil {
		return m.MatchingRule
	}
	return nil
}

// 品种信息.
type ProductInfo struct {
	// 品种代码.
	ProductId ProductID `protobuf:"bytes,1,opt,name=product_id,json=productId" json:"productId"`
	// 子类型
	ProductGroupId ProductID `protobuf:"bytes,2,opt,name=product_group_id,json=productGroupId" json:"productGroupId"`
	// 类型
	Type int32 `protobuf:"varint,3,opt,name=type,proto3" json:"type"`
	// / 品种名称
	ProductName string `protobuf:"bytes,4,opt,name=product_name,json=productName,proto3" json:"productName"`
	// 最小变动价位.
	PriceTick float64 `protobuf:"fixed64,5,opt,name=price_tick,json=priceTick,proto3" json:"priceTick"`
	// 合约乘数
	VolumeMultiple int32 `protobuf:"varint,6,opt,name=volume_multiple,json=volumeMultiple,proto3" json:"volumeMultiple"`
	// 昨总成交
	PreVolume int32 `protobuf:"varint,7,opt,name=pre_volume,json=preVolume,proto3" json:"preVolume"`
	// 昨持仓
	PrePosition int32 `protobuf:"varint,8,opt,name=pre_position,json=prePosition,proto3" json:"prePosition"`
	// 币种
	CurrencyType int32 `protobuf:"varint,9,opt,name=currency_type,json=currencyType,proto3" json:"currencyType"`
	// 结算组
	SettlementGroup int32 `protobuf:"varint,10,opt,name=settlement_group,json=settlementGroup,proto3" json:"settlementGroup"`
	// 时间
	TimeRule MarketTimeRule `protobuf:"bytes,11,opt,name=time_rule,json=timeRule" json:"timeRule"`
}

func (m *ProductInfo) Reset()                    { *m = ProductInfo{} }
func (m *ProductInfo) String() string            { return proto.CompactTextString(m) }
func (*ProductInfo) ProtoMessage()               {}
func (*ProductInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{9} }

func (m *ProductInfo) GetProductId() ProductID {
	if m != nil {
		return m.ProductId
	}
	return ProductID{}
}

func (m *ProductInfo) GetProductGroupId() ProductID {
	if m != nil {
		return m.ProductGroupId
	}
	return ProductID{}
}

func (m *ProductInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ProductInfo) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *ProductInfo) GetPriceTick() float64 {
	if m != nil {
		return m.PriceTick
	}
	return 0
}

func (m *ProductInfo) GetVolumeMultiple() int32 {
	if m != nil {
		return m.VolumeMultiple
	}
	return 0
}

func (m *ProductInfo) GetPreVolume() int32 {
	if m != nil {
		return m.PreVolume
	}
	return 0
}

func (m *ProductInfo) GetPrePosition() int32 {
	if m != nil {
		return m.PrePosition
	}
	return 0
}

func (m *ProductInfo) GetCurrencyType() int32 {
	if m != nil {
		return m.CurrencyType
	}
	return 0
}

func (m *ProductInfo) GetSettlementGroup() int32 {
	if m != nil {
		return m.SettlementGroup
	}
	return 0
}

func (m *ProductInfo) GetTimeRule() MarketTimeRule {
	if m != nil {
		return m.TimeRule
	}
	return MarketTimeRule{}
}

// 交易合约
type TradingInstrument struct {
	// / 合约编码
	Symbol Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	// 合约信息
	InstrumentInfo InstrumentInfo `protobuf:"bytes,2,opt,name=instrument_info,json=instrumentInfo" json:"instrumentInfo"`
	// 品种信息
	ProductInfo ProductInfo `protobuf:"bytes,3,opt,name=product_info,json=productInfo" json:"productInfo"`
}

func (m *TradingInstrument) Reset()                    { *m = TradingInstrument{} }
func (m *TradingInstrument) String() string            { return proto.CompactTextString(m) }
func (*TradingInstrument) ProtoMessage()               {}
func (*TradingInstrument) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{10} }

func (m *TradingInstrument) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *TradingInstrument) GetInstrumentInfo() InstrumentInfo {
	if m != nil {
		return m.InstrumentInfo
	}
	return InstrumentInfo{}
}

func (m *TradingInstrument) GetProductInfo() ProductInfo {
	if m != nil {
		return m.ProductInfo
	}
	return ProductInfo{}
}

type TradingInstrumentList struct {
	List []TradingInstrument `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *TradingInstrumentList) Reset()                    { *m = TradingInstrumentList{} }
func (m *TradingInstrumentList) String() string            { return proto.CompactTextString(m) }
func (*TradingInstrumentList) ProtoMessage()               {}
func (*TradingInstrumentList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{11} }

func (m *TradingInstrumentList) GetList() []TradingInstrument {
	if m != nil {
		return m.List
	}
	return nil
}

type ProductInfoList struct {
	List []ProductInfo `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *ProductInfoList) Reset()                    { *m = ProductInfoList{} }
func (m *ProductInfoList) String() string            { return proto.CompactTextString(m) }
func (*ProductInfoList) ProtoMessage()               {}
func (*ProductInfoList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{12} }

func (m *ProductInfoList) GetList() []ProductInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type ReqSetTradingInstrumentList struct {
	OpCode   string              `protobuf:"bytes,1,opt,name=op_code,json=opCode,proto3" json:"opCode"`
	Exchange int32               `protobuf:"varint,2,opt,name=exchange,proto3" json:"exchange"`
	List     []TradingInstrument `protobuf:"bytes,3,rep,name=list" json:"list"`
}

func (m *ReqSetTradingInstrumentList) Reset()         { *m = ReqSetTradingInstrumentList{} }
func (m *ReqSetTradingInstrumentList) String() string { return proto.CompactTextString(m) }
func (*ReqSetTradingInstrumentList) ProtoMessage()    {}
func (*ReqSetTradingInstrumentList) Descriptor() ([]byte, []int) {
	return fileDescriptorCommon, []int{13}
}

func (m *ReqSetTradingInstrumentList) GetOpCode() string {
	if m != nil {
		return m.OpCode
	}
	return ""
}

func (m *ReqSetTradingInstrumentList) GetExchange() int32 {
	if m != nil {
		return m.Exchange
	}
	return 0
}

func (m *ReqSetTradingInstrumentList) GetList() []TradingInstrument {
	if m != nil {
		return m.List
	}
	return nil
}

type ReqSetProductInfoList struct {
	OpCode   string        `protobuf:"bytes,1,opt,name=op_code,json=opCode,proto3" json:"opCode"`
	Exchange int32         `protobuf:"varint,2,opt,name=exchange,proto3" json:"exchange"`
	List     []ProductInfo `protobuf:"bytes,3,rep,name=list" json:"list"`
}

func (m *ReqSetProductInfoList) Reset()                    { *m = ReqSetProductInfoList{} }
func (m *ReqSetProductInfoList) String() string            { return proto.CompactTextString(m) }
func (*ReqSetProductInfoList) ProtoMessage()               {}
func (*ReqSetProductInfoList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{14} }

func (m *ReqSetProductInfoList) GetOpCode() string {
	if m != nil {
		return m.OpCode
	}
	return ""
}

func (m *ReqSetProductInfoList) GetExchange() int32 {
	if m != nil {
		return m.Exchange
	}
	return 0
}

func (m *ReqSetProductInfoList) GetList() []ProductInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type ReqUpdateTIOpenDate struct {
	Symbol   Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	OpenDate int32  `protobuf:"varint,2,opt,name=open_date,json=openDate,proto3" json:"openDate"`
}

func (m *ReqUpdateTIOpenDate) Reset()                    { *m = ReqUpdateTIOpenDate{} }
func (m *ReqUpdateTIOpenDate) String() string            { return proto.CompactTextString(m) }
func (*ReqUpdateTIOpenDate) ProtoMessage()               {}
func (*ReqUpdateTIOpenDate) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{15} }

func (m *ReqUpdateTIOpenDate) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *ReqUpdateTIOpenDate) GetOpenDate() int32 {
	if m != nil {
		return m.OpenDate
	}
	return 0
}

type ReqUpdateTIOpenDateList struct {
	Exchange int32                 `protobuf:"varint,1,opt,name=exchange,proto3" json:"exchange"`
	List     []ReqUpdateTIOpenDate `protobuf:"bytes,2,rep,name=list" json:"list"`
	OpCode   string                `protobuf:"bytes,3,opt,name=op_code,json=opCode,proto3" json:"opCode"`
}

func (m *ReqUpdateTIOpenDateList) Reset()                    { *m = ReqUpdateTIOpenDateList{} }
func (m *ReqUpdateTIOpenDateList) String() string            { return proto.CompactTextString(m) }
func (*ReqUpdateTIOpenDateList) ProtoMessage()               {}
func (*ReqUpdateTIOpenDateList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{16} }

func (m *ReqUpdateTIOpenDateList) GetExchange() int32 {
	if m != nil {
		return m.Exchange
	}
	return 0
}

func (m *ReqUpdateTIOpenDateList) GetList() []ReqUpdateTIOpenDate {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *ReqUpdateTIOpenDateList) GetOpCode() string {
	if m != nil {
		return m.OpCode
	}
	return ""
}

// 结算账户资金信息
type AccountMoneySummary struct {
	// 账号
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// 结算组（可能单个结算组给个摘要)
	Type AccountType `protobuf:"varint,2,opt,name=type,proto3,enum=pb.AccountType" json:"type"`
	// 币种
	CurrencyType CurrencyType `protobuf:"varint,3,opt,name=currency_type,json=currencyType,proto3,enum=pb.CurrencyType" json:"currencyType"`
	// / 余额
	Balance float64 `protobuf:"fixed64,4,opt,name=balance,proto3" json:"balance"`
	// / 手续费
	Commission float64 `protobuf:"fixed64,5,opt,name=commission,proto3" json:"commission"`
	// / 占用保证金
	CurMargin float64 `protobuf:"fixed64,6,opt,name=cur_margin,json=curMargin,proto3" json:"curMargin"`
	// / 持仓市值.
	NetPositionAmount float64 `protobuf:"fixed64,7,opt,name=net_position_amount,json=netPositionAmount,proto3" json:"netPositionAmount"`
	// / 上次余额
	PreBalance float64 `protobuf:"fixed64,8,opt,name=pre_balance,json=preBalance,proto3" json:"preBalance"`
	// / 利息收入
	InterestIn float64 `protobuf:"fixed64,9,opt,name=interest_in,json=interestIn,proto3" json:"interestIn"`
	// / 存款
	Deposit float64 `protobuf:"fixed64,10,opt,name=deposit,proto3" json:"deposit"`
	// / 取款
	Withdraw float64 `protobuf:"fixed64,11,opt,name=withdraw,proto3" json:"withdraw"`
	// / 冻结保证金
	FrozenMargin float64 `protobuf:"fixed64,12,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozenMargin"`
	// / 冻结手续费
	FrozenCommission float64 `protobuf:"fixed64,13,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozenCommission"`
	// / 可用资金
	Available float64 `protobuf:"fixed64,14,opt,name=available,proto3" json:"available"`
	// / 平仓盈亏
	CloseProfit float64 `protobuf:"fixed64,15,opt,name=close_profit,json=closeProfit,proto3" json:"closeProfit"`
	// / 持仓盈亏
	PositionProfit float64 `protobuf:"fixed64,16,opt,name=position_profit,json=positionProfit,proto3" json:"positionProfit"`
	// 上次质押金额
	PreMortgate float64 `protobuf:"fixed64,17,opt,name=pre_mortgate,json=preMortgate,proto3" json:"preMortgate"`
	// 上次信用额度
	PreCredit float64 `protobuf:"fixed64,18,opt,name=pre_credit,json=preCredit,proto3" json:"preCredit"`
	// 利息基数
	InterestBase float64 `protobuf:"fixed64,19,opt,name=interest_base,json=interestBase,proto3" json:"interestBase"`
	// 可取资金
	WithdrawAvailable float64 `protobuf:"fixed64,20,opt,name=withdraw_available,json=withdrawAvailable,proto3" json:"withdrawAvailable"`
	// 基本准备金
	Reserve float64 `protobuf:"fixed64,21,opt,name=reserve,proto3" json:"reserve"`
	// 交易日
	TradingDay int32 `protobuf:"varint,22,opt,name=trading_day,json=tradingDay,proto3" json:"tradingDay"`
	// 信用额度
	Credit float64 `protobuf:"fixed64,23,opt,name=credit,proto3" json:"credit"`
	// 质押金额
	Mortgate float64 `protobuf:"fixed64,24,opt,name=mortgate,proto3" json:"mortgate"`
	// 交易所保证金
	ExchangeMargin float64 `protobuf:"fixed64,25,opt,name=exchange_margin,json=exchangeMargin,proto3" json:"exchangeMargin"`
	// 交割保证金
	DeliveryMargin float64 `protobuf:"fixed64,26,opt,name=delivery_margin,json=deliveryMargin,proto3" json:"deliveryMargin"`
	// 交易所交割保证金
	ExchangeDeliveryMargin float64 `protobuf:"fixed64,27,opt,name=exchange_delivery_margin,json=exchangeDeliveryMargin,proto3" json:"exchangeDeliveryMargin"`
	// 保底期货结算准备金
	ReserveBalance float64 `protobuf:"fixed64,28,opt,name=reserve_balance,json=reserveBalance,proto3" json:"reserveBalance"`
	// 交割手续费
	DeliveryCommission float64 `protobuf:"fixed64,29,opt,name=delivery_commission,json=deliveryCommission,proto3" json:"deliveryCommission"`
	// 冻结过户费
	FrozenTransferFee float64 `protobuf:"fixed64,30,opt,name=frozen_transfer_fee,json=frozenTransferFee,proto3" json:"frozenTransferFee"`
	// 冻结的印花税
	FrozenStampTax float64 `protobuf:"fixed64,31,opt,name=frozen_stamp_tax,json=frozenStampTax,proto3" json:"frozenStampTax"`
	// 过户费
	TransferFee float64 `protobuf:"fixed64,32,opt,name=transfer_fee,json=transferFee,proto3" json:"transferFee"`
	// 印花税
	StampTax float64 `protobuf:"fixed64,33,opt,name=stamp_tax,json=stampTax,proto3" json:"stampTax"`
	// / 盯市盈亏
	MtmProfit float64 `protobuf:"fixed64,34,opt,name=mtm_profit,json=mtmProfit,proto3" json:"mtmProfit"`
	// /授信额度
	PreMtmProfit float64 `protobuf:"fixed64,35,opt,name=pre_mtm_profit,json=preMtmProfit,proto3" json:"preMtmProfit"`
	// /证券总价值
	StockValue float64 `protobuf:"fixed64,36,opt,name=stock_value,json=stockValue,proto3" json:"stockValue"`
	// /国债回购占用资金
	BondRepurchaseAmount float64 `protobuf:"fixed64,37,opt,name=bond_repurchase_amount,json=bondRepurchaseAmount,proto3" json:"bondRepurchaseAmount"`
	// /国债逆回购占用资金
	ReverseRepurchaseAmount float64 `protobuf:"fixed64,38,opt,name=reverse_repurchase_amount,json=reverseRepurchaseAmount,proto3" json:"reverseRepurchaseAmount"`
	// /融资买入金额
	MarginTradeAmount float64 `protobuf:"fixed64,39,opt,name=margin_trade_amount,json=marginTradeAmount,proto3" json:"marginTradeAmount"`
	// /融券卖出金额
	ShortSellAmount float64 `protobuf:"fixed64,40,opt,name=short_sell_amount,json=shortSellAmount,proto3" json:"shortSellAmount"`
	// /融资持仓盈亏
	MarginTradeProfit float64 `protobuf:"fixed64,41,opt,name=margin_trade_profit,json=marginTradeProfit,proto3" json:"marginTradeProfit"`
	// /融券持仓盈亏
	ShortSellProfit float64 `protobuf:"fixed64,42,opt,name=short_sell_profit,json=shortSellProfit,proto3" json:"shortSellProfit"`
	// 冻结平仓所需要费用
	FrozenCloseCommission float64 `protobuf:"fixed64,43,opt,name=frozen_close_commission,json=frozenCloseCommission,proto3" json:"frozenCloseCommission"`
	// 劣后
	CommonBalance float64 `protobuf:"fixed64,44,opt,name=common_balance,json=commonBalance,proto3" json:"commonBalance"`
	// 优先资金
	PreferedBalance float64 `protobuf:"fixed64,45,opt,name=prefered_balance,json=preferedBalance,proto3" json:"preferedBalance"`
	// 兑换基础货币汇率
	BaseExchangeRate float64 `protobuf:"fixed64,46,opt,name=base_exchange_rate,json=baseExchangeRate,proto3" json:"baseExchangeRate"`
	// 报警
	WarningLevel float64 `protobuf:"fixed64,47,opt,name=warning_level,json=warningLevel,proto3" json:"warningLevel"`
	// 强平
	ForceCloseLevel float64 `protobuf:"fixed64,48,opt,name=force_close_level,json=forceCloseLevel,proto3" json:"forceCloseLevel"`
	// 进入清算的平仓盈亏
	ClearedClosedProfit float64 `protobuf:"fixed64,49,opt,name=cleared_closed_profit,json=clearedClosedProfit,proto3" json:"clearedClosedProfit"`
	// 名称
	Name string `protobuf:"bytes,50,opt,name=name,proto3" json:"name"`
	// 利息
	Interest float64 `protobuf:"fixed64,51,opt,name=interest,proto3" json:"interest"`
	// 冻结利息
	FrozenInterest float64 `protobuf:"fixed64,52,opt,name=frozen_interest,json=frozenInterest,proto3" json:"frozenInterest"`
}

func (m *AccountMoneySummary) Reset()                    { *m = AccountMoneySummary{} }
func (m *AccountMoneySummary) String() string            { return proto.CompactTextString(m) }
func (*AccountMoneySummary) ProtoMessage()               {}
func (*AccountMoneySummary) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{17} }

func (m *AccountMoneySummary) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AccountMoneySummary) GetType() AccountType {
	if m != nil {
		return m.Type
	}
	return AccountType_CN_FUTURE
}

func (m *AccountMoneySummary) GetCurrencyType() CurrencyType {
	if m != nil {
		return m.CurrencyType
	}
	return CurrencyType_CNY
}

func (m *AccountMoneySummary) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *AccountMoneySummary) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *AccountMoneySummary) GetCurMargin() float64 {
	if m != nil {
		return m.CurMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetNetPositionAmount() float64 {
	if m != nil {
		return m.NetPositionAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetPreBalance() float64 {
	if m != nil {
		return m.PreBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetInterestIn() float64 {
	if m != nil {
		return m.InterestIn
	}
	return 0
}

func (m *AccountMoneySummary) GetDeposit() float64 {
	if m != nil {
		return m.Deposit
	}
	return 0
}

func (m *AccountMoneySummary) GetWithdraw() float64 {
	if m != nil {
		return m.Withdraw
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *AccountMoneySummary) GetAvailable() float64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *AccountMoneySummary) GetCloseProfit() float64 {
	if m != nil {
		return m.CloseProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetPreMortgate() float64 {
	if m != nil {
		return m.PreMortgate
	}
	return 0
}

func (m *AccountMoneySummary) GetPreCredit() float64 {
	if m != nil {
		return m.PreCredit
	}
	return 0
}

func (m *AccountMoneySummary) GetInterestBase() float64 {
	if m != nil {
		return m.InterestBase
	}
	return 0
}

func (m *AccountMoneySummary) GetWithdrawAvailable() float64 {
	if m != nil {
		return m.WithdrawAvailable
	}
	return 0
}

func (m *AccountMoneySummary) GetReserve() float64 {
	if m != nil {
		return m.Reserve
	}
	return 0
}

func (m *AccountMoneySummary) GetTradingDay() int32 {
	if m != nil {
		return m.TradingDay
	}
	return 0
}

func (m *AccountMoneySummary) GetCredit() float64 {
	if m != nil {
		return m.Credit
	}
	return 0
}

func (m *AccountMoneySummary) GetMortgate() float64 {
	if m != nil {
		return m.Mortgate
	}
	return 0
}

func (m *AccountMoneySummary) GetExchangeMargin() float64 {
	if m != nil {
		return m.ExchangeMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetDeliveryMargin() float64 {
	if m != nil {
		return m.DeliveryMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetExchangeDeliveryMargin() float64 {
	if m != nil {
		return m.ExchangeDeliveryMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetReserveBalance() float64 {
	if m != nil {
		return m.ReserveBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetDeliveryCommission() float64 {
	if m != nil {
		return m.DeliveryCommission
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenTransferFee() float64 {
	if m != nil {
		return m.FrozenTransferFee
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenStampTax() float64 {
	if m != nil {
		return m.FrozenStampTax
	}
	return 0
}

func (m *AccountMoneySummary) GetTransferFee() float64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

func (m *AccountMoneySummary) GetStampTax() float64 {
	if m != nil {
		return m.StampTax
	}
	return 0
}

func (m *AccountMoneySummary) GetMtmProfit() float64 {
	if m != nil {
		return m.MtmProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetPreMtmProfit() float64 {
	if m != nil {
		return m.PreMtmProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetStockValue() float64 {
	if m != nil {
		return m.StockValue
	}
	return 0
}

func (m *AccountMoneySummary) GetBondRepurchaseAmount() float64 {
	if m != nil {
		return m.BondRepurchaseAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetReverseRepurchaseAmount() float64 {
	if m != nil {
		return m.ReverseRepurchaseAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetMarginTradeAmount() float64 {
	if m != nil {
		return m.MarginTradeAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetShortSellAmount() float64 {
	if m != nil {
		return m.ShortSellAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetMarginTradeProfit() float64 {
	if m != nil {
		return m.MarginTradeProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetShortSellProfit() float64 {
	if m != nil {
		return m.ShortSellProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenCloseCommission() float64 {
	if m != nil {
		return m.FrozenCloseCommission
	}
	return 0
}

func (m *AccountMoneySummary) GetCommonBalance() float64 {
	if m != nil {
		return m.CommonBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetPreferedBalance() float64 {
	if m != nil {
		return m.PreferedBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetBaseExchangeRate() float64 {
	if m != nil {
		return m.BaseExchangeRate
	}
	return 0
}

func (m *AccountMoneySummary) GetWarningLevel() float64 {
	if m != nil {
		return m.WarningLevel
	}
	return 0
}

func (m *AccountMoneySummary) GetForceCloseLevel() float64 {
	if m != nil {
		return m.ForceCloseLevel
	}
	return 0
}

func (m *AccountMoneySummary) GetClearedClosedProfit() float64 {
	if m != nil {
		return m.ClearedClosedProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AccountMoneySummary) GetInterest() float64 {
	if m != nil {
		return m.Interest
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenInterest() float64 {
	if m != nil {
		return m.FrozenInterest
	}
	return 0
}

type AccountMoneySummaryList struct {
	List []AccountMoneySummary `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *AccountMoneySummaryList) Reset()                    { *m = AccountMoneySummaryList{} }
func (m *AccountMoneySummaryList) String() string            { return proto.CompactTextString(m) }
func (*AccountMoneySummaryList) ProtoMessage()               {}
func (*AccountMoneySummaryList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{18} }

func (m *AccountMoneySummaryList) GetList() []AccountMoneySummary {
	if m != nil {
		return m.List
	}
	return nil
}

// 出入金操作
type MoneyTransferRecord struct {
	// ID
	Uid int64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid"`
	// 出入
	Direction int32 `protobuf:"varint,2,opt,name=direction,proto3" json:"direction"`
	// 币种
	CurrencyType int32 `protobuf:"varint,3,opt,name=currency_type,json=currencyType,proto3" json:"currencyType"`
	// 结算组
	SettlementGroup int32 `protobuf:"varint,4,opt,name=settlement_group,json=settlementGroup,proto3" json:"settlementGroup"`
	// 是否确认
	Confirmed int32 `protobuf:"varint,5,opt,name=confirmed,proto3" json:"confirmed"`
	// 优先
	IsPrefered int32 `protobuf:"varint,6,opt,name=is_prefered,json=isPrefered,proto3" json:"isPrefered"`
	// 金额
	Amount float64 `protobuf:"fixed64,7,opt,name=amount,proto3" json:"amount"`
	// 账户
	AccountId string `protobuf:"bytes,8,opt,name=account_id,json=accountId,proto3" json:"accountId"`
	// 操作员
	OperatorId string `protobuf:"bytes,9,opt,name=operator_id,json=operatorId,proto3" json:"operatorId"`
	// 会话编号
	SessionId int32 `protobuf:"varint,10,opt,name=session_id,json=sessionId,proto3" json:"sessionId"`
	// 请求时间
	Time int64 `protobuf:"varint,11,opt,name=time,proto3" json:"time"`
	// 备注
	Comment string `protobuf:"bytes,12,opt,name=comment,proto3" json:"comment"`
	// 第三方单号
	BankTradeId string `protobuf:"bytes,13,opt,name=bank_trade_id,json=bankTradeId,proto3" json:"bankTradeId"`
	// 配置编号，用于出金
	PaymentConfigId int64 `protobuf:"varint,14,opt,name=payment_config_id,json=paymentConfigId,proto3" json:"paymentConfigId"`
	// 原始金额
	OriginalAmount float64 `protobuf:"fixed64,15,opt,name=original_amount,json=originalAmount,proto3" json:"originalAmount"`
	// 费用
	Fee float64 `protobuf:"fixed64,16,opt,name=fee,proto3" json:"fee"`
	// 通道
	PaymentPath string `protobuf:"bytes,17,opt,name=payment_path,json=paymentPath,proto3" json:"paymentPath"`
	// 身份证号
	IdentityNumber string `protobuf:"bytes,18,opt,name=identity_number,json=identityNumber,proto3" json:"identityNumber"`
	// 电话
	PhoneNumber string `protobuf:"bytes,19,opt,name=phone_number,json=phoneNumber,proto3" json:"phoneNumber"`
	// 银行名称
	BankName string `protobuf:"bytes,20,opt,name=bank_name,json=bankName,proto3" json:"bankName"`
	// 支行名称
	BankBranchName string `protobuf:"bytes,21,opt,name=bank_branch_name,json=bankBranchName,proto3" json:"bankBranchName"`
	// 银行卡号
	BankCardNo string `protobuf:"bytes,22,opt,name=bank_card_no,json=bankCardNo,proto3" json:"bankCardNo"`
	// 省份
	Province string `protobuf:"bytes,23,opt,name=province,proto3" json:"province"`
	// 城市
	City string `protobuf:"bytes,24,opt,name=city,proto3" json:"city"`
	// 支付方式代码
	PayType string `protobuf:"bytes,25,opt,name=pay_type,json=payType,proto3" json:"payType"`
	// 支付时间
	PayedTime int64 `protobuf:"varint,26,opt,name=payed_time,json=payedTime,proto3" json:"payedTime"`
	// 确认时间
	ConfirmedTime int64 `protobuf:"varint,27,opt,name=confirmed_time,json=confirmedTime,proto3" json:"confirmedTime"`
	// 名称
	Name string `protobuf:"bytes,28,opt,name=name,proto3" json:"name"`
}

func (m *MoneyTransferRecord) Reset()                    { *m = MoneyTransferRecord{} }
func (m *MoneyTransferRecord) String() string            { return proto.CompactTextString(m) }
func (*MoneyTransferRecord) ProtoMessage()               {}
func (*MoneyTransferRecord) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{19} }

func (m *MoneyTransferRecord) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *MoneyTransferRecord) GetDirection() int32 {
	if m != nil {
		return m.Direction
	}
	return 0
}

func (m *MoneyTransferRecord) GetCurrencyType() int32 {
	if m != nil {
		return m.CurrencyType
	}
	return 0
}

func (m *MoneyTransferRecord) GetSettlementGroup() int32 {
	if m != nil {
		return m.SettlementGroup
	}
	return 0
}

func (m *MoneyTransferRecord) GetConfirmed() int32 {
	if m != nil {
		return m.Confirmed
	}
	return 0
}

func (m *MoneyTransferRecord) GetIsPrefered() int32 {
	if m != nil {
		return m.IsPrefered
	}
	return 0
}

func (m *MoneyTransferRecord) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MoneyTransferRecord) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *MoneyTransferRecord) GetOperatorId() string {
	if m != nil {
		return m.OperatorId
	}
	return ""
}

func (m *MoneyTransferRecord) GetSessionId() int32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MoneyTransferRecord) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MoneyTransferRecord) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankTradeId() string {
	if m != nil {
		return m.BankTradeId
	}
	return ""
}

func (m *MoneyTransferRecord) GetPaymentConfigId() int64 {
	if m != nil {
		return m.PaymentConfigId
	}
	return 0
}

func (m *MoneyTransferRecord) GetOriginalAmount() float64 {
	if m != nil {
		return m.OriginalAmount
	}
	return 0
}

func (m *MoneyTransferRecord) GetFee() float64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *MoneyTransferRecord) GetPaymentPath() string {
	if m != nil {
		return m.PaymentPath
	}
	return ""
}

func (m *MoneyTransferRecord) GetIdentityNumber() string {
	if m != nil {
		return m.IdentityNumber
	}
	return ""
}

func (m *MoneyTransferRecord) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankName() string {
	if m != nil {
		return m.BankName
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankBranchName() string {
	if m != nil {
		return m.BankBranchName
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankCardNo() string {
	if m != nil {
		return m.BankCardNo
	}
	return ""
}

func (m *MoneyTransferRecord) GetProvince() string {
	if m != nil {
		return m.Province
	}
	return ""
}

func (m *MoneyTransferRecord) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *MoneyTransferRecord) GetPayType() string {
	if m != nil {
		return m.PayType
	}
	return ""
}

func (m *MoneyTransferRecord) GetPayedTime() int64 {
	if m != nil {
		return m.PayedTime
	}
	return 0
}

func (m *MoneyTransferRecord) GetConfirmedTime() int64 {
	if m != nil {
		return m.ConfirmedTime
	}
	return 0
}

func (m *MoneyTransferRecord) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MTRList struct {
	List []MoneyTransferRecord `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *MTRList) Reset()                    { *m = MTRList{} }
func (m *MTRList) String() string            { return proto.CompactTextString(m) }
func (*MTRList) ProtoMessage()               {}
func (*MTRList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{20} }

func (m *MTRList) GetList() []MoneyTransferRecord {
	if m != nil {
		return m.List
	}
	return nil
}

func init() {
	proto.RegisterType((*Symbol)(nil), "pb.Symbol")
	proto.RegisterType((*ProductID)(nil), "pb.ProductID")
	proto.RegisterType((*Kline)(nil), "pb.Kline")
	proto.RegisterType((*KlineSeries)(nil), "pb.KlineSeries")
	proto.RegisterType((*BrokerRoute)(nil), "pb.BrokerRoute")
	proto.RegisterType((*BrokerRouteList)(nil), "pb.BrokerRouteList")
	proto.RegisterType((*InstrumentInfo)(nil), "pb.InstrumentInfo")
	proto.RegisterType((*SimpleTimePeriod)(nil), "pb.SimpleTimePeriod")
	proto.RegisterType((*MarketTimeRule)(nil), "pb.MarketTimeRule")
	proto.RegisterType((*ProductInfo)(nil), "pb.ProductInfo")
	proto.RegisterType((*TradingInstrument)(nil), "pb.TradingInstrument")
	proto.RegisterType((*TradingInstrumentList)(nil), "pb.TradingInstrumentList")
	proto.RegisterType((*ProductInfoList)(nil), "pb.ProductInfoList")
	proto.RegisterType((*ReqSetTradingInstrumentList)(nil), "pb.ReqSetTradingInstrumentList")
	proto.RegisterType((*ReqSetProductInfoList)(nil), "pb.ReqSetProductInfoList")
	proto.RegisterType((*ReqUpdateTIOpenDate)(nil), "pb.ReqUpdateTIOpenDate")
	proto.RegisterType((*ReqUpdateTIOpenDateList)(nil), "pb.ReqUpdateTIOpenDateList")
	proto.RegisterType((*AccountMoneySummary)(nil), "pb.AccountMoneySummary")
	proto.RegisterType((*AccountMoneySummaryList)(nil), "pb.AccountMoneySummaryList")
	proto.RegisterType((*MoneyTransferRecord)(nil), "pb.MoneyTransferRecord")
	proto.RegisterType((*MTRList)(nil), "pb.MTRList")
	proto.RegisterEnum("pb.ExchangeType", ExchangeType_name, ExchangeType_value)
	proto.RegisterEnum("pb.PeriodType", PeriodType_name, PeriodType_value)
	proto.RegisterEnum("pb.AccountType", AccountType_name, AccountType_value)
	proto.RegisterEnum("pb.CurrencyType", CurrencyType_name, CurrencyType_value)
}
func (m *Symbol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Symbol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *ProductID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *Kline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Time))
	}
	if m.Open != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Open))))
	}
	if m.High != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.High))))
	}
	if m.Low != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Low))))
	}
	if m.Close != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Close))))
	}
	if m.Volume != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Volume))))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Amount))))
	}
	if m.Position != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Position))))
	}
	return i, nil
}

func (m *KlineSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KlineSeries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.Symbol.Size()))
	n1, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Period != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Period))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BrokerRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.MdFrontList) > 0 {
		for _, s := range m.MdFrontList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TradeFrontList) > 0 {
		for _, s := range m.TradeFrontList {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BrokerRouteList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerRouteList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InstrumentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstrumentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SymbolName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SymbolName)))
		i += copy(dAtA[i:], m.SymbolName)
	}
	if m.PositionRank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PositionRank))
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UpdateTime))
	}
	if m.UpdateTradingDay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UpdateTradingDay))
	}
	if m.UpperLimitPrice != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.UpperLimitPrice))))
	}
	if m.LowerLimitPrice != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.LowerLimitPrice))))
	}
	if m.PreClosePrice != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreClosePrice))))
	}
	if m.PreSettlementPrice != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreSettlementPrice))))
	}
	if m.PreVolume != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PrePosition))
	}
	if m.SettlementPrice != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.SettlementPrice))))
	}
	if m.CreateDate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateDate))
	}
	if m.OpenDate != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.OpenDate))
	}
	if m.ExpireDate != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpireDate))
	}
	if m.StartDeliverDate != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartDeliverDate))
	}
	if m.EndDeliverDate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndDeliverDate))
	}
	if m.IsCloseTodayAllowed != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.IsCloseTodayAllowed))
	}
	if m.MaxMarketOrderVolume != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxMarketOrderVolume))
	}
	if m.MinMarketOrderVolume != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MinMarketOrderVolume))
	}
	if m.MaxLimitOrderVolume != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxLimitOrderVolume))
	}
	if m.MinLimitOrderVolume != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MinLimitOrderVolume))
	}
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.BaseSymbol.Size()))
	n2, err := m.BaseSymbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.StrikePrice != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.StrikePrice))))
	}
	return i, nil
}

func (m *SimpleTimePeriod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleTimePeriod) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *MarketTimeRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketTimeRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SendRule) > 0 {
		for _, msg := range m.SendRule {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CancelRule) > 0 {
		for _, msg := range m.CancelRule {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MatchingRule) > 0 {
		for _, msg := range m.MatchingRule {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProductInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.ProductId.Size()))
	n3, err := m.ProductId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x12
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.ProductGroupId.Size()))
	n4, err := m.ProductGroupId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if m.PriceTick != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PriceTick))))
	}
	if m.VolumeMultiple != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.VolumeMultiple))
	}
	if m.PreVolume != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PrePosition))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SettlementGroup))
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.TimeRule.Size()))
	n5, err := m.TimeRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *TradingInstrument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingInstrument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.Symbol.Size()))
	n6, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.InstrumentInfo.Size()))
	n7, err := m.InstrumentInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.ProductInfo.Size()))
	n8, err := m.ProductInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *TradingInstrumentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingInstrumentList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProductInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductInfoList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqSetTradingInstrumentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetTradingInstrumentList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OpCode)))
		i += copy(dAtA[i:], m.OpCode)
	}
	if m.Exchange != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqSetProductInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetProductInfoList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OpCode)))
		i += copy(dAtA[i:], m.OpCode)
	}
	if m.Exchange != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqUpdateTIOpenDate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateTIOpenDate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.Symbol.Size()))
	n9, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.OpenDate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.OpenDate))
	}
	return i, nil
}

func (m *ReqUpdateTIOpenDateList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateTIOpenDateList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OpCode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OpCode)))
		i += copy(dAtA[i:], m.OpCode)
	}
	return i, nil
}

func (m *AccountMoneySummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMoneySummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CurrencyType))
	}
	if m.Balance != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Balance))))
	}
	if m.Commission != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Commission))))
	}
	if m.CurMargin != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.CurMargin))))
	}
	if m.NetPositionAmount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.NetPositionAmount))))
	}
	if m.PreBalance != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreBalance))))
	}
	if m.InterestIn != 0 {
		dAtA[i] = 0x49
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.InterestIn))))
	}
	if m.Deposit != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Deposit))))
	}
	if m.Withdraw != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Withdraw))))
	}
	if m.FrozenMargin != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenMargin))))
	}
	if m.FrozenCommission != 0 {
		dAtA[i] = 0x69
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenCommission))))
	}
	if m.Available != 0 {
		dAtA[i] = 0x71
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Available))))
	}
	if m.CloseProfit != 0 {
		dAtA[i] = 0x79
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.CloseProfit))))
	}
	if m.PositionProfit != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PositionProfit))))
	}
	if m.PreMortgate != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreMortgate))))
	}
	if m.PreCredit != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreCredit))))
	}
	if m.InterestBase != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.InterestBase))))
	}
	if m.WithdrawAvailable != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.WithdrawAvailable))))
	}
	if m.Reserve != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Reserve))))
	}
	if m.TradingDay != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TradingDay))
	}
	if m.Credit != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Credit))))
	}
	if m.Mortgate != 0 {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Mortgate))))
	}
	if m.ExchangeMargin != 0 {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ExchangeMargin))))
	}
	if m.DeliveryMargin != 0 {
		dAtA[i] = 0xd1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.DeliveryMargin))))
	}
	if m.ExchangeDeliveryMargin != 0 {
		dAtA[i] = 0xd9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ExchangeDeliveryMargin))))
	}
	if m.ReserveBalance != 0 {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ReserveBalance))))
	}
	if m.DeliveryCommission != 0 {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.DeliveryCommission))))
	}
	if m.FrozenTransferFee != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenTransferFee))))
	}
	if m.FrozenStampTax != 0 {
		dAtA[i] = 0xf9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenStampTax))))
	}
	if m.TransferFee != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.TransferFee))))
	}
	if m.StampTax != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.StampTax))))
	}
	if m.MtmProfit != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.MtmProfit))))
	}
	if m.PreMtmProfit != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreMtmProfit))))
	}
	if m.StockValue != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.StockValue))))
	}
	if m.BondRepurchaseAmount != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.BondRepurchaseAmount))))
	}
	if m.ReverseRepurchaseAmount != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ReverseRepurchaseAmount))))
	}
	if m.MarginTradeAmount != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.MarginTradeAmount))))
	}
	if m.ShortSellAmount != 0 {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ShortSellAmount))))
	}
	if m.MarginTradeProfit != 0 {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.MarginTradeProfit))))
	}
	if m.ShortSellProfit != 0 {
		dAtA[i] = 0xd1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ShortSellProfit))))
	}
	if m.FrozenCloseCommission != 0 {
		dAtA[i] = 0xd9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenCloseCommission))))
	}
	if m.CommonBalance != 0 {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.CommonBalance))))
	}
	if m.PreferedBalance != 0 {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreferedBalance))))
	}
	if m.BaseExchangeRate != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.BaseExchangeRate))))
	}
	if m.WarningLevel != 0 {
		dAtA[i] = 0xf9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.WarningLevel))))
	}
	if m.ForceCloseLevel != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ForceCloseLevel))))
	}
	if m.ClearedClosedProfit != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ClearedClosedProfit))))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Interest != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Interest))))
	}
	if m.FrozenInterest != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenInterest))))
	}
	return i, nil
}

func (m *AccountMoneySummaryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMoneySummaryList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MoneyTransferRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoneyTransferRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Uid))
	}
	if m.Direction != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Direction))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SettlementGroup))
	}
	if m.Confirmed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Confirmed))
	}
	if m.IsPrefered != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.IsPrefered))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Amount))))
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if len(m.OperatorId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OperatorId)))
		i += copy(dAtA[i:], m.OperatorId)
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SessionId))
	}
	if m.Time != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Time))
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.BankTradeId) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankTradeId)))
		i += copy(dAtA[i:], m.BankTradeId)
	}
	if m.PaymentConfigId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PaymentConfigId))
	}
	if m.OriginalAmount != 0 {
		dAtA[i] = 0x79
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.OriginalAmount))))
	}
	if m.Fee != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Fee))))
	}
	if len(m.PaymentPath) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PaymentPath)))
		i += copy(dAtA[i:], m.PaymentPath)
	}
	if len(m.IdentityNumber) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.IdentityNumber)))
		i += copy(dAtA[i:], m.IdentityNumber)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.BankName) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankName)))
		i += copy(dAtA[i:], m.BankName)
	}
	if len(m.BankBranchName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankBranchName)))
		i += copy(dAtA[i:], m.BankBranchName)
	}
	if len(m.BankCardNo) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankCardNo)))
		i += copy(dAtA[i:], m.BankCardNo)
	}
	if len(m.Province) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Province)))
		i += copy(dAtA[i:], m.Province)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.PayType) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PayType)))
		i += copy(dAtA[i:], m.PayType)
	}
	if m.PayedTime != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PayedTime))
	}
	if m.ConfirmedTime != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ConfirmedTime))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *MTRList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MTRList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Common(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Common(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Symbol) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *ProductID) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *Kline) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovCommon(uint64(m.Time))
	}
	if m.Open != 0 {
		n += 9
	}
	if m.High != 0 {
		n += 9
	}
	if m.Low != 0 {
		n += 9
	}
	if m.Close != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.Position != 0 {
		n += 9
	}
	return n
}

func (m *KlineSeries) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCommon(uint64(l))
	if m.Period != 0 {
		n += 1 + sovCommon(uint64(m.Period))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *BrokerRoute) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.MdFrontList) > 0 {
		for _, s := range m.MdFrontList {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.TradeFrontList) > 0 {
		for _, s := range m.TradeFrontList {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *BrokerRouteList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *InstrumentInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.SymbolName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PositionRank != 0 {
		n += 1 + sovCommon(uint64(m.PositionRank))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovCommon(uint64(m.UpdateTime))
	}
	if m.UpdateTradingDay != 0 {
		n += 1 + sovCommon(uint64(m.UpdateTradingDay))
	}
	if m.UpperLimitPrice != 0 {
		n += 9
	}
	if m.LowerLimitPrice != 0 {
		n += 9
	}
	if m.PreClosePrice != 0 {
		n += 9
	}
	if m.PreSettlementPrice != 0 {
		n += 9
	}
	if m.PreVolume != 0 {
		n += 1 + sovCommon(uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		n += 1 + sovCommon(uint64(m.PrePosition))
	}
	if m.SettlementPrice != 0 {
		n += 9
	}
	if m.CreateDate != 0 {
		n += 1 + sovCommon(uint64(m.CreateDate))
	}
	if m.OpenDate != 0 {
		n += 1 + sovCommon(uint64(m.OpenDate))
	}
	if m.ExpireDate != 0 {
		n += 1 + sovCommon(uint64(m.ExpireDate))
	}
	if m.StartDeliverDate != 0 {
		n += 1 + sovCommon(uint64(m.StartDeliverDate))
	}
	if m.EndDeliverDate != 0 {
		n += 2 + sovCommon(uint64(m.EndDeliverDate))
	}
	if m.IsCloseTodayAllowed != 0 {
		n += 2 + sovCommon(uint64(m.IsCloseTodayAllowed))
	}
	if m.MaxMarketOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MaxMarketOrderVolume))
	}
	if m.MinMarketOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MinMarketOrderVolume))
	}
	if m.MaxLimitOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MaxLimitOrderVolume))
	}
	if m.MinLimitOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MinLimitOrderVolume))
	}
	l = m.BaseSymbol.Size()
	n += 2 + l + sovCommon(uint64(l))
	if m.StrikePrice != 0 {
		n += 10
	}
	return n
}

func (m *SimpleTimePeriod) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovCommon(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCommon(uint64(m.End))
	}
	return n
}

func (m *MarketTimeRule) Size() (n int) {
	var l int
	_ = l
	if len(m.SendRule) > 0 {
		for _, e := range m.SendRule {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.CancelRule) > 0 {
		for _, e := range m.CancelRule {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.MatchingRule) > 0 {
		for _, e := range m.MatchingRule {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ProductInfo) Size() (n int) {
	var l int
	_ = l
	l = m.ProductId.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = m.ProductGroupId.Size()
	n += 1 + l + sovCommon(uint64(l))
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PriceTick != 0 {
		n += 9
	}
	if m.VolumeMultiple != 0 {
		n += 1 + sovCommon(uint64(m.VolumeMultiple))
	}
	if m.PreVolume != 0 {
		n += 1 + sovCommon(uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		n += 1 + sovCommon(uint64(m.PrePosition))
	}
	if m.CurrencyType != 0 {
		n += 1 + sovCommon(uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		n += 1 + sovCommon(uint64(m.SettlementGroup))
	}
	l = m.TimeRule.Size()
	n += 1 + l + sovCommon(uint64(l))
	return n
}

func (m *TradingInstrument) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = m.InstrumentInfo.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = m.ProductInfo.Size()
	n += 1 + l + sovCommon(uint64(l))
	return n
}

func (m *TradingInstrumentList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ProductInfoList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ReqSetTradingInstrumentList) Size() (n int) {
	var l int
	_ = l
	l = len(m.OpCode)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ReqSetProductInfoList) Size() (n int) {
	var l int
	_ = l
	l = len(m.OpCode)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ReqUpdateTIOpenDate) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCommon(uint64(l))
	if m.OpenDate != 0 {
		n += 1 + sovCommon(uint64(m.OpenDate))
	}
	return n
}

func (m *ReqUpdateTIOpenDateList) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.OpCode)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *AccountMoneySummary) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	if m.CurrencyType != 0 {
		n += 1 + sovCommon(uint64(m.CurrencyType))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.Commission != 0 {
		n += 9
	}
	if m.CurMargin != 0 {
		n += 9
	}
	if m.NetPositionAmount != 0 {
		n += 9
	}
	if m.PreBalance != 0 {
		n += 9
	}
	if m.InterestIn != 0 {
		n += 9
	}
	if m.Deposit != 0 {
		n += 9
	}
	if m.Withdraw != 0 {
		n += 9
	}
	if m.FrozenMargin != 0 {
		n += 9
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.Available != 0 {
		n += 9
	}
	if m.CloseProfit != 0 {
		n += 9
	}
	if m.PositionProfit != 0 {
		n += 10
	}
	if m.PreMortgate != 0 {
		n += 10
	}
	if m.PreCredit != 0 {
		n += 10
	}
	if m.InterestBase != 0 {
		n += 10
	}
	if m.WithdrawAvailable != 0 {
		n += 10
	}
	if m.Reserve != 0 {
		n += 10
	}
	if m.TradingDay != 0 {
		n += 2 + sovCommon(uint64(m.TradingDay))
	}
	if m.Credit != 0 {
		n += 10
	}
	if m.Mortgate != 0 {
		n += 10
	}
	if m.ExchangeMargin != 0 {
		n += 10
	}
	if m.DeliveryMargin != 0 {
		n += 10
	}
	if m.ExchangeDeliveryMargin != 0 {
		n += 10
	}
	if m.ReserveBalance != 0 {
		n += 10
	}
	if m.DeliveryCommission != 0 {
		n += 10
	}
	if m.FrozenTransferFee != 0 {
		n += 10
	}
	if m.FrozenStampTax != 0 {
		n += 10
	}
	if m.TransferFee != 0 {
		n += 10
	}
	if m.StampTax != 0 {
		n += 10
	}
	if m.MtmProfit != 0 {
		n += 10
	}
	if m.PreMtmProfit != 0 {
		n += 10
	}
	if m.StockValue != 0 {
		n += 10
	}
	if m.BondRepurchaseAmount != 0 {
		n += 10
	}
	if m.ReverseRepurchaseAmount != 0 {
		n += 10
	}
	if m.MarginTradeAmount != 0 {
		n += 10
	}
	if m.ShortSellAmount != 0 {
		n += 10
	}
	if m.MarginTradeProfit != 0 {
		n += 10
	}
	if m.ShortSellProfit != 0 {
		n += 10
	}
	if m.FrozenCloseCommission != 0 {
		n += 10
	}
	if m.CommonBalance != 0 {
		n += 10
	}
	if m.PreferedBalance != 0 {
		n += 10
	}
	if m.BaseExchangeRate != 0 {
		n += 10
	}
	if m.WarningLevel != 0 {
		n += 10
	}
	if m.ForceCloseLevel != 0 {
		n += 10
	}
	if m.ClearedClosedProfit != 0 {
		n += 10
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.Interest != 0 {
		n += 10
	}
	if m.FrozenInterest != 0 {
		n += 10
	}
	return n
}

func (m *AccountMoneySummaryList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *MoneyTransferRecord) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovCommon(uint64(m.Uid))
	}
	if m.Direction != 0 {
		n += 1 + sovCommon(uint64(m.Direction))
	}
	if m.CurrencyType != 0 {
		n += 1 + sovCommon(uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		n += 1 + sovCommon(uint64(m.SettlementGroup))
	}
	if m.Confirmed != 0 {
		n += 1 + sovCommon(uint64(m.Confirmed))
	}
	if m.IsPrefered != 0 {
		n += 1 + sovCommon(uint64(m.IsPrefered))
	}
	if m.Amount != 0 {
		n += 9
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.OperatorId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovCommon(uint64(m.SessionId))
	}
	if m.Time != 0 {
		n += 1 + sovCommon(uint64(m.Time))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.BankTradeId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PaymentConfigId != 0 {
		n += 1 + sovCommon(uint64(m.PaymentConfigId))
	}
	if m.OriginalAmount != 0 {
		n += 9
	}
	if m.Fee != 0 {
		n += 10
	}
	l = len(m.PaymentPath)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.IdentityNumber)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.BankName)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.BankBranchName)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.BankCardNo)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.Province)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.PayType)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.PayedTime != 0 {
		n += 2 + sovCommon(uint64(m.PayedTime))
	}
	if m.ConfirmedTime != 0 {
		n += 2 + sovCommon(uint64(m.ConfirmedTime))
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *MTRList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func sovCommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Symbol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Symbol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Symbol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Open = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.High = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Low = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Close = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Volume = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Amount = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Position = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KlineSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KlineSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KlineSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= (PeriodType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, Kline{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokerRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokerRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MdFrontList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MdFrontList = append(m.MdFrontList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeFrontList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeFrontList = append(m.TradeFrontList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerRouteList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokerRouteList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokerRouteList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, BrokerRoute{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstrumentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstrumentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstrumentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRank", wireType)
			}
			m.PositionRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTradingDay", wireType)
			}
			m.UpdateTradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperLimitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.UpperLimitPrice = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerLimitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LowerLimitPrice = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreClosePrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreClosePrice = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSettlementPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreSettlementPrice = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVolume", wireType)
			}
			m.PreVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePosition", wireType)
			}
			m.PrePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrePosition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.SettlementPrice = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDate", wireType)
			}
			m.CreateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenDate", wireType)
			}
			m.OpenDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireDate", wireType)
			}
			m.ExpireDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDeliverDate", wireType)
			}
			m.StartDeliverDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartDeliverDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDeliverDate", wireType)
			}
			m.EndDeliverDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndDeliverDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCloseTodayAllowed", wireType)
			}
			m.IsCloseTodayAllowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCloseTodayAllowed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMarketOrderVolume", wireType)
			}
			m.MaxMarketOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMarketOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMarketOrderVolume", wireType)
			}
			m.MinMarketOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinMarketOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLimitOrderVolume", wireType)
			}
			m.MaxLimitOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLimitOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLimitOrderVolume", wireType)
			}
			m.MinLimitOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLimitOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseSymbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseSymbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrikePrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.StrikePrice = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleTimePeriod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleTimePeriod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleTimePeriod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketTimeRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketTimeRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketTimeRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SendRule = append(m.SendRule, SimpleTimePeriod{})
			if err := m.SendRule[len(m.SendRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelRule = append(m.CancelRule, SimpleTimePeriod{})
			if err := m.CancelRule[len(m.CancelRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchingRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchingRule = append(m.MatchingRule, SimpleTimePeriod{})
			if err := m.MatchingRule[len(m.MatchingRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductGroupId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductGroupId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTick", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PriceTick = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMultiple", wireType)
			}
			m.VolumeMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeMultiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVolume", wireType)
			}
			m.PreVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePosition", wireType)
			}
			m.PrePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrePosition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementGroup", wireType)
			}
			m.SettlementGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingInstrument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingInstrument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingInstrument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstrumentInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingInstrumentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingInstrumentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingInstrumentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, TradingInstrument{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, ProductInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetTradingInstrumentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetTradingInstrumentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetTradingInstrumentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, TradingInstrument{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetProductInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetProductInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetProductInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, ProductInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateTIOpenDate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenDate", wireType)
			}
			m.OpenDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateTIOpenDateList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDateList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDateList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, ReqUpdateTIOpenDate{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMoneySummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMoneySummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMoneySummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AccountType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (CurrencyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Balance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Commission = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CurMargin = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetPositionAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.NetPositionAmount = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreBalance = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.InterestIn = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Deposit = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdraw", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Withdraw = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Available = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CloseProfit = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PositionProfit = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMortgate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreMortgate = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreCredit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreCredit = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestBase", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.InterestBase = float64(math.Float64frombits(v))
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawAvailable", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WithdrawAvailable = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Reserve = float64(math.Float64frombits(v))
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			m.TradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Credit = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mortgate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Mortgate = float64(math.Float64frombits(v))
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ExchangeMargin = float64(math.Float64frombits(v))
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.DeliveryMargin = float64(math.Float64frombits(v))
		case 27:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeDeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ExchangeDeliveryMargin = float64(math.Float64frombits(v))
		case 28:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ReserveBalance = float64(math.Float64frombits(v))
		case 29:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.DeliveryCommission = float64(math.Float64frombits(v))
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenTransferFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenTransferFee = float64(math.Float64frombits(v))
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenStampTax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenStampTax = float64(math.Float64frombits(v))
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.TransferFee = float64(math.Float64frombits(v))
		case 33:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StampTax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.StampTax = float64(math.Float64frombits(v))
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtmProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MtmProfit = float64(math.Float64frombits(v))
		case 35:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMtmProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreMtmProfit = float64(math.Float64frombits(v))
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.StockValue = float64(math.Float64frombits(v))
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondRepurchaseAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.BondRepurchaseAmount = float64(math.Float64frombits(v))
		case 38:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseRepurchaseAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ReverseRepurchaseAmount = float64(math.Float64frombits(v))
		case 39:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginTradeAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MarginTradeAmount = float64(math.Float64frombits(v))
		case 40:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortSellAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortSellAmount = float64(math.Float64frombits(v))
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginTradeProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MarginTradeProfit = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortSellProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortSellProfit = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCloseCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenCloseCommission = float64(math.Float64frombits(v))
		case 44:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CommonBalance = float64(math.Float64frombits(v))
		case 45:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferedBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreferedBalance = float64(math.Float64frombits(v))
		case 46:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseExchangeRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.BaseExchangeRate = float64(math.Float64frombits(v))
		case 47:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningLevel", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WarningLevel = float64(math.Float64frombits(v))
		case 48:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseLevel", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ForceCloseLevel = float64(math.Float64frombits(v))
		case 49:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearedClosedProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ClearedClosedProfit = float64(math.Float64frombits(v))
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Interest = float64(math.Float64frombits(v))
		case 52:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenInterest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenInterest = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMoneySummaryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMoneySummaryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMoneySummaryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, AccountMoneySummary{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoneyTransferRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoneyTransferRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoneyTransferRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementGroup", wireType)
			}
			m.SettlementGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmed", wireType)
			}
			m.Confirmed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirmed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrefered", wireType)
			}
			m.IsPrefered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPrefered |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Amount = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankTradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankTradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentConfigId", wireType)
			}
			m.PaymentConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentConfigId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.OriginalAmount = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Fee = float64(math.Float64frombits(v))
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankBranchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankBranchName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankCardNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankCardNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Province = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayedTime", wireType)
			}
			m.PayedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayedTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmedTime", wireType)
			}
			m.ConfirmedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmedTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MTRList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MTRList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MTRList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, MoneyTransferRecord{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("common.proto", fileDescriptorCommon) }

var fileDescriptorCommon = []byte{
	// 2691 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0x4b, 0x73, 0x1b, 0xc7,
	0x11, 0x16, 0x08, 0x3e, 0xb0, 0x0d, 0x10, 0x58, 0x2e, 0x5f, 0xd0, 0x9b, 0x06, 0x6d, 0x8b, 0xa2,
	0x64, 0xda, 0xa4, 0x2c, 0x25, 0x71, 0x4e, 0x12, 0x48, 0x5a, 0x88, 0xcc, 0x47, 0x2d, 0x28, 0xc7,
	0xf1, 0x65, 0x6b, 0xb9, 0x3b, 0x24, 0x37, 0xdc, 0x97, 0x67, 0x17, 0x14, 0x91, 0x54, 0x0e, 0xf9,
	0x07, 0xa9, 0xca, 0x9f, 0xc8, 0x1f, 0x48, 0xf2, 0x17, 0x72, 0xcc, 0x31, 0xc7, 0x94, 0x73, 0xca,
	0xbf, 0x48, 0x75, 0xf7, 0xcc, 0x62, 0x41, 0x52, 0x8e, 0x2b, 0x95, 0x13, 0x66, 0xbe, 0xfe, 0x7a,
	0x1e, 0x3d, 0x3d, 0xdd, 0x3d, 0x0b, 0x68, 0x78, 0x49, 0x14, 0x25, 0xf1, 0x46, 0x2a, 0x93, 0x3c,
	0xb1, 0x26, 0xd2, 0xe3, 0xce, 0x2f, 0x60, 0xba, 0x3f, 0x8c, 0x8e, 0x93, 0xd0, 0x7a, 0x0a, 0x35,
	0x71, 0xe9, 0x9d, 0xb9, 0xf1, 0xa9, 0x68, 0x57, 0x56, 0x2a, 0x6b, 0xcd, 0x2d, 0x73, 0x23, 0x3d,
	0xde, 0xd8, 0x51, 0xd8, 0xd1, 0x30, 0x15, 0x76, 0xc1, 0xb0, 0x2c, 0x98, 0xf4, 0x12, 0x5f, 0xb4,
	0x27, 0x56, 0x2a, 0x6b, 0x86, 0x4d, 0xed, 0xce, 0x1e, 0x18, 0x87, 0x32, 0xf1, 0x07, 0x5e, 0xde,
	0xdb, 0xfe, 0x3f, 0x0c, 0xf7, 0xd7, 0x0a, 0x4c, 0xbd, 0x09, 0x83, 0x98, 0xa4, 0x79, 0x10, 0xf1,
	0x38, 0x55, 0x9b, 0xda, 0x88, 0x25, 0xa9, 0x88, 0x49, 0xa3, 0x62, 0x53, 0x1b, 0xb1, 0xb3, 0xe0,
	0xf4, 0xac, 0x5d, 0x65, 0x0c, 0xdb, 0x96, 0x09, 0xd5, 0x30, 0x79, 0xd7, 0x9e, 0x24, 0x08, 0x9b,
	0xd6, 0x02, 0x4c, 0x79, 0x61, 0x92, 0x89, 0xf6, 0x14, 0x61, 0xdc, 0xb1, 0x96, 0x60, 0xfa, 0x22,
	0x09, 0x07, 0x91, 0x68, 0x4f, 0x13, 0xac, 0x7a, 0x88, 0xbb, 0x51, 0x32, 0x88, 0xf3, 0xf6, 0x0c,
	0xe3, 0xdc, 0xb3, 0xee, 0x40, 0x2d, 0x4d, 0xb2, 0x20, 0x0f, 0x92, 0xb8, 0x5d, 0x23, 0x49, 0xd1,
	0xef, 0x5c, 0x42, 0x9d, 0x16, 0xde, 0x17, 0x32, 0x10, 0x99, 0xd5, 0x81, 0xe9, 0x8c, 0x6c, 0x4c,
	0x1b, 0xa8, 0x6f, 0x01, 0x1a, 0x82, 0xad, 0x6e, 0x2b, 0x89, 0xf5, 0x31, 0x4c, 0xa7, 0x42, 0x06,
	0x89, 0x4f, 0x1b, 0x6a, 0x6e, 0x35, 0x91, 0x73, 0x48, 0x08, 0x99, 0x4a, 0x49, 0xad, 0xfb, 0x30,
	0x19, 0x06, 0x59, 0xde, 0xae, 0xae, 0x54, 0xd7, 0xea, 0x5b, 0x06, 0xb2, 0x68, 0x2a, 0x9b, 0xe0,
	0xce, 0x1f, 0x2b, 0x50, 0x7f, 0x25, 0x93, 0x73, 0x21, 0xed, 0x64, 0x90, 0x0b, 0xab, 0x09, 0x13,
	0x81, 0x4f, 0xd3, 0x1a, 0xf6, 0x44, 0xe0, 0x93, 0x25, 0x87, 0x29, 0xdb, 0x79, 0xca, 0xa6, 0x36,
	0x62, 0xb1, 0x1b, 0x09, 0xb2, 0x9a, 0x61, 0x53, 0xdb, 0xea, 0xc0, 0x6c, 0xe4, 0x3b, 0x27, 0x32,
	0x89, 0x73, 0x87, 0xe6, 0x9b, 0x5c, 0xa9, 0xae, 0x19, 0x76, 0x3d, 0xf2, 0x77, 0x11, 0xfb, 0x2a,
	0xc8, 0x72, 0x6b, 0x0d, 0xcc, 0x5c, 0xba, 0xbe, 0x28, 0xd3, 0xa6, 0x88, 0xd6, 0x24, 0xbc, 0x60,
	0x76, 0x5e, 0x40, 0xab, 0xb4, 0x28, 0x52, 0x5e, 0x55, 0xfb, 0xa8, 0xd0, 0x3e, 0x5a, 0xb8, 0x8f,
	0x12, 0x45, 0xed, 0xe6, 0x1f, 0x33, 0xd0, 0xec, 0xc5, 0x59, 0x2e, 0x07, 0x91, 0x88, 0xf3, 0x5e,
	0x7c, 0x92, 0x58, 0x0f, 0xa1, 0xce, 0x16, 0x73, 0x68, 0xcd, 0xbc, 0x33, 0x60, 0x68, 0x1f, 0x57,
	0xbe, 0x0a, 0xb3, 0xfa, 0x1c, 0x1c, 0xe9, 0xc6, 0xe7, 0x6a, 0xab, 0x0d, 0x0d, 0xda, 0x6e, 0x7c,
	0x8e, 0xa3, 0x0c, 0x52, 0xdf, 0xcd, 0x85, 0x43, 0x7e, 0x55, 0x25, 0xbf, 0x02, 0x86, 0x8e, 0xd0,
	0xbb, 0x9e, 0x82, 0xa5, 0x09, 0xd2, 0xf5, 0x83, 0xf8, 0xd4, 0xf1, 0xdd, 0x21, 0x39, 0xd1, 0x94,
	0x6d, 0x2a, 0x1e, 0x0b, 0xb6, 0xdd, 0xa1, 0xb5, 0x0e, 0x73, 0x83, 0x34, 0x15, 0xd2, 0x09, 0x83,
	0x28, 0xc8, 0x9d, 0x54, 0x06, 0x9e, 0xf6, 0xae, 0x16, 0x09, 0xbe, 0x42, 0xfc, 0x10, 0x61, 0xe4,
	0x86, 0xc9, 0xbb, 0x2b, 0x5c, 0x76, 0xb9, 0x16, 0x09, 0x4a, 0xdc, 0x8f, 0xa1, 0x95, 0x4a, 0xe1,
	0x90, 0x83, 0x2a, 0x26, 0x3b, 0xe1, 0x6c, 0x2a, 0x45, 0x17, 0x51, 0xe6, 0x7d, 0x06, 0x0b, 0xc8,
	0xcb, 0x44, 0x9e, 0x87, 0x02, 0x4d, 0xa5, 0xc8, 0xec, 0x97, 0x56, 0x2a, 0x45, 0xbf, 0x10, 0xb1,
	0xc6, 0x7d, 0x00, 0xd4, 0x50, 0x1e, 0x6f, 0xd0, 0xbe, 0x8c, 0x54, 0x8a, 0xaf, 0xd9, 0xe9, 0x3f,
	0x80, 0x06, 0x8a, 0x0b, 0x07, 0x07, 0x22, 0xd4, 0x53, 0x29, 0x0e, 0x15, 0x64, 0x3d, 0x06, 0xf3,
	0xda, 0x7c, 0x75, 0xde, 0x46, 0x76, 0x65, 0xb2, 0x87, 0x50, 0xf7, 0xa4, 0x40, 0x63, 0xa2, 0xdd,
	0xda, 0x0d, 0x1a, 0x0c, 0x18, 0xda, 0x76, 0x73, 0x61, 0xdd, 0x05, 0x03, 0xef, 0x2f, 0x8b, 0x67,
	0x49, 0x5c, 0x43, 0x80, 0x84, 0x0f, 0xa1, 0x2e, 0x2e, 0xd3, 0x40, 0x2a, 0xed, 0x26, 0x6b, 0x33,
	0x44, 0x84, 0xa7, 0x60, 0x65, 0xb9, 0x2b, 0x73, 0xc7, 0x17, 0x61, 0x70, 0x21, 0x24, 0xf3, 0x5a,
	0x7c, 0x56, 0x24, 0xd9, 0x66, 0x01, 0xb1, 0xd7, 0xc0, 0x14, 0xb1, 0x3f, 0xce, 0x35, 0x89, 0xdb,
	0x14, 0xb1, 0x5f, 0x66, 0x3e, 0x83, 0xa5, 0x20, 0x53, 0xc6, 0xcf, 0x13, 0xdf, 0x1d, 0x3a, 0x6e,
	0x88, 0x27, 0xe4, 0xb7, 0xe7, 0x88, 0x3f, 0x1f, 0x64, 0x74, 0x06, 0x47, 0x28, 0x7b, 0xc9, 0x22,
	0xeb, 0x39, 0x2c, 0x47, 0xee, 0xa5, 0x13, 0xb9, 0xf2, 0x5c, 0xe4, 0x4e, 0x22, 0x7d, 0x21, 0xb5,
	0x95, 0x2d, 0xd2, 0x5a, 0x88, 0xdc, 0xcb, 0x3d, 0x92, 0x1e, 0xa0, 0x50, 0x19, 0x1c, 0xd5, 0x82,
	0xf8, 0x46, 0xb5, 0x79, 0xa5, 0x16, 0xc4, 0xd7, 0xd5, 0x9e, 0xc1, 0x12, 0xce, 0xc6, 0xae, 0x34,
	0xa6, 0xb5, 0xc0, 0x4b, 0x8c, 0xdc, 0x4b, 0xf2, 0xa7, 0xab, 0x4a, 0x41, 0x7c, 0x93, 0xd2, 0xa2,
	0x52, 0x0a, 0xe2, 0x6b, 0x4a, 0x4f, 0xa0, 0x7e, 0xec, 0x66, 0xc2, 0x51, 0x81, 0x6c, 0xe9, 0x5a,
	0x20, 0x03, 0x14, 0xab, 0x54, 0xf2, 0x01, 0x34, 0xb2, 0x5c, 0x06, 0xe7, 0xda, 0x69, 0x97, 0xc9,
	0x2f, 0xea, 0x8c, 0x91, 0x4f, 0x74, 0xbe, 0x00, 0xb3, 0x1f, 0x44, 0x69, 0x48, 0xd7, 0x8d, 0xe3,
	0x1c, 0x06, 0x66, 0x3a, 0x2e, 0xba, 0xd5, 0x53, 0x36, 0x77, 0x30, 0x80, 0x8b, 0xd8, 0x57, 0xd7,
	0x18, 0x9b, 0x9d, 0x3f, 0x57, 0xa0, 0xc9, 0xb6, 0x40, 0x65, 0x7b, 0x10, 0x0a, 0x6b, 0x13, 0x8c,
	0x0c, 0x8f, 0x55, 0x0e, 0x42, 0xa1, 0x62, 0xca, 0x02, 0x2d, 0xee, 0xca, 0x1c, 0x76, 0x0d, 0x69,
	0xa4, 0xf2, 0x1c, 0xea, 0x9e, 0x1b, 0x7b, 0x22, 0x64, 0xa5, 0x89, 0x1f, 0x50, 0x02, 0x26, 0x92,
	0xda, 0xcf, 0x60, 0x36, 0x72, 0x73, 0xef, 0x0c, 0x63, 0x02, 0x29, 0x56, 0x7f, 0x40, 0xb1, 0xa1,
	0xa9, 0xa8, 0xda, 0xf9, 0x4b, 0x15, 0xea, 0x3a, 0x41, 0x62, 0x2c, 0x7b, 0x8a, 0x97, 0x90, 0xba,
	0x8e, 0x0a, 0xd2, 0xf5, 0xad, 0x59, 0x8a, 0xfb, 0x3a, 0x8b, 0xe2, 0x9d, 0xe4, 0xa6, 0x6f, 0xfd,
	0x04, 0x4c, 0xcd, 0x3e, 0x95, 0xc9, 0x20, 0x45, 0x9d, 0x89, 0x9b, 0x74, 0x9a, 0x8a, 0xf6, 0x25,
	0xb2, 0x7a, 0xa3, 0x98, 0x5f, 0x2d, 0xc5, 0x7c, 0xba, 0xe0, 0x3c, 0x18, 0xc5, 0xd1, 0x49, 0x8a,
	0xa3, 0x75, 0x85, 0x51, 0x20, 0xa5, 0x10, 0x11, 0x78, 0x18, 0x22, 0xbd, 0x73, 0x15, 0xcd, 0x0c,
	0x42, 0x8e, 0x02, 0xef, 0xdc, 0x7a, 0x04, 0x2d, 0xf6, 0x1a, 0x27, 0x1a, 0x84, 0x79, 0x90, 0x86,
	0x1c, 0xc5, 0xa6, 0xec, 0x26, 0xc3, 0x7b, 0x0a, 0xbd, 0x12, 0x6a, 0x66, 0xfe, 0x5b, 0xa8, 0xa9,
	0x5d, 0x0f, 0x35, 0xab, 0x30, 0xeb, 0x0d, 0xa4, 0x14, 0xb1, 0x37, 0x74, 0x68, 0x27, 0x1c, 0xaf,
	0x1a, 0x1a, 0xc4, 0x04, 0x79, 0x25, 0x1e, 0x91, 0x85, 0x54, 0xd8, 0x2a, 0xc5, 0x23, 0x32, 0x89,
	0xf5, 0x29, 0x18, 0x18, 0xf6, 0xf9, 0xf8, 0xea, 0x64, 0x42, 0x0b, 0x4d, 0x38, 0xee, 0x53, 0x76,
	0x2d, 0x57, 0xad, 0xce, 0x9f, 0x2a, 0x30, 0xa7, 0xc2, 0xfd, 0x28, 0x1d, 0xfd, 0xa8, 0xb4, 0xfe,
	0x73, 0x68, 0x05, 0x85, 0x86, 0x13, 0xc4, 0x27, 0x89, 0x3a, 0x33, 0x9a, 0x70, 0x3c, 0xb7, 0xd9,
	0xcd, 0x60, 0x3c, 0xd7, 0x6d, 0x8d, 0x0e, 0x89, 0x34, 0xab, 0xa4, 0xd9, 0x2a, 0x9f, 0x36, 0xaa,
	0xe9, 0x53, 0xc3, 0x4e, 0xe7, 0x15, 0x2c, 0x5e, 0x5b, 0x29, 0x25, 0xdc, 0xc7, 0x63, 0x09, 0x77,
	0x11, 0x07, 0xb9, 0x46, 0x54, 0x69, 0xf7, 0x05, 0xb4, 0x4a, 0xe3, 0xbf, 0x2f, 0x5d, 0x97, 0x97,
	0xc0, 0x7a, 0xbf, 0x83, 0xbb, 0xb6, 0xf8, 0xae, 0x2f, 0xf2, 0x9b, 0x57, 0xb0, 0x0c, 0x33, 0x49,
	0xea, 0x50, 0x99, 0xc7, 0x69, 0x7b, 0x3a, 0x49, 0xbb, 0x89, 0x2f, 0xb0, 0x94, 0x2a, 0x4a, 0x45,
	0xbe, 0xe6, 0xa3, 0xc2, 0xf0, 0xf1, 0x58, 0xbd, 0xf3, 0x83, 0xcb, 0xfe, 0x0e, 0x16, 0x79, 0xfa,
	0xab, 0x8b, 0xff, 0x9f, 0x26, 0x5e, 0x1d, 0x9b, 0xf8, 0x3d, 0x3b, 0xfe, 0x1a, 0xe6, 0x6d, 0xf1,
	0xdd, 0x5b, 0xae, 0x07, 0x7a, 0x07, 0x3a, 0x65, 0xfd, 0x18, 0xcf, 0x18, 0xcb, 0x79, 0x13, 0xe3,
	0x39, 0xaf, 0xf3, 0x5b, 0x58, 0xbe, 0x61, 0x5c, 0xda, 0xcc, 0x9d, 0x2b, 0x75, 0x75, 0x79, 0xcd,
	0x4f, 0xd4, 0x9a, 0x39, 0x96, 0x2d, 0xe3, 0xac, 0x37, 0x0c, 0xc3, 0x6b, 0x2f, 0x5b, 0xa5, 0x5a,
	0xb6, 0x4a, 0xe7, 0xdf, 0x2d, 0x98, 0x7f, 0xe9, 0x79, 0x58, 0xe5, 0xee, 0x25, 0xb1, 0x18, 0xf6,
	0x07, 0x51, 0xe4, 0xca, 0xe1, 0xb5, 0x5a, 0x72, 0xb5, 0x54, 0x4b, 0x36, 0xd9, 0x42, 0x4a, 0x8d,
	0x2a, 0x56, 0x0e, 0x34, 0xcf, 0xaf, 0xde, 0xdd, 0xea, 0xe8, 0x2d, 0xd0, 0x2d, 0xdd, 0xdf, 0x2b,
	0xb7, 0xb9, 0x0d, 0x33, 0xc7, 0x6e, 0x88, 0x51, 0x57, 0x55, 0xee, 0xba, 0x6b, 0x3d, 0x00, 0xc0,
	0x47, 0x4c, 0x90, 0x65, 0x18, 0x2d, 0x38, 0x2c, 0x95, 0x10, 0x0c, 0x37, 0xde, 0x40, 0x62, 0x26,
	0x3d, 0x0d, 0x62, 0x55, 0x58, 0x19, 0xde, 0x40, 0xee, 0x11, 0x60, 0x6d, 0xc0, 0x7c, 0x2c, 0xf2,
	0x22, 0xdc, 0x38, 0x63, 0xb5, 0xfd, 0x5c, 0x2c, 0x72, 0x1d, 0x75, 0x5e, 0x72, 0x99, 0xff, 0x10,
	0x30, 0x14, 0x39, 0x7a, 0x31, 0x5c, 0x51, 0x61, 0x40, 0x7b, 0xa5, 0xd6, 0xf3, 0x10, 0xea, 0x41,
	0x9c, 0x0b, 0x29, 0x32, 0xbc, 0xa5, 0x14, 0x9a, 0x2a, 0x36, 0x68, 0xa8, 0x17, 0xe3, 0x56, 0x7c,
	0x41, 0xf3, 0x51, 0x3c, 0xaa, 0xd8, 0xba, 0x8b, 0x47, 0xf9, 0x2e, 0xc8, 0xcf, 0x7c, 0xe9, 0xbe,
	0x53, 0xa5, 0x53, 0xd1, 0xc7, 0x98, 0x77, 0x22, 0x93, 0xdf, 0x88, 0x58, 0xef, 0xa4, 0x41, 0x84,
	0x06, 0x83, 0x6a, 0x33, 0x4f, 0x60, 0x4e, 0x91, 0x4a, 0x26, 0x99, 0x25, 0xa2, 0xc9, 0x82, 0xee,
	0xc8, 0x30, 0xf7, 0xc0, 0x70, 0x2f, 0xdc, 0x20, 0x74, 0x8f, 0x43, 0xae, 0xa2, 0x2a, 0xf6, 0x08,
	0xc0, 0x30, 0xac, 0xcb, 0xcc, 0xe4, 0x24, 0xc8, 0xa9, 0x7c, 0xaa, 0xd8, 0x75, 0x8f, 0x8b, 0x4c,
	0x84, 0x30, 0xe2, 0x17, 0x66, 0x53, 0x2c, 0x93, 0x58, 0x4d, 0x0d, 0x2b, 0xa2, 0x0a, 0xe9, 0x51,
	0x22, 0xf3, 0x53, 0xf4, 0xee, 0x39, 0x1e, 0x2b, 0x95, 0x62, 0x4f, 0x41, 0x3a, 0x29, 0x78, 0x52,
	0xf8, 0x41, 0x4e, 0x95, 0x11, 0x25, 0x17, 0xd1, 0x25, 0x00, 0x77, 0x5f, 0x18, 0x15, 0xeb, 0x0a,
	0x2a, 0x82, 0x2a, 0x76, 0x43, 0x83, 0xaf, 0xdc, 0x4c, 0x58, 0x9f, 0x80, 0xa5, 0xcd, 0xe5, 0x8c,
	0x76, 0xb6, 0xc0, 0x27, 0xa9, 0x25, 0x2f, 0x8b, 0x1d, 0xb6, 0x61, 0x46, 0x8a, 0x4c, 0xc8, 0x0b,
	0xae, 0x73, 0x2a, 0xb6, 0xee, 0xe2, 0x11, 0x96, 0xab, 0xfc, 0x25, 0xae, 0x30, 0xf3, 0x51, 0x7d,
	0xbf, 0x04, 0xd3, 0x6a, 0xa5, 0x5c, 0xc9, 0xa8, 0x1e, 0x1e, 0x60, 0xb1, 0xc9, 0x36, 0x1f, 0xa0,
	0xee, 0xa3, 0xb5, 0xf4, 0xbd, 0xd4, 0x47, 0x78, 0x9b, 0xad, 0xa5, 0x61, 0x75, 0x88, 0x8f, 0xa0,
	0xa5, 0x8a, 0xd1, 0xa1, 0x26, 0xde, 0x61, 0xa2, 0x86, 0x15, 0xf1, 0xa7, 0xd0, 0x2e, 0x46, 0xbc,
	0xaa, 0x71, 0x97, 0x34, 0x96, 0xb4, 0x7c, 0x7b, 0x5c, 0xf3, 0x11, 0xb4, 0xd4, 0x5e, 0x0b, 0x47,
	0xbe, 0xc7, 0x53, 0x28, 0x58, 0x3b, 0xf3, 0xa7, 0x30, 0x5f, 0x8c, 0x5c, 0x72, 0xa9, 0xfb, 0xfc,
	0x8e, 0xd0, 0xa2, 0x92, 0x53, 0x6d, 0xc0, 0xbc, 0xf2, 0xc0, 0x5c, 0xba, 0x71, 0x76, 0x22, 0xa4,
	0x73, 0x22, 0x44, 0xfb, 0x01, 0x1f, 0x02, 0x8b, 0x8e, 0x94, 0x64, 0x57, 0x50, 0xf5, 0xad, 0xf8,
	0x59, 0xee, 0x46, 0xa9, 0x93, 0xbb, 0x97, 0xed, 0x87, 0xbc, 0x14, 0xc6, 0xfb, 0x08, 0x1f, 0xb9,
	0x97, 0xe8, 0x44, 0x63, 0x43, 0xae, 0xb0, 0x13, 0xe5, 0xa5, 0xc1, 0xee, 0x82, 0x31, 0x1a, 0xe5,
	0x03, 0xb6, 0x7f, 0xa6, 0xf5, 0xef, 0x03, 0x44, 0x79, 0xa4, 0x1d, 0xb5, 0xc3, 0x1e, 0x16, 0xe5,
	0x91, 0xf2, 0xd1, 0x0f, 0xa1, 0x49, 0x3e, 0x3a, 0xa2, 0xac, 0xb2, 0x8b, 0xa1, 0x97, 0x16, 0x2c,
	0x7c, 0x6d, 0xe6, 0x89, 0x77, 0xee, 0x5c, 0xb8, 0xe1, 0x40, 0xb4, 0x3f, 0xe4, 0xcb, 0x4d, 0xd0,
	0xd7, 0x88, 0x58, 0x9f, 0xc3, 0xd2, 0x71, 0x82, 0x75, 0xa7, 0x48, 0x07, 0xd2, 0x3b, 0xc3, 0x0a,
	0x59, 0x45, 0x94, 0x8f, 0x88, 0xbb, 0x80, 0x52, 0xbb, 0x10, 0xaa, 0xa0, 0xf2, 0x05, 0xdc, 0x96,
	0xe2, 0x42, 0xc8, 0x4c, 0xdc, 0xa0, 0xf8, 0x31, 0x29, 0x2e, 0x2b, 0xc2, 0x35, 0xdd, 0x0d, 0x98,
	0xe7, 0x33, 0x77, 0xf8, 0xf1, 0xad, 0xb4, 0x1e, 0xb1, 0xc5, 0x59, 0x84, 0x19, 0x52, 0xf3, 0xd7,
	0x61, 0x2e, 0x3b, 0x4b, 0x64, 0xee, 0x64, 0x22, 0x0c, 0x35, 0x7b, 0x4d, 0x3d, 0xd4, 0x50, 0xd0,
	0x17, 0x61, 0xf8, 0x9e, 0xb1, 0x95, 0x65, 0x1e, 0x5f, 0x1b, 0x5b, 0x99, 0x67, 0x7c, 0x6c, 0xc5,
	0x5e, 0xbf, 0x32, 0xb6, 0xe2, 0xbe, 0x80, 0x65, 0x1d, 0xab, 0x28, 0xce, 0x94, 0xdc, 0xeb, 0x09,
	0x69, 0x2c, 0xaa, 0x88, 0x85, 0xd2, 0x92, 0x87, 0x7d, 0x04, 0x4d, 0xfe, 0x68, 0x55, 0xb8, 0xee,
	0x53, 0x7e, 0x02, 0x33, 0xaa, 0x3d, 0xf7, 0x31, 0x56, 0xc7, 0xe2, 0x44, 0x48, 0xe1, 0x17, 0xc4,
	0x4f, 0x78, 0x25, 0x1a, 0xd7, 0xd4, 0xa7, 0x60, 0xd1, 0x53, 0xa6, 0xb8, 0x4c, 0x12, 0xef, 0xef,
	0x06, 0x87, 0x4d, 0x94, 0xe8, 0x6f, 0x54, 0x36, 0xde, 0xe3, 0x55, 0x98, 0x7d, 0xe7, 0xca, 0x18,
	0x83, 0x43, 0x28, 0x2e, 0x44, 0xd8, 0xfe, 0x94, 0xfd, 0x44, 0x81, 0x5f, 0x21, 0x86, 0x86, 0x38,
	0x49, 0xa4, 0xa7, 0x9f, 0xea, 0x4c, 0xfc, 0x8c, 0xa7, 0x27, 0x01, 0xed, 0x8a, 0xb9, 0x5b, 0xb0,
	0xe8, 0x85, 0xc2, 0xc5, 0x85, 0x12, 0xdb, 0xd7, 0x86, 0xdb, 0x24, 0xfe, 0xbc, 0x12, 0x92, 0x86,
	0xaf, 0x8c, 0xa7, 0x3f, 0xd1, 0x6c, 0x95, 0x3e, 0xd1, 0xdc, 0x81, 0x9a, 0x0e, 0x87, 0xed, 0x67,
	0xec, 0xfc, 0xba, 0x8f, 0x17, 0x5e, 0x19, 0xbb, 0xa0, 0x7c, 0x5e, 0xbe, 0x65, 0x3d, 0x85, 0x76,
	0x76, 0x61, 0xf9, 0x86, 0x54, 0x4f, 0x85, 0xc6, 0x93, 0xb1, 0x92, 0x6f, 0xb9, 0x94, 0xde, 0xcb,
	0x54, 0x55, 0x08, 0xfd, 0x7e, 0x06, 0xe6, 0x09, 0xd6, 0x97, 0xdd, 0x16, 0x5e, 0x22, 0x7d, 0x7c,
	0xbc, 0x0d, 0x54, 0xd1, 0x50, 0xb5, 0xb1, 0x89, 0x69, 0xc8, 0x0f, 0xa4, 0xf0, 0xa8, 0xd8, 0xe7,
	0xba, 0x67, 0x04, 0x5c, 0x2f, 0xf5, 0xab, 0x3f, 0xb2, 0xd4, 0x9f, 0xbc, 0xb9, 0xd4, 0xbf, 0x07,
	0x86, 0x97, 0xc4, 0x27, 0x81, 0x8c, 0x84, 0x4f, 0xc5, 0xc2, 0x94, 0x3d, 0x02, 0x28, 0x77, 0x67,
	0x8e, 0xf6, 0x0f, 0xf5, 0x7e, 0x81, 0x20, 0x3b, 0x54, 0xc8, 0x7b, 0x3f, 0xfe, 0xdd, 0x07, 0x70,
	0xd9, 0x16, 0xf8, 0x0a, 0xab, 0xd1, 0xa9, 0x18, 0x0a, 0xe9, 0xd1, 0xb8, 0x49, 0x2a, 0xa4, 0x9b,
	0x27, 0x12, 0xe5, 0x06, 0x7f, 0xa4, 0xd2, 0x50, 0xcf, 0x47, 0xfd, 0x4c, 0x90, 0x7f, 0xa3, 0x9c,
	0x9f, 0x29, 0x86, 0x42, 0xd4, 0x8b, 0x2d, 0x88, 0xf8, 0x6d, 0xa2, 0xbf, 0x77, 0xb6, 0x61, 0x06,
	0x3d, 0x5e, 0xc4, 0x39, 0x95, 0x02, 0x86, 0xad, 0xbb, 0x56, 0x07, 0x66, 0x8f, 0xdd, 0xf8, 0x5c,
	0xdd, 0xd9, 0xc0, 0xa7, 0x0a, 0xc0, 0xb0, 0xeb, 0x08, 0xd2, 0x6d, 0xed, 0xf9, 0xe8, 0xa0, 0xa9,
	0x3b, 0x24, 0x7b, 0xd1, 0xf6, 0x4f, 0x91, 0xd7, 0xa4, 0xe1, 0x5b, 0x4a, 0xd0, 0x25, 0xbc, 0xe7,
	0xa3, 0xf3, 0x24, 0x32, 0x38, 0x0d, 0x62, 0xb7, 0x88, 0x17, 0x5c, 0x0d, 0x34, 0x35, 0xac, 0xc2,
	0x85, 0x09, 0x55, 0x8c, 0xcc, 0x5c, 0x04, 0x60, 0x93, 0x32, 0xbf, 0x9a, 0x26, 0x75, 0xf3, 0x33,
	0xca, 0xfc, 0xf8, 0xac, 0x64, 0xec, 0xd0, 0xcd, 0xcf, 0x70, 0xf4, 0xc0, 0x17, 0x71, 0x1e, 0xe4,
	0x43, 0x27, 0x1e, 0x44, 0xc7, 0x42, 0x52, 0xfa, 0x37, 0xec, 0xa6, 0x86, 0xf7, 0x09, 0xa5, 0xb1,
	0xce, 0x92, 0x58, 0x68, 0xd6, 0xbc, 0x1a, 0x0b, 0x31, 0x45, 0xb9, 0x0b, 0x06, 0xed, 0x9c, 0xee,
	0xc6, 0x02, 0xc9, 0x6b, 0x08, 0xd0, 0xfb, 0x75, 0x0d, 0x4c, 0x12, 0x1e, 0x4b, 0x37, 0xf6, 0xce,
	0x98, 0xb3, 0xc8, 0x33, 0x21, 0xfe, 0x8a, 0x60, 0x62, 0xae, 0x40, 0x83, 0x98, 0x9e, 0x2b, 0x7d,
	0x27, 0x4e, 0xa8, 0x00, 0x30, 0x6c, 0x40, 0xac, 0xeb, 0x4a, 0x7f, 0x3f, 0xa1, 0x8f, 0xbd, 0x32,
	0xb9, 0x08, 0x62, 0xf5, 0x31, 0xc3, 0xb0, 0x8b, 0x3e, 0x7d, 0xba, 0x0e, 0xf2, 0x21, 0x15, 0x00,
	0x86, 0x4d, 0x6d, 0xeb, 0x36, 0xd4, 0x52, 0x57, 0x79, 0xf0, 0x6d, 0x3e, 0xad, 0xd4, 0x65, 0xe7,
	0xc5, 0xca, 0xc7, 0x1d, 0x0a, 0x9f, 0xbf, 0x3c, 0xde, 0xa1, 0x23, 0x30, 0x08, 0xa1, 0x0f, 0x8f,
	0x14, 0xee, 0x94, 0x7f, 0x32, 0xe5, 0x2e, 0x51, 0x66, 0x0b, 0xf4, 0x48, 0x7d, 0xfd, 0xa6, 0x0d,
	0xdd, 0x1b, 0x05, 0x84, 0xce, 0x0b, 0x98, 0xd9, 0x3b, 0xb2, 0xdf, 0x77, 0x77, 0x6f, 0xb8, 0x9d,
	0x7c, 0x77, 0xd7, 0x2f, 0xa0, 0x51, 0xfe, 0x2a, 0x6f, 0xd5, 0x60, 0xb2, 0xff, 0x7a, 0x77, 0xc7,
	0xbc, 0x85, 0xad, 0xee, 0xb7, 0xdd, 0x1d, 0xb3, 0x62, 0xcd, 0x40, 0x75, 0xbb, 0xbb, 0x63, 0x4e,
	0x58, 0x06, 0x4c, 0x75, 0x77, 0x77, 0x77, 0xbe, 0x31, 0xab, 0x88, 0xf5, 0xfb, 0x3b, 0xe6, 0x24,
	0x35, 0xbe, 0xdd, 0x31, 0xa7, 0xb0, 0xf1, 0xfa, 0xcd, 0x97, 0xe6, 0x34, 0x2a, 0xbe, 0x7e, 0xb3,
	0xbb, 0x63, 0xce, 0x20, 0xbf, 0xb7, 0xbf, 0xbd, 0xf3, 0x8d, 0x59, 0xb3, 0x9a, 0x00, 0x07, 0x87,
	0x47, 0xbd, 0x83, 0x7d, 0x07, 0xd5, 0x8c, 0xf5, 0x5f, 0x03, 0x8c, 0x3e, 0x70, 0xa3, 0xca, 0x51,
	0xaf, 0xfb, 0xc6, 0xbc, 0x65, 0x4d, 0xc3, 0xc4, 0xde, 0xa6, 0x59, 0xa1, 0xdf, 0x67, 0xe6, 0x04,
	0xfd, 0x3e, 0xe7, 0xf9, 0xf6, 0x36, 0x3f, 0xe3, 0xf9, 0xf6, 0x36, 0x9f, 0x9b, 0x53, 0x28, 0x79,
	0xbd, 0x69, 0x4e, 0xd3, 0xef, 0x33, 0x73, 0x06, 0x7f, 0xb7, 0x37, 0xcd, 0x1a, 0xfe, 0xfe, 0x72,
	0xd3, 0x34, 0x70, 0xcc, 0xbd, 0x83, 0xfd, 0x4d, 0x13, 0xd6, 0xd7, 0xa1, 0x5e, 0x7a, 0x9b, 0x58,
	0xb3, 0x60, 0x74, 0xf7, 0x9d, 0xdd, 0xb7, 0x47, 0x6f, 0x6d, 0xdc, 0x67, 0x03, 0x6a, 0xdd, 0x7d,
	0xa7, 0x7f, 0x74, 0xd0, 0x7d, 0x63, 0x56, 0xd6, 0x57, 0xa0, 0x51, 0x7e, 0x99, 0xe0, 0x74, 0xdd,
	0xfd, 0x5f, 0x99, 0xb7, 0xb0, 0xf1, 0xb6, 0xbf, 0x6d, 0x56, 0x5e, 0x99, 0x7f, 0xfb, 0xfe, 0x41,
	0xe5, 0xef, 0xdf, 0x3f, 0xa8, 0xfc, 0xf3, 0xfb, 0x07, 0x95, 0x3f, 0xfc, 0xeb, 0xc1, 0xad, 0xe3,
	0x69, 0xfa, 0x47, 0xe5, 0xd9, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x1b, 0x8d, 0x06, 0xf6, 0x61,
	0x19, 0x00, 0x00,
}
