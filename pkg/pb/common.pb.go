// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		common.proto
		ctp.proto
		market_data.proto
		others.proto

	It has these top-level messages:
		Symbol
		ProductID
		Kline
		KlineSeries
		BrokerRoute
		BrokerRouteList
		InstrumentInfo
		SimpleTimePeriod
		MarketTimeRule
		ProductInfo
		TradingInstrument
		TradingInstrumentList
		ProductInfoList
		ReqSetTradingInstrumentList
		ReqSetProductInfoList
		ReqUpdateTIOpenDate
		ReqUpdateTIOpenDateList
		AccountMoneySummary
		AccountMoneySummaryList
		MoneyTransferRecord
		MTRList
		UserSession
		SSEStockOption
		CTPOrderID
		CTPOrder
		CTPOrderList
		JointOrder
		CTPOrderLink
		CTPCancelOrderRequest
		CTPOnRtnCancelOrder
		CTPTradeReport
		CTPTradeReportList
		CTPPositionSummation
		CTPPosition
		CTPPositionList
		CTPCloseTradeRecord
		CTPCloseTradeRecordList
		CTPMarginRate
		CTPMarginItem
		CTPCommissionRateItem
		CTPCommissionRate
		CTPTradingUnit
		CTPForceCloseTimeRule
		CTPTradingUnitOption
		MarginCheckRule
		SettlementUnitOption
		CTPTradingAccount
		CTPTradingAccountSnapshot
		OrderBook
		MarketDataSnapshot
		MdsList
		OptionTMarket
		SimpleTickForTQuote
		OptionTQuoteItem
		OptionTQuoteItemList
		NetInAmountDetail
		RealtimeMoneyTrendItem
		RealtimeMoneyTrendItemList
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ExchangeType int32

const (
	// / 上海期货交易所
	ExchangeType_SHFE ExchangeType = 0
	// / 郑州商品交易所
	ExchangeType_CZCE ExchangeType = 1
	// / 大连商品期货交易所
	ExchangeType_DCE ExchangeType = 2
	// / 中金所
	ExchangeType_CFFEX ExchangeType = 3
	// / 上海证券交易所
	ExchangeType_SSE ExchangeType = 4
	// / 深圳证券交易所
	ExchangeType_SZE ExchangeType = 5
	// / 香港证券交易所
	ExchangeType_HKG ExchangeType = 6
	// / 香港期货交易所
	ExchangeType_HKFE ExchangeType = 7
	// / 各类指数
	ExchangeType_INDEX ExchangeType = 8
	// / 上证期权
	ExchangeType_OPTION_SSE ExchangeType = 9
	// / NEW YORK MERCANTILE EXCHANGE
	ExchangeType_NYME ExchangeType = 10
	// / CME GLOBEX
	ExchangeType_GLBX ExchangeType = 11
	// / cbot
	ExchangeType_CBOT ExchangeType = 12
	// / cme
	ExchangeType_CME ExchangeType = 13
	// / comex
	ExchangeType_COMEX ExchangeType = 14
	// / eurex
	ExchangeType_EUREX ExchangeType = 15
	// /
	ExchangeType_IPE ExchangeType = 16
	// / liffe
	ExchangeType_LIFFE ExchangeType = 17
	// / LME
	ExchangeType_LME ExchangeType = 18
	// / SGX
	ExchangeType_SGX ExchangeType = 19
	// demo ex
	ExchangeType_DEMO ExchangeType = 20
	// INE
	ExchangeType_INE ExchangeType = 21
	// / 未知
	ExchangeType_INVALIDEX ExchangeType = 22
)

var ExchangeType_name = map[int32]string{
	0:  "SHFE",
	1:  "CZCE",
	2:  "DCE",
	3:  "CFFEX",
	4:  "SSE",
	5:  "SZE",
	6:  "HKG",
	7:  "HKFE",
	8:  "INDEX",
	9:  "OPTION_SSE",
	10: "NYME",
	11: "GLBX",
	12: "CBOT",
	13: "CME",
	14: "COMEX",
	15: "EUREX",
	16: "IPE",
	17: "LIFFE",
	18: "LME",
	19: "SGX",
	20: "DEMO",
	21: "INE",
	22: "INVALIDEX",
}
var ExchangeType_value = map[string]int32{
	"SHFE":       0,
	"CZCE":       1,
	"DCE":        2,
	"CFFEX":      3,
	"SSE":        4,
	"SZE":        5,
	"HKG":        6,
	"HKFE":       7,
	"INDEX":      8,
	"OPTION_SSE": 9,
	"NYME":       10,
	"GLBX":       11,
	"CBOT":       12,
	"CME":        13,
	"COMEX":      14,
	"EUREX":      15,
	"IPE":        16,
	"LIFFE":      17,
	"LME":        18,
	"SGX":        19,
	"DEMO":       20,
	"INE":        21,
	"INVALIDEX":  22,
}

func (x ExchangeType) String() string {
	return proto.EnumName(ExchangeType_name, int32(x))
}
func (ExchangeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

type ProductType int32

const (
	// 未知
	ProductType_PT_UNKOWN ProductType = 0
	// 期货
	ProductType_PT_FUTURE ProductType = 1
	// 股票
	ProductType_PT_STOCK ProductType = 2
	// 债券
	ProductType_PT_BOND ProductType = 3
	// 组合
	ProductType_PT_COMBINATION ProductType = 4
	// 期权
	ProductType_PT_OPTION ProductType = 5
	// 期货期权
	ProductType_PT_FUTURE_OPTION ProductType = 6
	// 股票期权
	ProductType_PT_STOCK_OPTION ProductType = 7
	// 上证50ETF期权
	ProductType_PT_SSE_ETF_OPTION ProductType = 8
)

var ProductType_name = map[int32]string{
	0: "PT_UNKOWN",
	1: "PT_FUTURE",
	2: "PT_STOCK",
	3: "PT_BOND",
	4: "PT_COMBINATION",
	5: "PT_OPTION",
	6: "PT_FUTURE_OPTION",
	7: "PT_STOCK_OPTION",
	8: "PT_SSE_ETF_OPTION",
}
var ProductType_value = map[string]int32{
	"PT_UNKOWN":         0,
	"PT_FUTURE":         1,
	"PT_STOCK":          2,
	"PT_BOND":           3,
	"PT_COMBINATION":    4,
	"PT_OPTION":         5,
	"PT_FUTURE_OPTION":  6,
	"PT_STOCK_OPTION":   7,
	"PT_SSE_ETF_OPTION": 8,
}

func (x ProductType) String() string {
	return proto.EnumName(ProductType_name, int32(x))
}
func (ProductType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

type PeriodType int32

const (
	// Tick
	PeriodType_TICK PeriodType = 0
	// 分钟
	PeriodType_M1 PeriodType = 1
	// 3分钟
	PeriodType_M3 PeriodType = 2
	// 5分钟
	PeriodType_M5 PeriodType = 3
	// 10分钟
	PeriodType_M10 PeriodType = 4
	// 15分钟
	PeriodType_M15 PeriodType = 5
	// 30分钟
	PeriodType_M30 PeriodType = 6
	// 小时
	PeriodType_H1 PeriodType = 7
	// 3小时
	PeriodType_H3 PeriodType = 8
	// 日线
	PeriodType_D1 PeriodType = 9
	// 周线
	PeriodType_W1 PeriodType = 10
	// 月线
	PeriodType_MON1 PeriodType = 11
)

var PeriodType_name = map[int32]string{
	0:  "TICK",
	1:  "M1",
	2:  "M3",
	3:  "M5",
	4:  "M10",
	5:  "M15",
	6:  "M30",
	7:  "H1",
	8:  "H3",
	9:  "D1",
	10: "W1",
	11: "MON1",
}
var PeriodType_value = map[string]int32{
	"TICK": 0,
	"M1":   1,
	"M3":   2,
	"M5":   3,
	"M10":  4,
	"M15":  5,
	"M30":  6,
	"H1":   7,
	"H3":   8,
	"D1":   9,
	"W1":   10,
	"MON1": 11,
}

func (x PeriodType) String() string {
	return proto.EnumName(PeriodType_name, int32(x))
}
func (PeriodType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

// OptionCallPutType 期权call or put 类型
type OptionCallPutType int32

const (
	OptionCallPutType_OCPT_CALL OptionCallPutType = 0
	OptionCallPutType_OCPT_PUT  OptionCallPutType = 1
)

var OptionCallPutType_name = map[int32]string{
	0: "OCPT_CALL",
	1: "OCPT_PUT",
}
var OptionCallPutType_value = map[string]int32{
	"OCPT_CALL": 0,
	"OCPT_PUT":  1,
}

func (x OptionCallPutType) String() string {
	return proto.EnumName(OptionCallPutType_name, int32(x))
}
func (OptionCallPutType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

// 行权日类型
type OptionDeliveryDateType int32

const (
	OptionDeliveryDateType_ODDT_EUR OptionDeliveryDateType = 0
)

var OptionDeliveryDateType_name = map[int32]string{
	0: "ODDT_EUR",
}
var OptionDeliveryDateType_value = map[string]int32{
	"ODDT_EUR": 0,
}

func (x OptionDeliveryDateType) String() string {
	return proto.EnumName(OptionDeliveryDateType_name, int32(x))
}
func (OptionDeliveryDateType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

// 平仓手续费算法
type CloseCommissionAlgorithim int32

const (
	// 普通
	CloseCommissionAlgorithim_CCA_NORMAL CloseCommissionAlgorithim = 0
	// 收一次
	CloseCommissionAlgorithim_CCA_ONCE CloseCommissionAlgorithim = 1
	// 隔夜日期
	CloseCommissionAlgorithim_CCA_MULTIPLE_BY_DATE CloseCommissionAlgorithim = 2
)

var CloseCommissionAlgorithim_name = map[int32]string{
	0: "CCA_NORMAL",
	1: "CCA_ONCE",
	2: "CCA_MULTIPLE_BY_DATE",
}
var CloseCommissionAlgorithim_value = map[string]int32{
	"CCA_NORMAL":           0,
	"CCA_ONCE":             1,
	"CCA_MULTIPLE_BY_DATE": 2,
}

func (x CloseCommissionAlgorithim) String() string {
	return proto.EnumName(CloseCommissionAlgorithim_name, int32(x))
}
func (CloseCommissionAlgorithim) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCommon, []int{5}
}

type AccountType int32

const (
	AccountType_CN_FUTURE AccountType = 0
	AccountType_CN_STOCK  AccountType = 1
)

var AccountType_name = map[int32]string{
	0: "CN_FUTURE",
	1: "CN_STOCK",
}
var AccountType_value = map[string]int32{
	"CN_FUTURE": 0,
	"CN_STOCK":  1,
}

func (x AccountType) String() string {
	return proto.EnumName(AccountType_name, int32(x))
}
func (AccountType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{6} }

type CurrencyType int32

const (
	CurrencyType_CNY CurrencyType = 0
	CurrencyType_USD CurrencyType = 1
)

var CurrencyType_name = map[int32]string{
	0: "CNY",
	1: "USD",
}
var CurrencyType_value = map[string]int32{
	"CNY": 0,
	"USD": 1,
}

func (x CurrencyType) String() string {
	return proto.EnumName(CurrencyType_name, int32(x))
}
func (CurrencyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{7} }

// 合约代码
type Symbol struct {
	Exchange ExchangeType `protobuf:"varint,1,opt,name=exchange,proto3,enum=pb.ExchangeType" json:"exchange"`
	Code     string       `protobuf:"bytes,2,opt,name=code,proto3" json:"code"`
}

func (m *Symbol) Reset()                    { *m = Symbol{} }
func (m *Symbol) String() string            { return proto.CompactTextString(m) }
func (*Symbol) ProtoMessage()               {}
func (*Symbol) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

func (m *Symbol) GetExchange() ExchangeType {
	if m != nil {
		return m.Exchange
	}
	return ExchangeType_SHFE
}

func (m *Symbol) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// 品种
type ProductID struct {
	Exchange ExchangeType `protobuf:"varint,1,opt,name=exchange,proto3,enum=pb.ExchangeType" json:"exchange"`
	Code     string       `protobuf:"bytes,2,opt,name=code,proto3" json:"code"`
}

func (m *ProductID) Reset()                    { *m = ProductID{} }
func (m *ProductID) String() string            { return proto.CompactTextString(m) }
func (*ProductID) ProtoMessage()               {}
func (*ProductID) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

func (m *ProductID) GetExchange() ExchangeType {
	if m != nil {
		return m.Exchange
	}
	return ExchangeType_SHFE
}

func (m *ProductID) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// K线
type Kline struct {
	// 时间
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time"`
	// 开盘
	Open float64 `protobuf:"fixed64,2,opt,name=open,proto3" json:"open"`
	// 最高
	High float64 `protobuf:"fixed64,3,opt,name=high,proto3" json:"high"`
	// 最低
	Low float64 `protobuf:"fixed64,4,opt,name=low,proto3" json:"low"`
	// 收盘
	Close float64 `protobuf:"fixed64,5,opt,name=close,proto3" json:"close"`
	// 成交量
	Volume float64 `protobuf:"fixed64,6,opt,name=volume,proto3" json:"volume"`
	// 成交额
	Amount float64 `protobuf:"fixed64,7,opt,name=amount,proto3" json:"amount"`
	// 持仓量
	Position float64 `protobuf:"fixed64,8,opt,name=position,proto3" json:"position"`
}

func (m *Kline) Reset()                    { *m = Kline{} }
func (m *Kline) String() string            { return proto.CompactTextString(m) }
func (*Kline) ProtoMessage()               {}
func (*Kline) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

func (m *Kline) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Kline) GetOpen() float64 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *Kline) GetHigh() float64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *Kline) GetLow() float64 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *Kline) GetClose() float64 {
	if m != nil {
		return m.Close
	}
	return 0
}

func (m *Kline) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *Kline) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Kline) GetPosition() float64 {
	if m != nil {
		return m.Position
	}
	return 0
}

// KlineSeries K线序列
type KlineSeries struct {
	Symbol Symbol     `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	Period PeriodType `protobuf:"varint,2,opt,name=period,proto3,enum=pb.PeriodType" json:"period"`
	List   []Kline    `protobuf:"bytes,3,rep,name=list" json:"list"`
}

func (m *KlineSeries) Reset()                    { *m = KlineSeries{} }
func (m *KlineSeries) String() string            { return proto.CompactTextString(m) }
func (*KlineSeries) ProtoMessage()               {}
func (*KlineSeries) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

func (m *KlineSeries) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *KlineSeries) GetPeriod() PeriodType {
	if m != nil {
		return m.Period
	}
	return PeriodType_TICK
}

func (m *KlineSeries) GetList() []Kline {
	if m != nil {
		return m.List
	}
	return nil
}

// 经纪商通道
type BrokerRoute struct {
	Id             string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Type           int32    `protobuf:"varint,2,opt,name=type,proto3" json:"type"`
	Name           string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	MdFrontList    []string `protobuf:"bytes,4,rep,name=md_front_list,json=mdFrontList" json:"mdFrontList"`
	TradeFrontList []string `protobuf:"bytes,5,rep,name=trade_front_list,json=tradeFrontList" json:"tradeFrontList"`
}

func (m *BrokerRoute) Reset()                    { *m = BrokerRoute{} }
func (m *BrokerRoute) String() string            { return proto.CompactTextString(m) }
func (*BrokerRoute) ProtoMessage()               {}
func (*BrokerRoute) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

func (m *BrokerRoute) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BrokerRoute) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BrokerRoute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BrokerRoute) GetMdFrontList() []string {
	if m != nil {
		return m.MdFrontList
	}
	return nil
}

func (m *BrokerRoute) GetTradeFrontList() []string {
	if m != nil {
		return m.TradeFrontList
	}
	return nil
}

type BrokerRouteList struct {
	List []BrokerRoute `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *BrokerRouteList) Reset()                    { *m = BrokerRouteList{} }
func (m *BrokerRouteList) String() string            { return proto.CompactTextString(m) }
func (*BrokerRouteList) ProtoMessage()               {}
func (*BrokerRouteList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5} }

func (m *BrokerRouteList) GetList() []BrokerRoute {
	if m != nil {
		return m.List
	}
	return nil
}

// 合约行情信息
type InstrumentInfo struct {
	// / 合约名称.
	SymbolName string `protobuf:"bytes,1,opt,name=symbol_name,json=symbolName,proto3" json:"symbolName"`
	// / 是否单边大保
	PositionRank int32 `protobuf:"varint,2,opt,name=position_rank,json=positionRank,proto3" json:"positionRank"`
	// / 更新时间.
	UpdateTime int64 `protobuf:"varint,3,opt,name=update_time,json=updateTime,proto3" json:"updateTime"`
	// 交易日
	UpdateTradingDay int32 `protobuf:"varint,4,opt,name=update_trading_day,json=updateTradingDay,proto3" json:"updateTradingDay"`
	// / 涨停价.
	UpperLimitPrice float64 `protobuf:"fixed64,5,opt,name=upper_limit_price,json=upperLimitPrice,proto3" json:"upperLimitPrice"`
	// / 跌停价.
	LowerLimitPrice float64 `protobuf:"fixed64,6,opt,name=lower_limit_price,json=lowerLimitPrice,proto3" json:"lowerLimitPrice"`
	// 昨收
	PreClosePrice float64 `protobuf:"fixed64,7,opt,name=pre_close_price,json=preClosePrice,proto3" json:"preClosePrice"`
	// 昨结
	PreSettlementPrice float64 `protobuf:"fixed64,8,opt,name=pre_settlement_price,json=preSettlementPrice,proto3" json:"preSettlementPrice"`
	// 昨成交
	PreVolume int32 `protobuf:"varint,9,opt,name=pre_volume,json=preVolume,proto3" json:"preVolume"`
	// 昨持仓
	PrePosition int32 `protobuf:"varint,10,opt,name=pre_position,json=prePosition,proto3" json:"prePosition"`
	// 今天结算价
	SettlementPrice float64 `protobuf:"fixed64,11,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlementPrice"`
	// 创建日期
	CreateDate int32 `protobuf:"varint,12,opt,name=create_date,json=createDate,proto3" json:"createDate"`
	// 上市日期
	OpenDate int32 `protobuf:"varint,13,opt,name=open_date,json=openDate,proto3" json:"openDate"`
	// 到期日期
	ExpireDate int32 `protobuf:"varint,14,opt,name=expire_date,json=expireDate,proto3" json:"expireDate"`
	// 开始交割日期
	StartDeliverDate int32 `protobuf:"varint,15,opt,name=start_deliver_date,json=startDeliverDate,proto3" json:"startDeliverDate"`
	// 结束交割日期
	EndDeliverDate int32 `protobuf:"varint,16,opt,name=end_deliver_date,json=endDeliverDate,proto3" json:"endDeliverDate"`
	// 是否T+0
	IsCloseTodayAllowed int32 `protobuf:"varint,17,opt,name=is_close_today_allowed,json=isCloseTodayAllowed,proto3" json:"isCloseTodayAllowed"`
	// 市价最大下单量
	MaxMarketOrderVolume int32 `protobuf:"varint,18,opt,name=max_market_order_volume,json=maxMarketOrderVolume,proto3" json:"maxMarketOrderVolume"`
	// 市价最小下单量
	MinMarketOrderVolume int32 `protobuf:"varint,19,opt,name=min_market_order_volume,json=minMarketOrderVolume,proto3" json:"minMarketOrderVolume"`
	// 限价最大下单量
	MaxLimitOrderVolume int32 `protobuf:"varint,20,opt,name=max_limit_order_volume,json=maxLimitOrderVolume,proto3" json:"maxLimitOrderVolume"`
	// 限价最小下单量
	MinLimitOrderVolume int32 `protobuf:"varint,21,opt,name=min_limit_order_volume,json=minLimitOrderVolume,proto3" json:"minLimitOrderVolume"`
	// 基础合约
	BaseSymbol Symbol `protobuf:"bytes,22,opt,name=base_symbol,json=baseSymbol" json:"baseSymbol"`
	// 行权价
	StrikePrice float64 `protobuf:"fixed64,23,opt,name=strike_price,json=strikePrice,proto3" json:"strikePrice"`
	// /期权类型
	CallPutType OptionCallPutType `protobuf:"varint,24,opt,name=call_put_type,json=callPutType,proto3,enum=pb.OptionCallPutType" json:"callPutType"`
	// /合约基础商品乘数
	UnderlyingMultiple float64 `protobuf:"fixed64,25,opt,name=underlying_multiple,json=underlyingMultiple,proto3" json:"underlyingMultiple"`
	// /组合类型
	CombinationType int32 `protobuf:"varint,26,opt,name=combination_type,json=combinationType,proto3" json:"combinationType"`
	// /最小买下单单位
	MinBuyVolume int32 `protobuf:"varint,27,opt,name=min_buy_volume,json=minBuyVolume,proto3" json:"minBuyVolume"`
	// /最小卖下单单位
	MinSellVolume int32 `protobuf:"varint,28,opt,name=min_sell_volume,json=minSellVolume,proto3" json:"minSellVolume"`
	// /合约标识码
	InstrumentCode Symbol `protobuf:"bytes,29,opt,name=instrument_code,json=instrumentCode" json:"instrumentCode"`
	// 是否在交易
	IsTrading bool `protobuf:"varint,30,opt,name=is_trading,json=isTrading,proto3" json:"isTrading"`
	// 行权方式类型
	DeliveryDateType OptionDeliveryDateType `protobuf:"varint,31,opt,name=delivery_date_type,json=deliveryDateType,proto3,enum=pb.OptionDeliveryDateType" json:"deliveryDateType"`
}

func (m *InstrumentInfo) Reset()                    { *m = InstrumentInfo{} }
func (m *InstrumentInfo) String() string            { return proto.CompactTextString(m) }
func (*InstrumentInfo) ProtoMessage()               {}
func (*InstrumentInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{6} }

func (m *InstrumentInfo) GetSymbolName() string {
	if m != nil {
		return m.SymbolName
	}
	return ""
}

func (m *InstrumentInfo) GetPositionRank() int32 {
	if m != nil {
		return m.PositionRank
	}
	return 0
}

func (m *InstrumentInfo) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *InstrumentInfo) GetUpdateTradingDay() int32 {
	if m != nil {
		return m.UpdateTradingDay
	}
	return 0
}

func (m *InstrumentInfo) GetUpperLimitPrice() float64 {
	if m != nil {
		return m.UpperLimitPrice
	}
	return 0
}

func (m *InstrumentInfo) GetLowerLimitPrice() float64 {
	if m != nil {
		return m.LowerLimitPrice
	}
	return 0
}

func (m *InstrumentInfo) GetPreClosePrice() float64 {
	if m != nil {
		return m.PreClosePrice
	}
	return 0
}

func (m *InstrumentInfo) GetPreSettlementPrice() float64 {
	if m != nil {
		return m.PreSettlementPrice
	}
	return 0
}

func (m *InstrumentInfo) GetPreVolume() int32 {
	if m != nil {
		return m.PreVolume
	}
	return 0
}

func (m *InstrumentInfo) GetPrePosition() int32 {
	if m != nil {
		return m.PrePosition
	}
	return 0
}

func (m *InstrumentInfo) GetSettlementPrice() float64 {
	if m != nil {
		return m.SettlementPrice
	}
	return 0
}

func (m *InstrumentInfo) GetCreateDate() int32 {
	if m != nil {
		return m.CreateDate
	}
	return 0
}

func (m *InstrumentInfo) GetOpenDate() int32 {
	if m != nil {
		return m.OpenDate
	}
	return 0
}

func (m *InstrumentInfo) GetExpireDate() int32 {
	if m != nil {
		return m.ExpireDate
	}
	return 0
}

func (m *InstrumentInfo) GetStartDeliverDate() int32 {
	if m != nil {
		return m.StartDeliverDate
	}
	return 0
}

func (m *InstrumentInfo) GetEndDeliverDate() int32 {
	if m != nil {
		return m.EndDeliverDate
	}
	return 0
}

func (m *InstrumentInfo) GetIsCloseTodayAllowed() int32 {
	if m != nil {
		return m.IsCloseTodayAllowed
	}
	return 0
}

func (m *InstrumentInfo) GetMaxMarketOrderVolume() int32 {
	if m != nil {
		return m.MaxMarketOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetMinMarketOrderVolume() int32 {
	if m != nil {
		return m.MinMarketOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetMaxLimitOrderVolume() int32 {
	if m != nil {
		return m.MaxLimitOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetMinLimitOrderVolume() int32 {
	if m != nil {
		return m.MinLimitOrderVolume
	}
	return 0
}

func (m *InstrumentInfo) GetBaseSymbol() Symbol {
	if m != nil {
		return m.BaseSymbol
	}
	return Symbol{}
}

func (m *InstrumentInfo) GetStrikePrice() float64 {
	if m != nil {
		return m.StrikePrice
	}
	return 0
}

func (m *InstrumentInfo) GetCallPutType() OptionCallPutType {
	if m != nil {
		return m.CallPutType
	}
	return OptionCallPutType_OCPT_CALL
}

func (m *InstrumentInfo) GetUnderlyingMultiple() float64 {
	if m != nil {
		return m.UnderlyingMultiple
	}
	return 0
}

func (m *InstrumentInfo) GetCombinationType() int32 {
	if m != nil {
		return m.CombinationType
	}
	return 0
}

func (m *InstrumentInfo) GetMinBuyVolume() int32 {
	if m != nil {
		return m.MinBuyVolume
	}
	return 0
}

func (m *InstrumentInfo) GetMinSellVolume() int32 {
	if m != nil {
		return m.MinSellVolume
	}
	return 0
}

func (m *InstrumentInfo) GetInstrumentCode() Symbol {
	if m != nil {
		return m.InstrumentCode
	}
	return Symbol{}
}

func (m *InstrumentInfo) GetIsTrading() bool {
	if m != nil {
		return m.IsTrading
	}
	return false
}

func (m *InstrumentInfo) GetDeliveryDateType() OptionDeliveryDateType {
	if m != nil {
		return m.DeliveryDateType
	}
	return OptionDeliveryDateType_ODDT_EUR
}

type SimpleTimePeriod struct {
	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end"`
}

func (m *SimpleTimePeriod) Reset()                    { *m = SimpleTimePeriod{} }
func (m *SimpleTimePeriod) String() string            { return proto.CompactTextString(m) }
func (*SimpleTimePeriod) ProtoMessage()               {}
func (*SimpleTimePeriod) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{7} }

func (m *SimpleTimePeriod) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SimpleTimePeriod) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

type MarketTimeRule struct {
	SendRule     []SimpleTimePeriod `protobuf:"bytes,1,rep,name=send_rule,json=sendRule" json:"sendRule"`
	CancelRule   []SimpleTimePeriod `protobuf:"bytes,2,rep,name=cancel_rule,json=cancelRule" json:"cancelRule"`
	MatchingRule []SimpleTimePeriod `protobuf:"bytes,3,rep,name=matching_rule,json=matchingRule" json:"matchingRule"`
}

func (m *MarketTimeRule) Reset()                    { *m = MarketTimeRule{} }
func (m *MarketTimeRule) String() string            { return proto.CompactTextString(m) }
func (*MarketTimeRule) ProtoMessage()               {}
func (*MarketTimeRule) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{8} }

func (m *MarketTimeRule) GetSendRule() []SimpleTimePeriod {
	if m != nil {
		return m.SendRule
	}
	return nil
}

func (m *MarketTimeRule) GetCancelRule() []SimpleTimePeriod {
	if m != nil {
		return m.CancelRule
	}
	return nil
}

func (m *MarketTimeRule) GetMatchingRule() []SimpleTimePeriod {
	if m != nil {
		return m.MatchingRule
	}
	return nil
}

// 品种信息.
type ProductInfo struct {
	// 品种代码.
	ProductId ProductID `protobuf:"bytes,1,opt,name=product_id,json=productId" json:"productId"`
	// 子类型
	ProductGroupId ProductID `protobuf:"bytes,2,opt,name=product_group_id,json=productGroupId" json:"productGroupId"`
	// 类型
	Type ProductType `protobuf:"varint,3,opt,name=type,proto3,enum=pb.ProductType" json:"type"`
	// / 品种名称
	ProductName string `protobuf:"bytes,4,opt,name=product_name,json=productName,proto3" json:"productName"`
	// 最小变动价位.
	PriceTick float64 `protobuf:"fixed64,5,opt,name=price_tick,json=priceTick,proto3" json:"priceTick"`
	// 合约乘数
	VolumeMultiple int32 `protobuf:"varint,6,opt,name=volume_multiple,json=volumeMultiple,proto3" json:"volumeMultiple"`
	// 昨总成交
	PreVolume int32 `protobuf:"varint,7,opt,name=pre_volume,json=preVolume,proto3" json:"preVolume"`
	// 昨持仓
	PrePosition int32 `protobuf:"varint,8,opt,name=pre_position,json=prePosition,proto3" json:"prePosition"`
	// 币种
	CurrencyType int32 `protobuf:"varint,9,opt,name=currency_type,json=currencyType,proto3" json:"currencyType"`
	// 结算组
	SettlementGroup int32 `protobuf:"varint,10,opt,name=settlement_group,json=settlementGroup,proto3" json:"settlementGroup"`
	// 时间
	TimeRule MarketTimeRule `protobuf:"bytes,11,opt,name=time_rule,json=timeRule" json:"timeRule"`
	// 区分昨仓今仓
	DistinguishPositionTime bool `protobuf:"varint,12,opt,name=distinguish_position_time,json=distinguishPositionTime,proto3" json:"distinguishPositionTime"`
}

func (m *ProductInfo) Reset()                    { *m = ProductInfo{} }
func (m *ProductInfo) String() string            { return proto.CompactTextString(m) }
func (*ProductInfo) ProtoMessage()               {}
func (*ProductInfo) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{9} }

func (m *ProductInfo) GetProductId() ProductID {
	if m != nil {
		return m.ProductId
	}
	return ProductID{}
}

func (m *ProductInfo) GetProductGroupId() ProductID {
	if m != nil {
		return m.ProductGroupId
	}
	return ProductID{}
}

func (m *ProductInfo) GetType() ProductType {
	if m != nil {
		return m.Type
	}
	return ProductType_PT_UNKOWN
}

func (m *ProductInfo) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *ProductInfo) GetPriceTick() float64 {
	if m != nil {
		return m.PriceTick
	}
	return 0
}

func (m *ProductInfo) GetVolumeMultiple() int32 {
	if m != nil {
		return m.VolumeMultiple
	}
	return 0
}

func (m *ProductInfo) GetPreVolume() int32 {
	if m != nil {
		return m.PreVolume
	}
	return 0
}

func (m *ProductInfo) GetPrePosition() int32 {
	if m != nil {
		return m.PrePosition
	}
	return 0
}

func (m *ProductInfo) GetCurrencyType() int32 {
	if m != nil {
		return m.CurrencyType
	}
	return 0
}

func (m *ProductInfo) GetSettlementGroup() int32 {
	if m != nil {
		return m.SettlementGroup
	}
	return 0
}

func (m *ProductInfo) GetTimeRule() MarketTimeRule {
	if m != nil {
		return m.TimeRule
	}
	return MarketTimeRule{}
}

func (m *ProductInfo) GetDistinguishPositionTime() bool {
	if m != nil {
		return m.DistinguishPositionTime
	}
	return false
}

// 交易合约
type TradingInstrument struct {
	// / 合约编码
	Symbol Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	// 合约信息
	InstrumentInfo InstrumentInfo `protobuf:"bytes,2,opt,name=instrument_info,json=instrumentInfo" json:"instrumentInfo"`
	// 品种信息
	ProductInfo ProductInfo `protobuf:"bytes,3,opt,name=product_info,json=productInfo" json:"productInfo"`
}

func (m *TradingInstrument) Reset()                    { *m = TradingInstrument{} }
func (m *TradingInstrument) String() string            { return proto.CompactTextString(m) }
func (*TradingInstrument) ProtoMessage()               {}
func (*TradingInstrument) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{10} }

func (m *TradingInstrument) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *TradingInstrument) GetInstrumentInfo() InstrumentInfo {
	if m != nil {
		return m.InstrumentInfo
	}
	return InstrumentInfo{}
}

func (m *TradingInstrument) GetProductInfo() ProductInfo {
	if m != nil {
		return m.ProductInfo
	}
	return ProductInfo{}
}

type TradingInstrumentList struct {
	List []TradingInstrument `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *TradingInstrumentList) Reset()                    { *m = TradingInstrumentList{} }
func (m *TradingInstrumentList) String() string            { return proto.CompactTextString(m) }
func (*TradingInstrumentList) ProtoMessage()               {}
func (*TradingInstrumentList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{11} }

func (m *TradingInstrumentList) GetList() []TradingInstrument {
	if m != nil {
		return m.List
	}
	return nil
}

type ProductInfoList struct {
	List []ProductInfo `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *ProductInfoList) Reset()                    { *m = ProductInfoList{} }
func (m *ProductInfoList) String() string            { return proto.CompactTextString(m) }
func (*ProductInfoList) ProtoMessage()               {}
func (*ProductInfoList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{12} }

func (m *ProductInfoList) GetList() []ProductInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type ReqSetTradingInstrumentList struct {
	OpCode   string              `protobuf:"bytes,1,opt,name=op_code,json=opCode,proto3" json:"opCode"`
	Exchange int32               `protobuf:"varint,2,opt,name=exchange,proto3" json:"exchange"`
	List     []TradingInstrument `protobuf:"bytes,3,rep,name=list" json:"list"`
}

func (m *ReqSetTradingInstrumentList) Reset()         { *m = ReqSetTradingInstrumentList{} }
func (m *ReqSetTradingInstrumentList) String() string { return proto.CompactTextString(m) }
func (*ReqSetTradingInstrumentList) ProtoMessage()    {}
func (*ReqSetTradingInstrumentList) Descriptor() ([]byte, []int) {
	return fileDescriptorCommon, []int{13}
}

func (m *ReqSetTradingInstrumentList) GetOpCode() string {
	if m != nil {
		return m.OpCode
	}
	return ""
}

func (m *ReqSetTradingInstrumentList) GetExchange() int32 {
	if m != nil {
		return m.Exchange
	}
	return 0
}

func (m *ReqSetTradingInstrumentList) GetList() []TradingInstrument {
	if m != nil {
		return m.List
	}
	return nil
}

type ReqSetProductInfoList struct {
	OpCode   string        `protobuf:"bytes,1,opt,name=op_code,json=opCode,proto3" json:"opCode"`
	Exchange int32         `protobuf:"varint,2,opt,name=exchange,proto3" json:"exchange"`
	List     []ProductInfo `protobuf:"bytes,3,rep,name=list" json:"list"`
}

func (m *ReqSetProductInfoList) Reset()                    { *m = ReqSetProductInfoList{} }
func (m *ReqSetProductInfoList) String() string            { return proto.CompactTextString(m) }
func (*ReqSetProductInfoList) ProtoMessage()               {}
func (*ReqSetProductInfoList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{14} }

func (m *ReqSetProductInfoList) GetOpCode() string {
	if m != nil {
		return m.OpCode
	}
	return ""
}

func (m *ReqSetProductInfoList) GetExchange() int32 {
	if m != nil {
		return m.Exchange
	}
	return 0
}

func (m *ReqSetProductInfoList) GetList() []ProductInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type ReqUpdateTIOpenDate struct {
	Symbol   Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	OpenDate int32  `protobuf:"varint,2,opt,name=open_date,json=openDate,proto3" json:"openDate"`
}

func (m *ReqUpdateTIOpenDate) Reset()                    { *m = ReqUpdateTIOpenDate{} }
func (m *ReqUpdateTIOpenDate) String() string            { return proto.CompactTextString(m) }
func (*ReqUpdateTIOpenDate) ProtoMessage()               {}
func (*ReqUpdateTIOpenDate) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{15} }

func (m *ReqUpdateTIOpenDate) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *ReqUpdateTIOpenDate) GetOpenDate() int32 {
	if m != nil {
		return m.OpenDate
	}
	return 0
}

type ReqUpdateTIOpenDateList struct {
	Exchange int32                 `protobuf:"varint,1,opt,name=exchange,proto3" json:"exchange"`
	List     []ReqUpdateTIOpenDate `protobuf:"bytes,2,rep,name=list" json:"list"`
	OpCode   string                `protobuf:"bytes,3,opt,name=op_code,json=opCode,proto3" json:"opCode"`
}

func (m *ReqUpdateTIOpenDateList) Reset()                    { *m = ReqUpdateTIOpenDateList{} }
func (m *ReqUpdateTIOpenDateList) String() string            { return proto.CompactTextString(m) }
func (*ReqUpdateTIOpenDateList) ProtoMessage()               {}
func (*ReqUpdateTIOpenDateList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{16} }

func (m *ReqUpdateTIOpenDateList) GetExchange() int32 {
	if m != nil {
		return m.Exchange
	}
	return 0
}

func (m *ReqUpdateTIOpenDateList) GetList() []ReqUpdateTIOpenDate {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *ReqUpdateTIOpenDateList) GetOpCode() string {
	if m != nil {
		return m.OpCode
	}
	return ""
}

// 结算账户资金信息
type AccountMoneySummary struct {
	// 账号
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// 结算组（可能单个结算组给个摘要)
	Type AccountType `protobuf:"varint,2,opt,name=type,proto3,enum=pb.AccountType" json:"type"`
	// 币种
	CurrencyType CurrencyType `protobuf:"varint,3,opt,name=currency_type,json=currencyType,proto3,enum=pb.CurrencyType" json:"currencyType"`
	// / 余额
	Balance float64 `protobuf:"fixed64,4,opt,name=balance,proto3" json:"balance"`
	// / 手续费
	Commission float64 `protobuf:"fixed64,5,opt,name=commission,proto3" json:"commission"`
	// / 占用保证金
	CurMargin float64 `protobuf:"fixed64,6,opt,name=cur_margin,json=curMargin,proto3" json:"curMargin"`
	// / 持仓市值.
	NetPositionAmount float64 `protobuf:"fixed64,7,opt,name=net_position_amount,json=netPositionAmount,proto3" json:"netPositionAmount"`
	// / 上次余额
	PreBalance float64 `protobuf:"fixed64,8,opt,name=pre_balance,json=preBalance,proto3" json:"preBalance"`
	// / 利息收入
	InterestIn float64 `protobuf:"fixed64,9,opt,name=interest_in,json=interestIn,proto3" json:"interestIn"`
	// / 存款
	Deposit float64 `protobuf:"fixed64,10,opt,name=deposit,proto3" json:"deposit"`
	// / 取款
	Withdraw float64 `protobuf:"fixed64,11,opt,name=withdraw,proto3" json:"withdraw"`
	// / 冻结保证金
	FrozenMargin float64 `protobuf:"fixed64,12,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozenMargin"`
	// / 冻结手续费
	FrozenCommission float64 `protobuf:"fixed64,13,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozenCommission"`
	// / 可用资金
	Available float64 `protobuf:"fixed64,14,opt,name=available,proto3" json:"available"`
	// / 平仓盈亏
	CloseProfit float64 `protobuf:"fixed64,15,opt,name=close_profit,json=closeProfit,proto3" json:"closeProfit"`
	// / 持仓盈亏
	PositionProfit float64 `protobuf:"fixed64,16,opt,name=position_profit,json=positionProfit,proto3" json:"positionProfit"`
	// 上次质押金额
	PreMortgate float64 `protobuf:"fixed64,17,opt,name=pre_mortgate,json=preMortgate,proto3" json:"preMortgate"`
	// 上次信用额度
	PreCredit float64 `protobuf:"fixed64,18,opt,name=pre_credit,json=preCredit,proto3" json:"preCredit"`
	// 利息基数
	InterestBase float64 `protobuf:"fixed64,19,opt,name=interest_base,json=interestBase,proto3" json:"interestBase"`
	// 可取资金
	WithdrawAvailable float64 `protobuf:"fixed64,20,opt,name=withdraw_available,json=withdrawAvailable,proto3" json:"withdrawAvailable"`
	// 基本准备金
	Reserve float64 `protobuf:"fixed64,21,opt,name=reserve,proto3" json:"reserve"`
	// 交易日
	TradingDay int32 `protobuf:"varint,22,opt,name=trading_day,json=tradingDay,proto3" json:"tradingDay"`
	// 信用额度
	Credit float64 `protobuf:"fixed64,23,opt,name=credit,proto3" json:"credit"`
	// 质押金额
	Mortgate float64 `protobuf:"fixed64,24,opt,name=mortgate,proto3" json:"mortgate"`
	// 交易所保证金
	ExchangeMargin float64 `protobuf:"fixed64,25,opt,name=exchange_margin,json=exchangeMargin,proto3" json:"exchangeMargin"`
	// 交割保证金
	DeliveryMargin float64 `protobuf:"fixed64,26,opt,name=delivery_margin,json=deliveryMargin,proto3" json:"deliveryMargin"`
	// 交易所交割保证金
	ExchangeDeliveryMargin float64 `protobuf:"fixed64,27,opt,name=exchange_delivery_margin,json=exchangeDeliveryMargin,proto3" json:"exchangeDeliveryMargin"`
	// 保底期货结算准备金
	ReserveBalance float64 `protobuf:"fixed64,28,opt,name=reserve_balance,json=reserveBalance,proto3" json:"reserveBalance"`
	// 交割手续费
	DeliveryCommission float64 `protobuf:"fixed64,29,opt,name=delivery_commission,json=deliveryCommission,proto3" json:"deliveryCommission"`
	// 冻结过户费
	FrozenTransferFee float64 `protobuf:"fixed64,30,opt,name=frozen_transfer_fee,json=frozenTransferFee,proto3" json:"frozenTransferFee"`
	// 冻结的印花税
	FrozenStampTax float64 `protobuf:"fixed64,31,opt,name=frozen_stamp_tax,json=frozenStampTax,proto3" json:"frozenStampTax"`
	// 过户费
	TransferFee float64 `protobuf:"fixed64,32,opt,name=transfer_fee,json=transferFee,proto3" json:"transferFee"`
	// 印花税
	StampTax float64 `protobuf:"fixed64,33,opt,name=stamp_tax,json=stampTax,proto3" json:"stampTax"`
	// / 盯市盈亏
	MtmProfit float64 `protobuf:"fixed64,34,opt,name=mtm_profit,json=mtmProfit,proto3" json:"mtmProfit"`
	// /授信额度
	PreMtmProfit float64 `protobuf:"fixed64,35,opt,name=pre_mtm_profit,json=preMtmProfit,proto3" json:"preMtmProfit"`
	// /证券总价值
	StockValue float64 `protobuf:"fixed64,36,opt,name=stock_value,json=stockValue,proto3" json:"stockValue"`
	// /国债回购占用资金
	BondRepurchaseAmount float64 `protobuf:"fixed64,37,opt,name=bond_repurchase_amount,json=bondRepurchaseAmount,proto3" json:"bondRepurchaseAmount"`
	// /国债逆回购占用资金
	ReverseRepurchaseAmount float64 `protobuf:"fixed64,38,opt,name=reverse_repurchase_amount,json=reverseRepurchaseAmount,proto3" json:"reverseRepurchaseAmount"`
	// /融资买入金额
	MarginTradeAmount float64 `protobuf:"fixed64,39,opt,name=margin_trade_amount,json=marginTradeAmount,proto3" json:"marginTradeAmount"`
	// /融券卖出金额
	ShortSellAmount float64 `protobuf:"fixed64,40,opt,name=short_sell_amount,json=shortSellAmount,proto3" json:"shortSellAmount"`
	// /融资持仓盈亏
	MarginTradeProfit float64 `protobuf:"fixed64,41,opt,name=margin_trade_profit,json=marginTradeProfit,proto3" json:"marginTradeProfit"`
	// /融券持仓盈亏
	ShortSellProfit float64 `protobuf:"fixed64,42,opt,name=short_sell_profit,json=shortSellProfit,proto3" json:"shortSellProfit"`
	// 冻结平仓所需要费用
	FrozenCloseCommission float64 `protobuf:"fixed64,43,opt,name=frozen_close_commission,json=frozenCloseCommission,proto3" json:"frozenCloseCommission"`
	// 劣后
	CommonBalance float64 `protobuf:"fixed64,44,opt,name=common_balance,json=commonBalance,proto3" json:"commonBalance"`
	// 优先资金
	PreferedBalance float64 `protobuf:"fixed64,45,opt,name=prefered_balance,json=preferedBalance,proto3" json:"preferedBalance"`
	// 兑换基础货币汇率
	BaseExchangeRate float64 `protobuf:"fixed64,46,opt,name=base_exchange_rate,json=baseExchangeRate,proto3" json:"baseExchangeRate"`
	// 报警
	WarningLevel float64 `protobuf:"fixed64,47,opt,name=warning_level,json=warningLevel,proto3" json:"warningLevel"`
	// 强平
	ForceCloseLevel float64 `protobuf:"fixed64,48,opt,name=force_close_level,json=forceCloseLevel,proto3" json:"forceCloseLevel"`
	// 进入清算的平仓盈亏
	ClearedClosedProfit float64 `protobuf:"fixed64,49,opt,name=cleared_closed_profit,json=clearedClosedProfit,proto3" json:"clearedClosedProfit"`
	// 名称
	Name string `protobuf:"bytes,50,opt,name=name,proto3" json:"name"`
	// 利息
	Interest float64 `protobuf:"fixed64,51,opt,name=interest,proto3" json:"interest"`
	// 冻结利息
	FrozenInterest float64 `protobuf:"fixed64,52,opt,name=frozen_interest,json=frozenInterest,proto3" json:"frozenInterest"`
}

func (m *AccountMoneySummary) Reset()                    { *m = AccountMoneySummary{} }
func (m *AccountMoneySummary) String() string            { return proto.CompactTextString(m) }
func (*AccountMoneySummary) ProtoMessage()               {}
func (*AccountMoneySummary) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{17} }

func (m *AccountMoneySummary) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AccountMoneySummary) GetType() AccountType {
	if m != nil {
		return m.Type
	}
	return AccountType_CN_FUTURE
}

func (m *AccountMoneySummary) GetCurrencyType() CurrencyType {
	if m != nil {
		return m.CurrencyType
	}
	return CurrencyType_CNY
}

func (m *AccountMoneySummary) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *AccountMoneySummary) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *AccountMoneySummary) GetCurMargin() float64 {
	if m != nil {
		return m.CurMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetNetPositionAmount() float64 {
	if m != nil {
		return m.NetPositionAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetPreBalance() float64 {
	if m != nil {
		return m.PreBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetInterestIn() float64 {
	if m != nil {
		return m.InterestIn
	}
	return 0
}

func (m *AccountMoneySummary) GetDeposit() float64 {
	if m != nil {
		return m.Deposit
	}
	return 0
}

func (m *AccountMoneySummary) GetWithdraw() float64 {
	if m != nil {
		return m.Withdraw
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *AccountMoneySummary) GetAvailable() float64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *AccountMoneySummary) GetCloseProfit() float64 {
	if m != nil {
		return m.CloseProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetPreMortgate() float64 {
	if m != nil {
		return m.PreMortgate
	}
	return 0
}

func (m *AccountMoneySummary) GetPreCredit() float64 {
	if m != nil {
		return m.PreCredit
	}
	return 0
}

func (m *AccountMoneySummary) GetInterestBase() float64 {
	if m != nil {
		return m.InterestBase
	}
	return 0
}

func (m *AccountMoneySummary) GetWithdrawAvailable() float64 {
	if m != nil {
		return m.WithdrawAvailable
	}
	return 0
}

func (m *AccountMoneySummary) GetReserve() float64 {
	if m != nil {
		return m.Reserve
	}
	return 0
}

func (m *AccountMoneySummary) GetTradingDay() int32 {
	if m != nil {
		return m.TradingDay
	}
	return 0
}

func (m *AccountMoneySummary) GetCredit() float64 {
	if m != nil {
		return m.Credit
	}
	return 0
}

func (m *AccountMoneySummary) GetMortgate() float64 {
	if m != nil {
		return m.Mortgate
	}
	return 0
}

func (m *AccountMoneySummary) GetExchangeMargin() float64 {
	if m != nil {
		return m.ExchangeMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetDeliveryMargin() float64 {
	if m != nil {
		return m.DeliveryMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetExchangeDeliveryMargin() float64 {
	if m != nil {
		return m.ExchangeDeliveryMargin
	}
	return 0
}

func (m *AccountMoneySummary) GetReserveBalance() float64 {
	if m != nil {
		return m.ReserveBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetDeliveryCommission() float64 {
	if m != nil {
		return m.DeliveryCommission
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenTransferFee() float64 {
	if m != nil {
		return m.FrozenTransferFee
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenStampTax() float64 {
	if m != nil {
		return m.FrozenStampTax
	}
	return 0
}

func (m *AccountMoneySummary) GetTransferFee() float64 {
	if m != nil {
		return m.TransferFee
	}
	return 0
}

func (m *AccountMoneySummary) GetStampTax() float64 {
	if m != nil {
		return m.StampTax
	}
	return 0
}

func (m *AccountMoneySummary) GetMtmProfit() float64 {
	if m != nil {
		return m.MtmProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetPreMtmProfit() float64 {
	if m != nil {
		return m.PreMtmProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetStockValue() float64 {
	if m != nil {
		return m.StockValue
	}
	return 0
}

func (m *AccountMoneySummary) GetBondRepurchaseAmount() float64 {
	if m != nil {
		return m.BondRepurchaseAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetReverseRepurchaseAmount() float64 {
	if m != nil {
		return m.ReverseRepurchaseAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetMarginTradeAmount() float64 {
	if m != nil {
		return m.MarginTradeAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetShortSellAmount() float64 {
	if m != nil {
		return m.ShortSellAmount
	}
	return 0
}

func (m *AccountMoneySummary) GetMarginTradeProfit() float64 {
	if m != nil {
		return m.MarginTradeProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetShortSellProfit() float64 {
	if m != nil {
		return m.ShortSellProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenCloseCommission() float64 {
	if m != nil {
		return m.FrozenCloseCommission
	}
	return 0
}

func (m *AccountMoneySummary) GetCommonBalance() float64 {
	if m != nil {
		return m.CommonBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetPreferedBalance() float64 {
	if m != nil {
		return m.PreferedBalance
	}
	return 0
}

func (m *AccountMoneySummary) GetBaseExchangeRate() float64 {
	if m != nil {
		return m.BaseExchangeRate
	}
	return 0
}

func (m *AccountMoneySummary) GetWarningLevel() float64 {
	if m != nil {
		return m.WarningLevel
	}
	return 0
}

func (m *AccountMoneySummary) GetForceCloseLevel() float64 {
	if m != nil {
		return m.ForceCloseLevel
	}
	return 0
}

func (m *AccountMoneySummary) GetClearedClosedProfit() float64 {
	if m != nil {
		return m.ClearedClosedProfit
	}
	return 0
}

func (m *AccountMoneySummary) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AccountMoneySummary) GetInterest() float64 {
	if m != nil {
		return m.Interest
	}
	return 0
}

func (m *AccountMoneySummary) GetFrozenInterest() float64 {
	if m != nil {
		return m.FrozenInterest
	}
	return 0
}

type AccountMoneySummaryList struct {
	List []AccountMoneySummary `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *AccountMoneySummaryList) Reset()                    { *m = AccountMoneySummaryList{} }
func (m *AccountMoneySummaryList) String() string            { return proto.CompactTextString(m) }
func (*AccountMoneySummaryList) ProtoMessage()               {}
func (*AccountMoneySummaryList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{18} }

func (m *AccountMoneySummaryList) GetList() []AccountMoneySummary {
	if m != nil {
		return m.List
	}
	return nil
}

// 出入金操作
type MoneyTransferRecord struct {
	// ID
	Uid int64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid"`
	// 出入
	Direction int32 `protobuf:"varint,2,opt,name=direction,proto3" json:"direction"`
	// 币种
	CurrencyType int32 `protobuf:"varint,3,opt,name=currency_type,json=currencyType,proto3" json:"currencyType"`
	// 结算组
	SettlementGroup int32 `protobuf:"varint,4,opt,name=settlement_group,json=settlementGroup,proto3" json:"settlementGroup"`
	// 是否确认
	Confirmed int32 `protobuf:"varint,5,opt,name=confirmed,proto3" json:"confirmed"`
	// 优先
	IsPrefered int32 `protobuf:"varint,6,opt,name=is_prefered,json=isPrefered,proto3" json:"isPrefered"`
	// 金额
	Amount float64 `protobuf:"fixed64,7,opt,name=amount,proto3" json:"amount"`
	// 账户
	AccountId string `protobuf:"bytes,8,opt,name=account_id,json=accountId,proto3" json:"accountId"`
	// 操作员
	OperatorId string `protobuf:"bytes,9,opt,name=operator_id,json=operatorId,proto3" json:"operatorId"`
	// 会话编号
	SessionId int32 `protobuf:"varint,10,opt,name=session_id,json=sessionId,proto3" json:"sessionId"`
	// 请求时间
	Time int64 `protobuf:"varint,11,opt,name=time,proto3" json:"time"`
	// 备注
	Comment string `protobuf:"bytes,12,opt,name=comment,proto3" json:"comment"`
	// 第三方单号
	BankTradeId string `protobuf:"bytes,13,opt,name=bank_trade_id,json=bankTradeId,proto3" json:"bankTradeId"`
	// 配置编号，用于出金
	PaymentConfigId int64 `protobuf:"varint,14,opt,name=payment_config_id,json=paymentConfigId,proto3" json:"paymentConfigId"`
	// 原始金额
	OriginalAmount float64 `protobuf:"fixed64,15,opt,name=original_amount,json=originalAmount,proto3" json:"originalAmount"`
	// 费用
	Fee float64 `protobuf:"fixed64,16,opt,name=fee,proto3" json:"fee"`
	// 通道
	PaymentPath string `protobuf:"bytes,17,opt,name=payment_path,json=paymentPath,proto3" json:"paymentPath"`
	// 身份证号
	IdentityNumber string `protobuf:"bytes,18,opt,name=identity_number,json=identityNumber,proto3" json:"identityNumber"`
	// 电话
	PhoneNumber string `protobuf:"bytes,19,opt,name=phone_number,json=phoneNumber,proto3" json:"phoneNumber"`
	// 银行名称
	BankName string `protobuf:"bytes,20,opt,name=bank_name,json=bankName,proto3" json:"bankName"`
	// 支行名称
	BankBranchName string `protobuf:"bytes,21,opt,name=bank_branch_name,json=bankBranchName,proto3" json:"bankBranchName"`
	// 银行卡号
	BankCardNo string `protobuf:"bytes,22,opt,name=bank_card_no,json=bankCardNo,proto3" json:"bankCardNo"`
	// 省份
	Province string `protobuf:"bytes,23,opt,name=province,proto3" json:"province"`
	// 城市
	City string `protobuf:"bytes,24,opt,name=city,proto3" json:"city"`
	// 支付方式代码
	PayType string `protobuf:"bytes,25,opt,name=pay_type,json=payType,proto3" json:"payType"`
	// 支付时间
	PayedTime int64 `protobuf:"varint,26,opt,name=payed_time,json=payedTime,proto3" json:"payedTime"`
	// 确认时间
	ConfirmedTime int64 `protobuf:"varint,27,opt,name=confirmed_time,json=confirmedTime,proto3" json:"confirmedTime"`
	// 名称
	Name string `protobuf:"bytes,28,opt,name=name,proto3" json:"name"`
}

func (m *MoneyTransferRecord) Reset()                    { *m = MoneyTransferRecord{} }
func (m *MoneyTransferRecord) String() string            { return proto.CompactTextString(m) }
func (*MoneyTransferRecord) ProtoMessage()               {}
func (*MoneyTransferRecord) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{19} }

func (m *MoneyTransferRecord) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *MoneyTransferRecord) GetDirection() int32 {
	if m != nil {
		return m.Direction
	}
	return 0
}

func (m *MoneyTransferRecord) GetCurrencyType() int32 {
	if m != nil {
		return m.CurrencyType
	}
	return 0
}

func (m *MoneyTransferRecord) GetSettlementGroup() int32 {
	if m != nil {
		return m.SettlementGroup
	}
	return 0
}

func (m *MoneyTransferRecord) GetConfirmed() int32 {
	if m != nil {
		return m.Confirmed
	}
	return 0
}

func (m *MoneyTransferRecord) GetIsPrefered() int32 {
	if m != nil {
		return m.IsPrefered
	}
	return 0
}

func (m *MoneyTransferRecord) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MoneyTransferRecord) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *MoneyTransferRecord) GetOperatorId() string {
	if m != nil {
		return m.OperatorId
	}
	return ""
}

func (m *MoneyTransferRecord) GetSessionId() int32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MoneyTransferRecord) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MoneyTransferRecord) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankTradeId() string {
	if m != nil {
		return m.BankTradeId
	}
	return ""
}

func (m *MoneyTransferRecord) GetPaymentConfigId() int64 {
	if m != nil {
		return m.PaymentConfigId
	}
	return 0
}

func (m *MoneyTransferRecord) GetOriginalAmount() float64 {
	if m != nil {
		return m.OriginalAmount
	}
	return 0
}

func (m *MoneyTransferRecord) GetFee() float64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *MoneyTransferRecord) GetPaymentPath() string {
	if m != nil {
		return m.PaymentPath
	}
	return ""
}

func (m *MoneyTransferRecord) GetIdentityNumber() string {
	if m != nil {
		return m.IdentityNumber
	}
	return ""
}

func (m *MoneyTransferRecord) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankName() string {
	if m != nil {
		return m.BankName
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankBranchName() string {
	if m != nil {
		return m.BankBranchName
	}
	return ""
}

func (m *MoneyTransferRecord) GetBankCardNo() string {
	if m != nil {
		return m.BankCardNo
	}
	return ""
}

func (m *MoneyTransferRecord) GetProvince() string {
	if m != nil {
		return m.Province
	}
	return ""
}

func (m *MoneyTransferRecord) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *MoneyTransferRecord) GetPayType() string {
	if m != nil {
		return m.PayType
	}
	return ""
}

func (m *MoneyTransferRecord) GetPayedTime() int64 {
	if m != nil {
		return m.PayedTime
	}
	return 0
}

func (m *MoneyTransferRecord) GetConfirmedTime() int64 {
	if m != nil {
		return m.ConfirmedTime
	}
	return 0
}

func (m *MoneyTransferRecord) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MTRList struct {
	List []MoneyTransferRecord `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *MTRList) Reset()                    { *m = MTRList{} }
func (m *MTRList) String() string            { return proto.CompactTextString(m) }
func (*MTRList) ProtoMessage()               {}
func (*MTRList) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{20} }

func (m *MTRList) GetList() []MoneyTransferRecord {
	if m != nil {
		return m.List
	}
	return nil
}

type UserSession struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
}

func (m *UserSession) Reset()                    { *m = UserSession{} }
func (m *UserSession) String() string            { return proto.CompactTextString(m) }
func (*UserSession) ProtoMessage()               {}
func (*UserSession) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{21} }

func (m *UserSession) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// SSEStockOption 上证交易所ETF期权
type SSEStockOption struct {
	// 行权价
	ExercisePrice       string `protobuf:"bytes,1,opt,name=exercise_price,json=exercisePrice,proto3" json:"exercisePrice"`
	UpdateVersion       string `protobuf:"bytes,2,opt,name=update_version,json=updateVersion,proto3" json:"updateVersion"`
	OptionType          string `protobuf:"bytes,3,opt,name=option_type,json=optionType,proto3" json:"optionType"`
	DailyPriceUpLimit   string `protobuf:"bytes,4,opt,name=daily_price_up_limit,json=dailyPriceUpLimit,proto3" json:"dailyPriceUpLimit"`
	TimeSave            string `protobuf:"bytes,5,opt,name=time_save,json=timeSave,proto3" json:"timeSave"`
	DELIST_Flag         string `protobuf:"bytes,6,opt,name=DELIST_Flag,json=DELISTFlag,proto3" json:"DELISTFlag"`
	StartDate           string `protobuf:"bytes,7,opt,name=start_date,json=startDate,proto3" json:"startDate"`
	ExpireDate          string `protobuf:"bytes,8,opt,name=expire_date,json=expireDate,proto3" json:"expireDate"`
	ContractUnit        string `protobuf:"bytes,9,opt,name=contract_unit,json=contractUnit,proto3" json:"contractUnit"`
	CallOrPut           string `protobuf:"bytes,10,opt,name=call_or_put,json=callOrPut,proto3" json:"callOrPut"`
	LmtOrdMaxFloor      string `protobuf:"bytes,11,opt,name=lmt_ord_max_floor,json=lmtOrdMaxFloor,proto3" json:"lmtOrdMaxFloor"`
	DeliveryDate        string `protobuf:"bytes,12,opt,name=delivery_date,json=deliveryDate,proto3" json:"deliveryDate"`
	ChangeFlag          string `protobuf:"bytes,13,opt,name=change_flag,json=changeFlag,proto3" json:"changeFlag"`
	MktOrdMaxFloor      string `protobuf:"bytes,14,opt,name=mkt_ord_max_floor,json=mktOrdMaxFloor,proto3" json:"mktOrdMaxFloor"`
	UnderlyingType      string `protobuf:"bytes,15,opt,name=underlying_type,json=underlyingType,proto3" json:"underlyingType"`
	DailyPriceDownLimit string `protobuf:"bytes,16,opt,name=daily_price_down_limit,json=dailyPriceDownLimit,proto3" json:"dailyPriceDownLimit"`
	RoundLot            string `protobuf:"bytes,17,opt,name=round_lot,json=roundLot,proto3" json:"roundLot"`
	SecurityClosePX     string `protobuf:"bytes,18,opt,name=security_closePX,json=securityClosePX,proto3" json:"securityClosePX"`
	SettlPrice          string `protobuf:"bytes,19,opt,name=settl_price,json=settlPrice,proto3" json:"settlPrice"`
	ContractSymbol      string `protobuf:"bytes,20,opt,name=contract_symbol,json=contractSymbol,proto3" json:"contractSymbol"`
	Num                 string `protobuf:"bytes,21,opt,name=num,proto3" json:"num"`
	ContractID          string `protobuf:"bytes,22,opt,name=contractID,proto3" json:"contractID"`
	MarginRatioParam1   string `protobuf:"bytes,23,opt,name=margin_ratio_param1,json=marginRatioParam1,proto3" json:"marginRatioParam1"`
	MarginRatioParam2   string `protobuf:"bytes,24,opt,name=margin_ratio_param2,json=marginRatioParam2,proto3" json:"marginRatioParam2"`
	LmtOrdMinFloor      string `protobuf:"bytes,25,opt,name=lmt_ord_min_floor,json=lmtOrdMinFloor,proto3" json:"lmtOrdMinFloor"`
	MktOrdMinFloor      string `protobuf:"bytes,26,opt,name=mkt_ord_min_floor,json=mktOrdMinFloor,proto3" json:"mktOrdMinFloor"`
	EndDate             string `protobuf:"bytes,27,opt,name=end_date,json=endDate,proto3" json:"endDate"`
	PriceLimitType      string `protobuf:"bytes,28,opt,name=price_limit_type,json=priceLimitType,proto3" json:"priceLimitType"`
	ExerciseDate        string `protobuf:"bytes,29,opt,name=exercise_date,json=exerciseDate,proto3" json:"exerciseDate"`
	MarginUnit          string `protobuf:"bytes,30,opt,name=margin_unit,json=marginUnit,proto3" json:"marginUnit"`
	SecurityID          string `protobuf:"bytes,31,opt,name=securityID,proto3" json:"securityID"`
	SecurityNameByID    string `protobuf:"bytes,32,opt,name=security_name_byID,json=securityNameByID,proto3" json:"securityNameByID"`
	ContractFlag        string `protobuf:"bytes,33,opt,name=contract_flag,json=contractFlag,proto3" json:"contractFlag"`
	UnderlyingClosePX   string `protobuf:"bytes,34,opt,name=underlying_closePX,json=underlyingClosePX,proto3" json:"underlyingClosePX"`
}

func (m *SSEStockOption) Reset()                    { *m = SSEStockOption{} }
func (m *SSEStockOption) String() string            { return proto.CompactTextString(m) }
func (*SSEStockOption) ProtoMessage()               {}
func (*SSEStockOption) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{22} }

func (m *SSEStockOption) GetExercisePrice() string {
	if m != nil {
		return m.ExercisePrice
	}
	return ""
}

func (m *SSEStockOption) GetUpdateVersion() string {
	if m != nil {
		return m.UpdateVersion
	}
	return ""
}

func (m *SSEStockOption) GetOptionType() string {
	if m != nil {
		return m.OptionType
	}
	return ""
}

func (m *SSEStockOption) GetDailyPriceUpLimit() string {
	if m != nil {
		return m.DailyPriceUpLimit
	}
	return ""
}

func (m *SSEStockOption) GetTimeSave() string {
	if m != nil {
		return m.TimeSave
	}
	return ""
}

func (m *SSEStockOption) GetDELIST_Flag() string {
	if m != nil {
		return m.DELIST_Flag
	}
	return ""
}

func (m *SSEStockOption) GetStartDate() string {
	if m != nil {
		return m.StartDate
	}
	return ""
}

func (m *SSEStockOption) GetExpireDate() string {
	if m != nil {
		return m.ExpireDate
	}
	return ""
}

func (m *SSEStockOption) GetContractUnit() string {
	if m != nil {
		return m.ContractUnit
	}
	return ""
}

func (m *SSEStockOption) GetCallOrPut() string {
	if m != nil {
		return m.CallOrPut
	}
	return ""
}

func (m *SSEStockOption) GetLmtOrdMaxFloor() string {
	if m != nil {
		return m.LmtOrdMaxFloor
	}
	return ""
}

func (m *SSEStockOption) GetDeliveryDate() string {
	if m != nil {
		return m.DeliveryDate
	}
	return ""
}

func (m *SSEStockOption) GetChangeFlag() string {
	if m != nil {
		return m.ChangeFlag
	}
	return ""
}

func (m *SSEStockOption) GetMktOrdMaxFloor() string {
	if m != nil {
		return m.MktOrdMaxFloor
	}
	return ""
}

func (m *SSEStockOption) GetUnderlyingType() string {
	if m != nil {
		return m.UnderlyingType
	}
	return ""
}

func (m *SSEStockOption) GetDailyPriceDownLimit() string {
	if m != nil {
		return m.DailyPriceDownLimit
	}
	return ""
}

func (m *SSEStockOption) GetRoundLot() string {
	if m != nil {
		return m.RoundLot
	}
	return ""
}

func (m *SSEStockOption) GetSecurityClosePX() string {
	if m != nil {
		return m.SecurityClosePX
	}
	return ""
}

func (m *SSEStockOption) GetSettlPrice() string {
	if m != nil {
		return m.SettlPrice
	}
	return ""
}

func (m *SSEStockOption) GetContractSymbol() string {
	if m != nil {
		return m.ContractSymbol
	}
	return ""
}

func (m *SSEStockOption) GetNum() string {
	if m != nil {
		return m.Num
	}
	return ""
}

func (m *SSEStockOption) GetContractID() string {
	if m != nil {
		return m.ContractID
	}
	return ""
}

func (m *SSEStockOption) GetMarginRatioParam1() string {
	if m != nil {
		return m.MarginRatioParam1
	}
	return ""
}

func (m *SSEStockOption) GetMarginRatioParam2() string {
	if m != nil {
		return m.MarginRatioParam2
	}
	return ""
}

func (m *SSEStockOption) GetLmtOrdMinFloor() string {
	if m != nil {
		return m.LmtOrdMinFloor
	}
	return ""
}

func (m *SSEStockOption) GetMktOrdMinFloor() string {
	if m != nil {
		return m.MktOrdMinFloor
	}
	return ""
}

func (m *SSEStockOption) GetEndDate() string {
	if m != nil {
		return m.EndDate
	}
	return ""
}

func (m *SSEStockOption) GetPriceLimitType() string {
	if m != nil {
		return m.PriceLimitType
	}
	return ""
}

func (m *SSEStockOption) GetExerciseDate() string {
	if m != nil {
		return m.ExerciseDate
	}
	return ""
}

func (m *SSEStockOption) GetMarginUnit() string {
	if m != nil {
		return m.MarginUnit
	}
	return ""
}

func (m *SSEStockOption) GetSecurityID() string {
	if m != nil {
		return m.SecurityID
	}
	return ""
}

func (m *SSEStockOption) GetSecurityNameByID() string {
	if m != nil {
		return m.SecurityNameByID
	}
	return ""
}

func (m *SSEStockOption) GetContractFlag() string {
	if m != nil {
		return m.ContractFlag
	}
	return ""
}

func (m *SSEStockOption) GetUnderlyingClosePX() string {
	if m != nil {
		return m.UnderlyingClosePX
	}
	return ""
}

func init() {
	proto.RegisterType((*Symbol)(nil), "pb.Symbol")
	proto.RegisterType((*ProductID)(nil), "pb.ProductID")
	proto.RegisterType((*Kline)(nil), "pb.Kline")
	proto.RegisterType((*KlineSeries)(nil), "pb.KlineSeries")
	proto.RegisterType((*BrokerRoute)(nil), "pb.BrokerRoute")
	proto.RegisterType((*BrokerRouteList)(nil), "pb.BrokerRouteList")
	proto.RegisterType((*InstrumentInfo)(nil), "pb.InstrumentInfo")
	proto.RegisterType((*SimpleTimePeriod)(nil), "pb.SimpleTimePeriod")
	proto.RegisterType((*MarketTimeRule)(nil), "pb.MarketTimeRule")
	proto.RegisterType((*ProductInfo)(nil), "pb.ProductInfo")
	proto.RegisterType((*TradingInstrument)(nil), "pb.TradingInstrument")
	proto.RegisterType((*TradingInstrumentList)(nil), "pb.TradingInstrumentList")
	proto.RegisterType((*ProductInfoList)(nil), "pb.ProductInfoList")
	proto.RegisterType((*ReqSetTradingInstrumentList)(nil), "pb.ReqSetTradingInstrumentList")
	proto.RegisterType((*ReqSetProductInfoList)(nil), "pb.ReqSetProductInfoList")
	proto.RegisterType((*ReqUpdateTIOpenDate)(nil), "pb.ReqUpdateTIOpenDate")
	proto.RegisterType((*ReqUpdateTIOpenDateList)(nil), "pb.ReqUpdateTIOpenDateList")
	proto.RegisterType((*AccountMoneySummary)(nil), "pb.AccountMoneySummary")
	proto.RegisterType((*AccountMoneySummaryList)(nil), "pb.AccountMoneySummaryList")
	proto.RegisterType((*MoneyTransferRecord)(nil), "pb.MoneyTransferRecord")
	proto.RegisterType((*MTRList)(nil), "pb.MTRList")
	proto.RegisterType((*UserSession)(nil), "pb.UserSession")
	proto.RegisterType((*SSEStockOption)(nil), "pb.SSEStockOption")
	proto.RegisterEnum("pb.ExchangeType", ExchangeType_name, ExchangeType_value)
	proto.RegisterEnum("pb.ProductType", ProductType_name, ProductType_value)
	proto.RegisterEnum("pb.PeriodType", PeriodType_name, PeriodType_value)
	proto.RegisterEnum("pb.OptionCallPutType", OptionCallPutType_name, OptionCallPutType_value)
	proto.RegisterEnum("pb.OptionDeliveryDateType", OptionDeliveryDateType_name, OptionDeliveryDateType_value)
	proto.RegisterEnum("pb.CloseCommissionAlgorithim", CloseCommissionAlgorithim_name, CloseCommissionAlgorithim_value)
	proto.RegisterEnum("pb.AccountType", AccountType_name, AccountType_value)
	proto.RegisterEnum("pb.CurrencyType", CurrencyType_name, CurrencyType_value)
}
func (m *Symbol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Symbol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *ProductID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *Kline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Time))
	}
	if m.Open != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Open))))
	}
	if m.High != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.High))))
	}
	if m.Low != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Low))))
	}
	if m.Close != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Close))))
	}
	if m.Volume != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Volume))))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Amount))))
	}
	if m.Position != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Position))))
	}
	return i, nil
}

func (m *KlineSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KlineSeries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.Symbol.Size()))
	n1, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Period != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Period))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BrokerRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.MdFrontList) > 0 {
		for _, s := range m.MdFrontList {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TradeFrontList) > 0 {
		for _, s := range m.TradeFrontList {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BrokerRouteList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerRouteList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InstrumentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstrumentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SymbolName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SymbolName)))
		i += copy(dAtA[i:], m.SymbolName)
	}
	if m.PositionRank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PositionRank))
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UpdateTime))
	}
	if m.UpdateTradingDay != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UpdateTradingDay))
	}
	if m.UpperLimitPrice != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.UpperLimitPrice))))
	}
	if m.LowerLimitPrice != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.LowerLimitPrice))))
	}
	if m.PreClosePrice != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreClosePrice))))
	}
	if m.PreSettlementPrice != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreSettlementPrice))))
	}
	if m.PreVolume != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PrePosition))
	}
	if m.SettlementPrice != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.SettlementPrice))))
	}
	if m.CreateDate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateDate))
	}
	if m.OpenDate != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.OpenDate))
	}
	if m.ExpireDate != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ExpireDate))
	}
	if m.StartDeliverDate != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.StartDeliverDate))
	}
	if m.EndDeliverDate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.EndDeliverDate))
	}
	if m.IsCloseTodayAllowed != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.IsCloseTodayAllowed))
	}
	if m.MaxMarketOrderVolume != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxMarketOrderVolume))
	}
	if m.MinMarketOrderVolume != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MinMarketOrderVolume))
	}
	if m.MaxLimitOrderVolume != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MaxLimitOrderVolume))
	}
	if m.MinLimitOrderVolume != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MinLimitOrderVolume))
	}
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.BaseSymbol.Size()))
	n2, err := m.BaseSymbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.StrikePrice != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.StrikePrice))))
	}
	if m.CallPutType != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CallPutType))
	}
	if m.UnderlyingMultiple != 0 {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.UnderlyingMultiple))))
	}
	if m.CombinationType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CombinationType))
	}
	if m.MinBuyVolume != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MinBuyVolume))
	}
	if m.MinSellVolume != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.MinSellVolume))
	}
	dAtA[i] = 0xea
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.InstrumentCode.Size()))
	n3, err := m.InstrumentCode.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.IsTrading {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsTrading {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeliveryDateType != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.DeliveryDateType))
	}
	return i, nil
}

func (m *SimpleTimePeriod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleTimePeriod) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *MarketTimeRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketTimeRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SendRule) > 0 {
		for _, msg := range m.SendRule {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CancelRule) > 0 {
		for _, msg := range m.CancelRule {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MatchingRule) > 0 {
		for _, msg := range m.MatchingRule {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProductInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.ProductId.Size()))
	n4, err := m.ProductId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.ProductGroupId.Size()))
	n5, err := m.ProductGroupId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if m.PriceTick != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PriceTick))))
	}
	if m.VolumeMultiple != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.VolumeMultiple))
	}
	if m.PreVolume != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PrePosition))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SettlementGroup))
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.TimeRule.Size()))
	n6, err := m.TimeRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.DistinguishPositionTime {
		dAtA[i] = 0x60
		i++
		if m.DistinguishPositionTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TradingInstrument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingInstrument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.Symbol.Size()))
	n7, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x12
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.InstrumentInfo.Size()))
	n8, err := m.InstrumentInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.ProductInfo.Size()))
	n9, err := m.ProductInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *TradingInstrumentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradingInstrumentList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProductInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductInfoList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqSetTradingInstrumentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetTradingInstrumentList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OpCode)))
		i += copy(dAtA[i:], m.OpCode)
	}
	if m.Exchange != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqSetProductInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetProductInfoList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OpCode)))
		i += copy(dAtA[i:], m.OpCode)
	}
	if m.Exchange != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqUpdateTIOpenDate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateTIOpenDate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCommon(dAtA, i, uint64(m.Symbol.Size()))
	n10, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.OpenDate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.OpenDate))
	}
	return i, nil
}

func (m *ReqUpdateTIOpenDateList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateTIOpenDateList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OpCode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OpCode)))
		i += copy(dAtA[i:], m.OpCode)
	}
	return i, nil
}

func (m *AccountMoneySummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMoneySummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CurrencyType))
	}
	if m.Balance != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Balance))))
	}
	if m.Commission != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Commission))))
	}
	if m.CurMargin != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.CurMargin))))
	}
	if m.NetPositionAmount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.NetPositionAmount))))
	}
	if m.PreBalance != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreBalance))))
	}
	if m.InterestIn != 0 {
		dAtA[i] = 0x49
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.InterestIn))))
	}
	if m.Deposit != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Deposit))))
	}
	if m.Withdraw != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Withdraw))))
	}
	if m.FrozenMargin != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenMargin))))
	}
	if m.FrozenCommission != 0 {
		dAtA[i] = 0x69
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenCommission))))
	}
	if m.Available != 0 {
		dAtA[i] = 0x71
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Available))))
	}
	if m.CloseProfit != 0 {
		dAtA[i] = 0x79
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.CloseProfit))))
	}
	if m.PositionProfit != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PositionProfit))))
	}
	if m.PreMortgate != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreMortgate))))
	}
	if m.PreCredit != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreCredit))))
	}
	if m.InterestBase != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.InterestBase))))
	}
	if m.WithdrawAvailable != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.WithdrawAvailable))))
	}
	if m.Reserve != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Reserve))))
	}
	if m.TradingDay != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.TradingDay))
	}
	if m.Credit != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Credit))))
	}
	if m.Mortgate != 0 {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Mortgate))))
	}
	if m.ExchangeMargin != 0 {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ExchangeMargin))))
	}
	if m.DeliveryMargin != 0 {
		dAtA[i] = 0xd1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.DeliveryMargin))))
	}
	if m.ExchangeDeliveryMargin != 0 {
		dAtA[i] = 0xd9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ExchangeDeliveryMargin))))
	}
	if m.ReserveBalance != 0 {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ReserveBalance))))
	}
	if m.DeliveryCommission != 0 {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.DeliveryCommission))))
	}
	if m.FrozenTransferFee != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenTransferFee))))
	}
	if m.FrozenStampTax != 0 {
		dAtA[i] = 0xf9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenStampTax))))
	}
	if m.TransferFee != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.TransferFee))))
	}
	if m.StampTax != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.StampTax))))
	}
	if m.MtmProfit != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.MtmProfit))))
	}
	if m.PreMtmProfit != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreMtmProfit))))
	}
	if m.StockValue != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.StockValue))))
	}
	if m.BondRepurchaseAmount != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.BondRepurchaseAmount))))
	}
	if m.ReverseRepurchaseAmount != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ReverseRepurchaseAmount))))
	}
	if m.MarginTradeAmount != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.MarginTradeAmount))))
	}
	if m.ShortSellAmount != 0 {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ShortSellAmount))))
	}
	if m.MarginTradeProfit != 0 {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.MarginTradeProfit))))
	}
	if m.ShortSellProfit != 0 {
		dAtA[i] = 0xd1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ShortSellProfit))))
	}
	if m.FrozenCloseCommission != 0 {
		dAtA[i] = 0xd9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenCloseCommission))))
	}
	if m.CommonBalance != 0 {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.CommonBalance))))
	}
	if m.PreferedBalance != 0 {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.PreferedBalance))))
	}
	if m.BaseExchangeRate != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.BaseExchangeRate))))
	}
	if m.WarningLevel != 0 {
		dAtA[i] = 0xf9
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.WarningLevel))))
	}
	if m.ForceCloseLevel != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ForceCloseLevel))))
	}
	if m.ClearedClosedProfit != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.ClearedClosedProfit))))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Interest != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Interest))))
	}
	if m.FrozenInterest != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x3
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.FrozenInterest))))
	}
	return i, nil
}

func (m *AccountMoneySummaryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMoneySummaryList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MoneyTransferRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoneyTransferRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Uid))
	}
	if m.Direction != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Direction))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SettlementGroup))
	}
	if m.Confirmed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Confirmed))
	}
	if m.IsPrefered != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.IsPrefered))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Amount))))
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if len(m.OperatorId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OperatorId)))
		i += copy(dAtA[i:], m.OperatorId)
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.SessionId))
	}
	if m.Time != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Time))
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.BankTradeId) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankTradeId)))
		i += copy(dAtA[i:], m.BankTradeId)
	}
	if m.PaymentConfigId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PaymentConfigId))
	}
	if m.OriginalAmount != 0 {
		dAtA[i] = 0x79
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.OriginalAmount))))
	}
	if m.Fee != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Common(dAtA, i, uint64(math.Float64bits(float64(m.Fee))))
	}
	if len(m.PaymentPath) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PaymentPath)))
		i += copy(dAtA[i:], m.PaymentPath)
	}
	if len(m.IdentityNumber) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.IdentityNumber)))
		i += copy(dAtA[i:], m.IdentityNumber)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.BankName) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankName)))
		i += copy(dAtA[i:], m.BankName)
	}
	if len(m.BankBranchName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankBranchName)))
		i += copy(dAtA[i:], m.BankBranchName)
	}
	if len(m.BankCardNo) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BankCardNo)))
		i += copy(dAtA[i:], m.BankCardNo)
	}
	if len(m.Province) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Province)))
		i += copy(dAtA[i:], m.Province)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.PayType) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PayType)))
		i += copy(dAtA[i:], m.PayType)
	}
	if m.PayedTime != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PayedTime))
	}
	if m.ConfirmedTime != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ConfirmedTime))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *MTRList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MTRList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *SSEStockOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSEStockOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExercisePrice) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ExercisePrice)))
		i += copy(dAtA[i:], m.ExercisePrice)
	}
	if len(m.UpdateVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.UpdateVersion)))
		i += copy(dAtA[i:], m.UpdateVersion)
	}
	if len(m.OptionType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.OptionType)))
		i += copy(dAtA[i:], m.OptionType)
	}
	if len(m.DailyPriceUpLimit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DailyPriceUpLimit)))
		i += copy(dAtA[i:], m.DailyPriceUpLimit)
	}
	if len(m.TimeSave) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.TimeSave)))
		i += copy(dAtA[i:], m.TimeSave)
	}
	if len(m.DELIST_Flag) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DELIST_Flag)))
		i += copy(dAtA[i:], m.DELIST_Flag)
	}
	if len(m.StartDate) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.StartDate)))
		i += copy(dAtA[i:], m.StartDate)
	}
	if len(m.ExpireDate) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ExpireDate)))
		i += copy(dAtA[i:], m.ExpireDate)
	}
	if len(m.ContractUnit) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ContractUnit)))
		i += copy(dAtA[i:], m.ContractUnit)
	}
	if len(m.CallOrPut) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.CallOrPut)))
		i += copy(dAtA[i:], m.CallOrPut)
	}
	if len(m.LmtOrdMaxFloor) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.LmtOrdMaxFloor)))
		i += copy(dAtA[i:], m.LmtOrdMaxFloor)
	}
	if len(m.DeliveryDate) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DeliveryDate)))
		i += copy(dAtA[i:], m.DeliveryDate)
	}
	if len(m.ChangeFlag) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ChangeFlag)))
		i += copy(dAtA[i:], m.ChangeFlag)
	}
	if len(m.MktOrdMaxFloor) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.MktOrdMaxFloor)))
		i += copy(dAtA[i:], m.MktOrdMaxFloor)
	}
	if len(m.UnderlyingType) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.UnderlyingType)))
		i += copy(dAtA[i:], m.UnderlyingType)
	}
	if len(m.DailyPriceDownLimit) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DailyPriceDownLimit)))
		i += copy(dAtA[i:], m.DailyPriceDownLimit)
	}
	if len(m.RoundLot) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.RoundLot)))
		i += copy(dAtA[i:], m.RoundLot)
	}
	if len(m.SecurityClosePX) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SecurityClosePX)))
		i += copy(dAtA[i:], m.SecurityClosePX)
	}
	if len(m.SettlPrice) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SettlPrice)))
		i += copy(dAtA[i:], m.SettlPrice)
	}
	if len(m.ContractSymbol) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ContractSymbol)))
		i += copy(dAtA[i:], m.ContractSymbol)
	}
	if len(m.Num) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Num)))
		i += copy(dAtA[i:], m.Num)
	}
	if len(m.ContractID) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ContractID)))
		i += copy(dAtA[i:], m.ContractID)
	}
	if len(m.MarginRatioParam1) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.MarginRatioParam1)))
		i += copy(dAtA[i:], m.MarginRatioParam1)
	}
	if len(m.MarginRatioParam2) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.MarginRatioParam2)))
		i += copy(dAtA[i:], m.MarginRatioParam2)
	}
	if len(m.LmtOrdMinFloor) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.LmtOrdMinFloor)))
		i += copy(dAtA[i:], m.LmtOrdMinFloor)
	}
	if len(m.MktOrdMinFloor) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.MktOrdMinFloor)))
		i += copy(dAtA[i:], m.MktOrdMinFloor)
	}
	if len(m.EndDate) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.EndDate)))
		i += copy(dAtA[i:], m.EndDate)
	}
	if len(m.PriceLimitType) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.PriceLimitType)))
		i += copy(dAtA[i:], m.PriceLimitType)
	}
	if len(m.ExerciseDate) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ExerciseDate)))
		i += copy(dAtA[i:], m.ExerciseDate)
	}
	if len(m.MarginUnit) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.MarginUnit)))
		i += copy(dAtA[i:], m.MarginUnit)
	}
	if len(m.SecurityID) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SecurityID)))
		i += copy(dAtA[i:], m.SecurityID)
	}
	if len(m.SecurityNameByID) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.SecurityNameByID)))
		i += copy(dAtA[i:], m.SecurityNameByID)
	}
	if len(m.ContractFlag) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ContractFlag)))
		i += copy(dAtA[i:], m.ContractFlag)
	}
	if len(m.UnderlyingClosePX) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.UnderlyingClosePX)))
		i += copy(dAtA[i:], m.UnderlyingClosePX)
	}
	return i, nil
}

func encodeFixed64Common(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Common(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Symbol) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *ProductID) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *Kline) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovCommon(uint64(m.Time))
	}
	if m.Open != 0 {
		n += 9
	}
	if m.High != 0 {
		n += 9
	}
	if m.Low != 0 {
		n += 9
	}
	if m.Close != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.Position != 0 {
		n += 9
	}
	return n
}

func (m *KlineSeries) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCommon(uint64(l))
	if m.Period != 0 {
		n += 1 + sovCommon(uint64(m.Period))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *BrokerRoute) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.MdFrontList) > 0 {
		for _, s := range m.MdFrontList {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.TradeFrontList) > 0 {
		for _, s := range m.TradeFrontList {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *BrokerRouteList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *InstrumentInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.SymbolName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PositionRank != 0 {
		n += 1 + sovCommon(uint64(m.PositionRank))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovCommon(uint64(m.UpdateTime))
	}
	if m.UpdateTradingDay != 0 {
		n += 1 + sovCommon(uint64(m.UpdateTradingDay))
	}
	if m.UpperLimitPrice != 0 {
		n += 9
	}
	if m.LowerLimitPrice != 0 {
		n += 9
	}
	if m.PreClosePrice != 0 {
		n += 9
	}
	if m.PreSettlementPrice != 0 {
		n += 9
	}
	if m.PreVolume != 0 {
		n += 1 + sovCommon(uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		n += 1 + sovCommon(uint64(m.PrePosition))
	}
	if m.SettlementPrice != 0 {
		n += 9
	}
	if m.CreateDate != 0 {
		n += 1 + sovCommon(uint64(m.CreateDate))
	}
	if m.OpenDate != 0 {
		n += 1 + sovCommon(uint64(m.OpenDate))
	}
	if m.ExpireDate != 0 {
		n += 1 + sovCommon(uint64(m.ExpireDate))
	}
	if m.StartDeliverDate != 0 {
		n += 1 + sovCommon(uint64(m.StartDeliverDate))
	}
	if m.EndDeliverDate != 0 {
		n += 2 + sovCommon(uint64(m.EndDeliverDate))
	}
	if m.IsCloseTodayAllowed != 0 {
		n += 2 + sovCommon(uint64(m.IsCloseTodayAllowed))
	}
	if m.MaxMarketOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MaxMarketOrderVolume))
	}
	if m.MinMarketOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MinMarketOrderVolume))
	}
	if m.MaxLimitOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MaxLimitOrderVolume))
	}
	if m.MinLimitOrderVolume != 0 {
		n += 2 + sovCommon(uint64(m.MinLimitOrderVolume))
	}
	l = m.BaseSymbol.Size()
	n += 2 + l + sovCommon(uint64(l))
	if m.StrikePrice != 0 {
		n += 10
	}
	if m.CallPutType != 0 {
		n += 2 + sovCommon(uint64(m.CallPutType))
	}
	if m.UnderlyingMultiple != 0 {
		n += 10
	}
	if m.CombinationType != 0 {
		n += 2 + sovCommon(uint64(m.CombinationType))
	}
	if m.MinBuyVolume != 0 {
		n += 2 + sovCommon(uint64(m.MinBuyVolume))
	}
	if m.MinSellVolume != 0 {
		n += 2 + sovCommon(uint64(m.MinSellVolume))
	}
	l = m.InstrumentCode.Size()
	n += 2 + l + sovCommon(uint64(l))
	if m.IsTrading {
		n += 3
	}
	if m.DeliveryDateType != 0 {
		n += 2 + sovCommon(uint64(m.DeliveryDateType))
	}
	return n
}

func (m *SimpleTimePeriod) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovCommon(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCommon(uint64(m.End))
	}
	return n
}

func (m *MarketTimeRule) Size() (n int) {
	var l int
	_ = l
	if len(m.SendRule) > 0 {
		for _, e := range m.SendRule {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.CancelRule) > 0 {
		for _, e := range m.CancelRule {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if len(m.MatchingRule) > 0 {
		for _, e := range m.MatchingRule {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ProductInfo) Size() (n int) {
	var l int
	_ = l
	l = m.ProductId.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = m.ProductGroupId.Size()
	n += 1 + l + sovCommon(uint64(l))
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PriceTick != 0 {
		n += 9
	}
	if m.VolumeMultiple != 0 {
		n += 1 + sovCommon(uint64(m.VolumeMultiple))
	}
	if m.PreVolume != 0 {
		n += 1 + sovCommon(uint64(m.PreVolume))
	}
	if m.PrePosition != 0 {
		n += 1 + sovCommon(uint64(m.PrePosition))
	}
	if m.CurrencyType != 0 {
		n += 1 + sovCommon(uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		n += 1 + sovCommon(uint64(m.SettlementGroup))
	}
	l = m.TimeRule.Size()
	n += 1 + l + sovCommon(uint64(l))
	if m.DistinguishPositionTime {
		n += 2
	}
	return n
}

func (m *TradingInstrument) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = m.InstrumentInfo.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = m.ProductInfo.Size()
	n += 1 + l + sovCommon(uint64(l))
	return n
}

func (m *TradingInstrumentList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ProductInfoList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ReqSetTradingInstrumentList) Size() (n int) {
	var l int
	_ = l
	l = len(m.OpCode)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ReqSetProductInfoList) Size() (n int) {
	var l int
	_ = l
	l = len(m.OpCode)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *ReqUpdateTIOpenDate) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCommon(uint64(l))
	if m.OpenDate != 0 {
		n += 1 + sovCommon(uint64(m.OpenDate))
	}
	return n
}

func (m *ReqUpdateTIOpenDateList) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCommon(uint64(m.Exchange))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.OpCode)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *AccountMoneySummary) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	if m.CurrencyType != 0 {
		n += 1 + sovCommon(uint64(m.CurrencyType))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.Commission != 0 {
		n += 9
	}
	if m.CurMargin != 0 {
		n += 9
	}
	if m.NetPositionAmount != 0 {
		n += 9
	}
	if m.PreBalance != 0 {
		n += 9
	}
	if m.InterestIn != 0 {
		n += 9
	}
	if m.Deposit != 0 {
		n += 9
	}
	if m.Withdraw != 0 {
		n += 9
	}
	if m.FrozenMargin != 0 {
		n += 9
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.Available != 0 {
		n += 9
	}
	if m.CloseProfit != 0 {
		n += 9
	}
	if m.PositionProfit != 0 {
		n += 10
	}
	if m.PreMortgate != 0 {
		n += 10
	}
	if m.PreCredit != 0 {
		n += 10
	}
	if m.InterestBase != 0 {
		n += 10
	}
	if m.WithdrawAvailable != 0 {
		n += 10
	}
	if m.Reserve != 0 {
		n += 10
	}
	if m.TradingDay != 0 {
		n += 2 + sovCommon(uint64(m.TradingDay))
	}
	if m.Credit != 0 {
		n += 10
	}
	if m.Mortgate != 0 {
		n += 10
	}
	if m.ExchangeMargin != 0 {
		n += 10
	}
	if m.DeliveryMargin != 0 {
		n += 10
	}
	if m.ExchangeDeliveryMargin != 0 {
		n += 10
	}
	if m.ReserveBalance != 0 {
		n += 10
	}
	if m.DeliveryCommission != 0 {
		n += 10
	}
	if m.FrozenTransferFee != 0 {
		n += 10
	}
	if m.FrozenStampTax != 0 {
		n += 10
	}
	if m.TransferFee != 0 {
		n += 10
	}
	if m.StampTax != 0 {
		n += 10
	}
	if m.MtmProfit != 0 {
		n += 10
	}
	if m.PreMtmProfit != 0 {
		n += 10
	}
	if m.StockValue != 0 {
		n += 10
	}
	if m.BondRepurchaseAmount != 0 {
		n += 10
	}
	if m.ReverseRepurchaseAmount != 0 {
		n += 10
	}
	if m.MarginTradeAmount != 0 {
		n += 10
	}
	if m.ShortSellAmount != 0 {
		n += 10
	}
	if m.MarginTradeProfit != 0 {
		n += 10
	}
	if m.ShortSellProfit != 0 {
		n += 10
	}
	if m.FrozenCloseCommission != 0 {
		n += 10
	}
	if m.CommonBalance != 0 {
		n += 10
	}
	if m.PreferedBalance != 0 {
		n += 10
	}
	if m.BaseExchangeRate != 0 {
		n += 10
	}
	if m.WarningLevel != 0 {
		n += 10
	}
	if m.ForceCloseLevel != 0 {
		n += 10
	}
	if m.ClearedClosedProfit != 0 {
		n += 10
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.Interest != 0 {
		n += 10
	}
	if m.FrozenInterest != 0 {
		n += 10
	}
	return n
}

func (m *AccountMoneySummaryList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *MoneyTransferRecord) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovCommon(uint64(m.Uid))
	}
	if m.Direction != 0 {
		n += 1 + sovCommon(uint64(m.Direction))
	}
	if m.CurrencyType != 0 {
		n += 1 + sovCommon(uint64(m.CurrencyType))
	}
	if m.SettlementGroup != 0 {
		n += 1 + sovCommon(uint64(m.SettlementGroup))
	}
	if m.Confirmed != 0 {
		n += 1 + sovCommon(uint64(m.Confirmed))
	}
	if m.IsPrefered != 0 {
		n += 1 + sovCommon(uint64(m.IsPrefered))
	}
	if m.Amount != 0 {
		n += 9
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.OperatorId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovCommon(uint64(m.SessionId))
	}
	if m.Time != 0 {
		n += 1 + sovCommon(uint64(m.Time))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.BankTradeId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PaymentConfigId != 0 {
		n += 1 + sovCommon(uint64(m.PaymentConfigId))
	}
	if m.OriginalAmount != 0 {
		n += 9
	}
	if m.Fee != 0 {
		n += 10
	}
	l = len(m.PaymentPath)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.IdentityNumber)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.BankName)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.BankBranchName)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.BankCardNo)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.Province)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.PayType)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	if m.PayedTime != 0 {
		n += 2 + sovCommon(uint64(m.PayedTime))
	}
	if m.ConfirmedTime != 0 {
		n += 2 + sovCommon(uint64(m.ConfirmedTime))
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *MTRList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *UserSession) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCommon(uint64(m.Id))
	}
	return n
}

func (m *SSEStockOption) Size() (n int) {
	var l int
	_ = l
	l = len(m.ExercisePrice)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.UpdateVersion)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.OptionType)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.DailyPriceUpLimit)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.TimeSave)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.DELIST_Flag)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.StartDate)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ExpireDate)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ContractUnit)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.CallOrPut)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.LmtOrdMaxFloor)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.DeliveryDate)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ChangeFlag)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.MktOrdMaxFloor)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.UnderlyingType)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.DailyPriceDownLimit)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.RoundLot)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.SecurityClosePX)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.SettlPrice)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.ContractSymbol)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.Num)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.ContractID)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.MarginRatioParam1)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.MarginRatioParam2)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.LmtOrdMinFloor)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.MktOrdMinFloor)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.EndDate)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.PriceLimitType)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.ExerciseDate)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.MarginUnit)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.SecurityID)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.SecurityNameByID)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.ContractFlag)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	l = len(m.UnderlyingClosePX)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Symbol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Symbol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Symbol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Open = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.High = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Low = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Close = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Volume = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Amount = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Position = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KlineSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KlineSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KlineSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= (PeriodType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, Kline{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokerRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokerRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MdFrontList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MdFrontList = append(m.MdFrontList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeFrontList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeFrontList = append(m.TradeFrontList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerRouteList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokerRouteList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokerRouteList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, BrokerRoute{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstrumentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstrumentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstrumentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionRank", wireType)
			}
			m.PositionRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTradingDay", wireType)
			}
			m.UpdateTradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperLimitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.UpperLimitPrice = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerLimitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LowerLimitPrice = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreClosePrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreClosePrice = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSettlementPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreSettlementPrice = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVolume", wireType)
			}
			m.PreVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePosition", wireType)
			}
			m.PrePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrePosition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.SettlementPrice = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDate", wireType)
			}
			m.CreateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenDate", wireType)
			}
			m.OpenDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireDate", wireType)
			}
			m.ExpireDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDeliverDate", wireType)
			}
			m.StartDeliverDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartDeliverDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDeliverDate", wireType)
			}
			m.EndDeliverDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndDeliverDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCloseTodayAllowed", wireType)
			}
			m.IsCloseTodayAllowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCloseTodayAllowed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMarketOrderVolume", wireType)
			}
			m.MaxMarketOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMarketOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMarketOrderVolume", wireType)
			}
			m.MinMarketOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinMarketOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLimitOrderVolume", wireType)
			}
			m.MaxLimitOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLimitOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLimitOrderVolume", wireType)
			}
			m.MinLimitOrderVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLimitOrderVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseSymbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseSymbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrikePrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.StrikePrice = float64(math.Float64frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallPutType", wireType)
			}
			m.CallPutType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallPutType |= (OptionCallPutType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlyingMultiple", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.UnderlyingMultiple = float64(math.Float64frombits(v))
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombinationType", wireType)
			}
			m.CombinationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CombinationType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBuyVolume", wireType)
			}
			m.MinBuyVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBuyVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSellVolume", wireType)
			}
			m.MinSellVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSellVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstrumentCode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTrading", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTrading = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryDateType", wireType)
			}
			m.DeliveryDateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryDateType |= (OptionDeliveryDateType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleTimePeriod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleTimePeriod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleTimePeriod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketTimeRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketTimeRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketTimeRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SendRule = append(m.SendRule, SimpleTimePeriod{})
			if err := m.SendRule[len(m.SendRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelRule = append(m.CancelRule, SimpleTimePeriod{})
			if err := m.CancelRule[len(m.CancelRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchingRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchingRule = append(m.MatchingRule, SimpleTimePeriod{})
			if err := m.MatchingRule[len(m.MatchingRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductGroupId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductGroupId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ProductType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTick", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PriceTick = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMultiple", wireType)
			}
			m.VolumeMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeMultiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVolume", wireType)
			}
			m.PreVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePosition", wireType)
			}
			m.PrePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrePosition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementGroup", wireType)
			}
			m.SettlementGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistinguishPositionTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DistinguishPositionTime = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingInstrument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingInstrument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingInstrument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstrumentInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradingInstrumentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradingInstrumentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradingInstrumentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, TradingInstrument{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, ProductInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetTradingInstrumentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetTradingInstrumentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetTradingInstrumentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, TradingInstrument{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetProductInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetProductInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetProductInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, ProductInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateTIOpenDate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenDate", wireType)
			}
			m.OpenDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateTIOpenDateList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDateList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateTIOpenDateList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, ReqUpdateTIOpenDate{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMoneySummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMoneySummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMoneySummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AccountType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (CurrencyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Balance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Commission = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CurMargin = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetPositionAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.NetPositionAmount = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreBalance = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.InterestIn = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Deposit = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdraw", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Withdraw = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Available = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CloseProfit = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PositionProfit = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMortgate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreMortgate = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreCredit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreCredit = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestBase", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.InterestBase = float64(math.Float64frombits(v))
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawAvailable", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WithdrawAvailable = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Reserve = float64(math.Float64frombits(v))
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			m.TradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Credit = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mortgate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Mortgate = float64(math.Float64frombits(v))
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ExchangeMargin = float64(math.Float64frombits(v))
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.DeliveryMargin = float64(math.Float64frombits(v))
		case 27:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeDeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ExchangeDeliveryMargin = float64(math.Float64frombits(v))
		case 28:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ReserveBalance = float64(math.Float64frombits(v))
		case 29:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.DeliveryCommission = float64(math.Float64frombits(v))
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenTransferFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenTransferFee = float64(math.Float64frombits(v))
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenStampTax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenStampTax = float64(math.Float64frombits(v))
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.TransferFee = float64(math.Float64frombits(v))
		case 33:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StampTax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.StampTax = float64(math.Float64frombits(v))
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtmProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MtmProfit = float64(math.Float64frombits(v))
		case 35:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMtmProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreMtmProfit = float64(math.Float64frombits(v))
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.StockValue = float64(math.Float64frombits(v))
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondRepurchaseAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.BondRepurchaseAmount = float64(math.Float64frombits(v))
		case 38:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseRepurchaseAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ReverseRepurchaseAmount = float64(math.Float64frombits(v))
		case 39:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginTradeAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MarginTradeAmount = float64(math.Float64frombits(v))
		case 40:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortSellAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortSellAmount = float64(math.Float64frombits(v))
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginTradeProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MarginTradeProfit = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortSellProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortSellProfit = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCloseCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenCloseCommission = float64(math.Float64frombits(v))
		case 44:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CommonBalance = float64(math.Float64frombits(v))
		case 45:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferedBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreferedBalance = float64(math.Float64frombits(v))
		case 46:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseExchangeRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.BaseExchangeRate = float64(math.Float64frombits(v))
		case 47:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningLevel", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WarningLevel = float64(math.Float64frombits(v))
		case 48:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseLevel", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ForceCloseLevel = float64(math.Float64frombits(v))
		case 49:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearedClosedProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ClearedClosedProfit = float64(math.Float64frombits(v))
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Interest = float64(math.Float64frombits(v))
		case 52:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenInterest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenInterest = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMoneySummaryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMoneySummaryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMoneySummaryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, AccountMoneySummary{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoneyTransferRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoneyTransferRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoneyTransferRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementGroup", wireType)
			}
			m.SettlementGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirmed", wireType)
			}
			m.Confirmed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confirmed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrefered", wireType)
			}
			m.IsPrefered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPrefered |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Amount = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankTradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankTradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentConfigId", wireType)
			}
			m.PaymentConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentConfigId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.OriginalAmount = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Fee = float64(math.Float64frombits(v))
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankBranchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankBranchName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankCardNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankCardNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Province = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayedTime", wireType)
			}
			m.PayedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayedTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmedTime", wireType)
			}
			m.ConfirmedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmedTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MTRList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MTRList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MTRList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, MoneyTransferRecord{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSEStockOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSEStockOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSEStockOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExercisePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExercisePrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyPriceUpLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DailyPriceUpLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSave", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeSave = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DELIST_Flag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DELIST_Flag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpireDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallOrPut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallOrPut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmtOrdMaxFloor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LmtOrdMaxFloor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeliveryDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MktOrdMaxFloor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MktOrdMaxFloor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlyingType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnderlyingType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyPriceDownLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DailyPriceDownLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundLot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoundLot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityClosePX", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityClosePX = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Num = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginRatioParam1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginRatioParam1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginRatioParam2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginRatioParam2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmtOrdMinFloor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LmtOrdMinFloor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MktOrdMinFloor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MktOrdMinFloor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceLimitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceLimitType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExerciseDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExerciseDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityNameByID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityNameByID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlyingClosePX", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnderlyingClosePX = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("common.proto", fileDescriptorCommon) }

var fileDescriptorCommon = []byte{
	// 3704 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0x4b, 0x73, 0xdb, 0xd8,
	0x72, 0x36, 0x45, 0x3d, 0x88, 0xa6, 0x44, 0x42, 0x90, 0x2c, 0xd1, 0xf6, 0xf8, 0x31, 0xf4, 0x8c,
	0x1f, 0xb2, 0xc7, 0xb6, 0xe4, 0xeb, 0x49, 0xee, 0x64, 0x25, 0x51, 0xd4, 0x98, 0xb1, 0x28, 0xaa,
	0x40, 0xca, 0xd7, 0x73, 0x37, 0x28, 0x88, 0x38, 0x92, 0x50, 0xc2, 0x6b, 0x0e, 0x40, 0x59, 0x4c,
	0x2a, 0x8b, 0x54, 0xfe, 0x40, 0xaa, 0x92, 0x1f, 0x91, 0xaa, 0xac, 0x53, 0xf9, 0x0b, 0x59, 0x66,
	0x9f, 0x4d, 0x6a, 0xb2, 0xca, 0x6f, 0xc8, 0x26, 0xd5, 0xdd, 0xe7, 0x80, 0xa0, 0x24, 0x4f, 0xa6,
	0x52, 0x77, 0x25, 0x9c, 0xaf, 0xbb, 0xcf, 0xa3, 0x5f, 0xa7, 0x4f, 0x53, 0xb0, 0x38, 0x8c, 0xc3,
	0x30, 0x8e, 0x5e, 0x25, 0x32, 0xce, 0x62, 0x6b, 0x26, 0x39, 0x6e, 0xfe, 0x25, 0xcc, 0xf7, 0xc7,
	0xe1, 0x71, 0x1c, 0x58, 0x2f, 0xa1, 0x22, 0x2e, 0x87, 0x67, 0x6e, 0x74, 0x2a, 0x1a, 0xa5, 0x47,
	0xa5, 0x67, 0xb5, 0x2d, 0xf3, 0x55, 0x72, 0xfc, 0xaa, 0xad, 0xb0, 0xc1, 0x38, 0x11, 0x76, 0xce,
	0x61, 0x59, 0x30, 0x3b, 0x8c, 0x3d, 0xd1, 0x98, 0x79, 0x54, 0x7a, 0x66, 0xd8, 0xf4, 0xdd, 0xec,
	0x82, 0x71, 0x28, 0x63, 0x6f, 0x34, 0xcc, 0x3a, 0xbb, 0x7f, 0x82, 0xe9, 0xfe, 0xb5, 0x04, 0x73,
	0x1f, 0x02, 0x3f, 0x22, 0x6a, 0xe6, 0x87, 0x3c, 0x4f, 0xd9, 0xa6, 0x6f, 0xc4, 0xe2, 0x44, 0x44,
	0x24, 0x51, 0xb2, 0xe9, 0x1b, 0xb1, 0x33, 0xff, 0xf4, 0xac, 0x51, 0x66, 0x0c, 0xbf, 0x2d, 0x13,
	0xca, 0x41, 0xfc, 0xb9, 0x31, 0x4b, 0x10, 0x7e, 0x5a, 0xab, 0x30, 0x37, 0x0c, 0xe2, 0x54, 0x34,
	0xe6, 0x08, 0xe3, 0x81, 0xb5, 0x06, 0xf3, 0x17, 0x71, 0x30, 0x0a, 0x45, 0x63, 0x9e, 0x60, 0x35,
	0x42, 0xdc, 0x0d, 0xe3, 0x51, 0x94, 0x35, 0x16, 0x18, 0xe7, 0x91, 0x75, 0x17, 0x2a, 0x49, 0x9c,
	0xfa, 0x99, 0x1f, 0x47, 0x8d, 0x0a, 0x51, 0xf2, 0x71, 0xf3, 0x12, 0xaa, 0xb4, 0xf1, 0xbe, 0x90,
	0xbe, 0x48, 0xad, 0x26, 0xcc, 0xa7, 0xa4, 0x63, 0x3a, 0x40, 0x75, 0x0b, 0x50, 0x11, 0xac, 0x75,
	0x5b, 0x51, 0xac, 0x27, 0x30, 0x9f, 0x08, 0xe9, 0xc7, 0x1e, 0x1d, 0xa8, 0xb6, 0x55, 0x43, 0x9e,
	0x43, 0x42, 0x48, 0x55, 0x8a, 0x6a, 0xdd, 0x87, 0xd9, 0xc0, 0x4f, 0xb3, 0x46, 0xf9, 0x51, 0xf9,
	0x59, 0x75, 0xcb, 0x40, 0x2e, 0x5a, 0xca, 0x26, 0xb8, 0xf9, 0x0f, 0x25, 0xa8, 0xee, 0xc8, 0xf8,
	0x5c, 0x48, 0x3b, 0x1e, 0x65, 0xc2, 0xaa, 0xc1, 0x8c, 0xef, 0xd1, 0xb2, 0x86, 0x3d, 0xe3, 0x7b,
	0xa4, 0xc9, 0x71, 0xc2, 0x7a, 0x9e, 0xb3, 0xe9, 0x1b, 0xb1, 0xc8, 0x0d, 0x05, 0x69, 0xcd, 0xb0,
	0xe9, 0xdb, 0x6a, 0xc2, 0x52, 0xe8, 0x39, 0x27, 0x32, 0x8e, 0x32, 0x87, 0xd6, 0x9b, 0x7d, 0x54,
	0x7e, 0x66, 0xd8, 0xd5, 0xd0, 0xdb, 0x43, 0x6c, 0xdf, 0x4f, 0x33, 0xeb, 0x19, 0x98, 0x99, 0x74,
	0x3d, 0x51, 0x64, 0x9b, 0x23, 0xb6, 0x1a, 0xe1, 0x39, 0x67, 0xf3, 0x7b, 0xa8, 0x17, 0x36, 0x45,
	0xc2, 0x8f, 0xd5, 0x39, 0x4a, 0x74, 0x8e, 0x3a, 0x9e, 0xa3, 0xc0, 0xa2, 0x4e, 0xf3, 0x1f, 0x00,
	0xb5, 0x4e, 0x94, 0x66, 0x72, 0x14, 0x8a, 0x28, 0xeb, 0x44, 0x27, 0xb1, 0xf5, 0x10, 0xaa, 0xac,
	0x31, 0x87, 0xf6, 0xcc, 0x27, 0x03, 0x86, 0x0e, 0x70, 0xe7, 0x8f, 0x61, 0x49, 0xdb, 0xc1, 0x91,
	0x6e, 0x74, 0xae, 0x8e, 0xba, 0xa8, 0x41, 0xdb, 0x8d, 0xce, 0x71, 0x96, 0x51, 0xe2, 0xb9, 0x99,
	0x70, 0xc8, 0xaf, 0xca, 0xe4, 0x57, 0xc0, 0xd0, 0x00, 0xbd, 0xeb, 0x25, 0x58, 0x9a, 0x41, 0xba,
	0x9e, 0x1f, 0x9d, 0x3a, 0x9e, 0x3b, 0x26, 0x27, 0x9a, 0xb3, 0x4d, 0xc5, 0xc7, 0x84, 0x5d, 0x77,
	0x6c, 0x6d, 0xc0, 0xf2, 0x28, 0x49, 0x84, 0x74, 0x02, 0x3f, 0xf4, 0x33, 0x27, 0x91, 0xfe, 0x50,
	0x7b, 0x57, 0x9d, 0x08, 0xfb, 0x88, 0x1f, 0x22, 0x8c, 0xbc, 0x41, 0xfc, 0xf9, 0x0a, 0x2f, 0xbb,
	0x5c, 0x9d, 0x08, 0x05, 0xde, 0x27, 0x50, 0x4f, 0xa4, 0x70, 0xc8, 0x41, 0x15, 0x27, 0x3b, 0xe1,
	0x52, 0x22, 0x45, 0x0b, 0x51, 0xe6, 0x7b, 0x03, 0xab, 0xc8, 0x97, 0x8a, 0x2c, 0x0b, 0x04, 0xaa,
	0x4a, 0x31, 0xb3, 0x5f, 0x5a, 0x89, 0x14, 0xfd, 0x9c, 0xc4, 0x12, 0xf7, 0x01, 0x50, 0x42, 0x79,
	0xbc, 0x41, 0xe7, 0x32, 0x12, 0x29, 0x3e, 0xb2, 0xd3, 0x7f, 0x0d, 0x8b, 0x48, 0xce, 0x1d, 0x1c,
	0x88, 0xa1, 0x9a, 0x48, 0x71, 0xa8, 0x20, 0xeb, 0x39, 0x98, 0xd7, 0xd6, 0xab, 0xf2, 0x31, 0xd2,
	0x2b, 0x8b, 0x3d, 0x84, 0xea, 0x50, 0x0a, 0x54, 0x26, 0xea, 0xad, 0xb1, 0x48, 0x93, 0x01, 0x43,
	0xbb, 0x6e, 0x26, 0xac, 0x7b, 0x60, 0x60, 0xfc, 0x32, 0x79, 0x89, 0xc8, 0x15, 0x04, 0x88, 0xf8,
	0x10, 0xaa, 0xe2, 0x32, 0xf1, 0xa5, 0x92, 0xae, 0xb1, 0x34, 0x43, 0xc4, 0xf0, 0x12, 0xac, 0x34,
	0x73, 0x65, 0xe6, 0x78, 0x22, 0xf0, 0x2f, 0x84, 0x64, 0xbe, 0x3a, 0xdb, 0x8a, 0x28, 0xbb, 0x4c,
	0x20, 0xee, 0x67, 0x60, 0x8a, 0xc8, 0x9b, 0xe6, 0x35, 0x89, 0xb7, 0x26, 0x22, 0xaf, 0xc8, 0xf9,
	0x16, 0xd6, 0xfc, 0x54, 0x29, 0x3f, 0x8b, 0x3d, 0x77, 0xec, 0xb8, 0x01, 0x5a, 0xc8, 0x6b, 0x2c,
	0x13, 0xff, 0x8a, 0x9f, 0x92, 0x0d, 0x06, 0x48, 0xdb, 0x66, 0x92, 0xf5, 0x0e, 0xd6, 0x43, 0xf7,
	0xd2, 0x09, 0x5d, 0x79, 0x2e, 0x32, 0x27, 0x96, 0x9e, 0x90, 0x5a, 0xcb, 0x16, 0x49, 0xad, 0x86,
	0xee, 0x65, 0x97, 0xa8, 0x3d, 0x24, 0x2a, 0x85, 0xa3, 0x98, 0x1f, 0xdd, 0x28, 0xb6, 0xa2, 0xc4,
	0xfc, 0xe8, 0xba, 0xd8, 0x5b, 0x58, 0xc3, 0xd5, 0xd8, 0x95, 0xa6, 0xa4, 0x56, 0x79, 0x8b, 0xa1,
	0x7b, 0x49, 0xfe, 0x74, 0x55, 0xc8, 0x8f, 0x6e, 0x12, 0xba, 0xad, 0x84, 0xfc, 0xe8, 0x9a, 0xd0,
	0x0b, 0xa8, 0x1e, 0xbb, 0xa9, 0x70, 0x54, 0x22, 0x5b, 0xbb, 0x96, 0xc8, 0x00, 0xc9, 0xea, 0x2a,
	0xf9, 0x1a, 0x16, 0xd3, 0x4c, 0xfa, 0xe7, 0xda, 0x69, 0xd7, 0xc9, 0x2f, 0xaa, 0x8c, 0xb1, 0x4f,
	0xfc, 0x1e, 0x96, 0x86, 0x6e, 0x10, 0x38, 0xc9, 0x28, 0x73, 0x28, 0x23, 0x35, 0x28, 0xed, 0xdd,
	0xc6, 0x19, 0x7b, 0x09, 0x7a, 0x58, 0xcb, 0x0d, 0x82, 0xc3, 0x51, 0x46, 0xd9, 0xaf, 0x3a, 0x9c,
	0x0c, 0xac, 0xd7, 0xb0, 0x32, 0x8a, 0x3c, 0x21, 0x83, 0x31, 0xc6, 0x65, 0x38, 0x0a, 0x32, 0x3f,
	0x09, 0x44, 0xe3, 0x0e, 0x3b, 0xfb, 0x84, 0xd4, 0x55, 0x14, 0x74, 0xd5, 0x61, 0x1c, 0x1e, 0xfb,
	0x91, 0x4b, 0x59, 0x81, 0x96, 0xbb, 0x4b, 0x47, 0xad, 0x17, 0x70, 0x9a, 0xfb, 0x1b, 0xa8, 0xa1,
	0x6e, 0x8e, 0x47, 0x63, 0xad, 0x93, 0x7b, 0x9c, 0x3e, 0x42, 0x3f, 0xda, 0x19, 0x8d, 0x95, 0x32,
	0x9e, 0x40, 0x1d, 0xb9, 0x52, 0x11, 0x04, 0x9a, 0xed, 0x2b, 0x62, 0x5b, 0x0a, 0xfd, 0xa8, 0x2f,
	0x82, 0x20, 0xd7, 0x74, 0xdd, 0xcf, 0xd3, 0x97, 0x43, 0x17, 0xdc, 0xfd, 0x6b, 0x8a, 0xab, 0x4d,
	0x58, 0x5a, 0xb1, 0x47, 0xa1, 0xe9, 0xa7, 0x3a, 0xed, 0x34, 0x1e, 0x3c, 0x2a, 0x3d, 0xab, 0xd8,
	0x86, 0x9f, 0xaa, 0x74, 0x63, 0xbd, 0x07, 0x4b, 0xf9, 0xee, 0xd8, 0xe1, 0x04, 0x85, 0xc7, 0x79,
	0x48, 0xda, 0xbb, 0x3b, 0xd1, 0x9e, 0x72, 0xe4, 0x31, 0x7a, 0x32, 0xa9, 0xd0, 0xf4, 0xae, 0x20,
	0xcd, 0x1f, 0xc0, 0xec, 0xfb, 0x61, 0x12, 0x50, 0xc6, 0xe3, 0xab, 0x06, 0xef, 0x46, 0x8a, 0x18,
	0x4a, 0xac, 0x73, 0x36, 0x0f, 0xf0, 0x0e, 0x15, 0x91, 0xa7, 0x32, 0x29, 0x7e, 0x36, 0xff, 0xa5,
	0x04, 0x35, 0x76, 0x47, 0x14, 0xb6, 0x47, 0x81, 0xb0, 0x36, 0xc1, 0x48, 0x31, 0xb2, 0xe4, 0x28,
	0x10, 0x2a, 0xad, 0xaf, 0xd2, 0x31, 0xaf, 0xac, 0x61, 0x57, 0x90, 0x8d, 0x44, 0xde, 0x41, 0x75,
	0xe8, 0x46, 0x43, 0x11, 0xb0, 0xd0, 0xcc, 0xaf, 0x08, 0x01, 0x33, 0x92, 0xd8, 0xef, 0x61, 0x29,
	0x74, 0xb3, 0xe1, 0x19, 0x9a, 0x9f, 0x04, 0xcb, 0xbf, 0x22, 0xb8, 0xa8, 0x59, 0x51, 0xb4, 0xf9,
	0x77, 0xb3, 0x50, 0xd5, 0x35, 0x0a, 0x5e, 0x27, 0x2f, 0x31, 0x0f, 0xd2, 0xd0, 0x51, 0xf7, 0x64,
	0x75, 0x6b, 0x89, 0xae, 0x5e, 0x5d, 0xc8, 0x60, 0x5a, 0xe4, 0x4f, 0xcf, 0xfa, 0x33, 0x30, 0x35,
	0xf7, 0xa9, 0x8c, 0x47, 0x09, 0xca, 0xcc, 0xdc, 0x24, 0x53, 0x53, 0x6c, 0x3f, 0x22, 0x57, 0xc7,
	0xc3, 0xdb, 0x8e, 0xcc, 0x54, 0x26, 0x33, 0xd5, 0x0b, 0xcc, 0x64, 0x1b, 0xbe, 0x87, 0x29, 0xe9,
	0xf2, 0xec, 0x74, 0xb7, 0xcd, 0xd2, 0xdd, 0x56, 0x55, 0x18, 0x5d, 0x6e, 0x94, 0xb6, 0xfd, 0x21,
	0x5e, 0x5b, 0xc3, 0x73, 0x75, 0xc3, 0x18, 0x84, 0x0c, 0xfc, 0xe1, 0xb9, 0xf5, 0x14, 0xea, 0xec,
	0x8e, 0x93, 0xa8, 0x98, 0xe7, 0xd4, 0xc6, 0x70, 0x1e, 0x11, 0xd3, 0xe9, 0x7f, 0xe1, 0xff, 0x4a,
	0xff, 0x95, 0xeb, 0xe9, 0xff, 0x31, 0x2c, 0x0d, 0x47, 0x52, 0x8a, 0x68, 0x38, 0x66, 0x0f, 0xe4,
	0x3b, 0x64, 0x51, 0x83, 0x14, 0x4d, 0xd3, 0x77, 0x04, 0xa9, 0x4c, 0x5d, 0x25, 0x85, 0x3b, 0x82,
	0x74, 0x64, 0xbd, 0x06, 0x03, 0xaf, 0x62, 0xb6, 0x67, 0x95, 0x74, 0x6a, 0xa1, 0x9a, 0xa6, 0x9d,
	0xcc, 0xae, 0x64, 0xda, 0xdd, 0x7e, 0x80, 0x3b, 0x9e, 0x9f, 0x66, 0x7e, 0x74, 0x3a, 0xf2, 0xd3,
	0xb3, 0x7c, 0xaf, 0x7c, 0xa1, 0x2f, 0x52, 0xd4, 0xac, 0x17, 0x18, 0xf4, 0xc6, 0x71, 0xa6, 0xe6,
	0x3f, 0x95, 0x60, 0x59, 0xc5, 0xd3, 0xa4, 0xbc, 0xf8, 0x4d, 0x65, 0xda, 0x5f, 0x4c, 0x45, 0xb4,
	0x1f, 0x9d, 0xc4, 0xca, 0x01, 0x68, 0xb3, 0xd3, 0xb5, 0x4a, 0x31, 0xb2, 0xc9, 0xd9, 0xb6, 0x26,
	0x06, 0x26, 0xc9, 0x32, 0x49, 0x16, 0xbd, 0x81, 0xc4, 0xb4, 0xc5, 0x71, 0xd0, 0xdc, 0x81, 0xdb,
	0xd7, 0x76, 0x4a, 0x05, 0xd4, 0xf3, 0xa9, 0x02, 0x8a, 0xf2, 0xe6, 0x35, 0x46, 0x55, 0x46, 0x7d,
	0x0f, 0xf5, 0xc2, 0xfc, 0x5f, 0x2a, 0xbf, 0x8a, 0x5b, 0x60, 0xb9, 0xbf, 0x81, 0x7b, 0xb6, 0xf8,
	0xb9, 0x2f, 0xb2, 0x9b, 0x77, 0xb0, 0x0e, 0x0b, 0x71, 0xc2, 0x59, 0x8d, 0xcb, 0xb0, 0xf9, 0x38,
	0xa1, 0x0c, 0x76, 0xb7, 0x50, 0xfa, 0x73, 0xce, 0x98, 0x14, 0xfa, 0xcf, 0xa7, 0xea, 0xd7, 0x5f,
	0xdd, 0xf6, 0xcf, 0x70, 0x9b, 0x97, 0xbf, 0xba, 0xf9, 0xff, 0xd7, 0xc2, 0x8f, 0xa7, 0x16, 0xfe,
	0xc2, 0x89, 0x3f, 0xc2, 0x8a, 0x2d, 0x7e, 0x3e, 0xe2, 0xfa, 0xae, 0xd3, 0xd3, 0x25, 0xc8, 0x6f,
	0xf1, 0x8c, 0xa9, 0x1a, 0x66, 0x66, 0xba, 0x86, 0x69, 0xfe, 0x35, 0xac, 0xdf, 0x30, 0x2f, 0x1d,
	0xe6, 0xee, 0x95, 0x77, 0x52, 0x71, 0xcf, 0x2f, 0xd4, 0x9e, 0x39, 0x31, 0xae, 0xe3, 0xaa, 0x37,
	0x4c, 0xc3, 0x7b, 0x2f, 0x6a, 0xa5, 0x5c, 0xd4, 0x4a, 0xf3, 0xbf, 0xeb, 0xb0, 0xb2, 0x3d, 0x1c,
	0xe2, 0xab, 0xa5, 0x1b, 0x47, 0x62, 0xdc, 0x1f, 0x85, 0xa1, 0x2b, 0xc7, 0xd7, 0xde, 0x06, 0x8f,
	0x0b, 0x6f, 0x03, 0x95, 0xa4, 0x94, 0x58, 0x21, 0x49, 0xbd, 0xbb, 0x1a, 0xf7, 0xe5, 0xc9, 0xdb,
	0xae, 0x55, 0x88, 0xfd, 0x2b, 0x99, 0xa0, 0x01, 0x0b, 0xc7, 0x6e, 0x80, 0x29, 0x5c, 0xbd, 0xc4,
	0xf4, 0xd0, 0x7a, 0x00, 0x80, 0x8f, 0x52, 0x3f, 0x4d, 0x31, 0xd3, 0x70, 0x4a, 0x2b, 0x20, 0x98,
	0xaa, 0x86, 0x23, 0x89, 0x95, 0xd1, 0xa9, 0x1f, 0xa9, 0x42, 0xd9, 0x18, 0x8e, 0x64, 0x97, 0x00,
	0xeb, 0x15, 0xac, 0x44, 0x22, 0x9b, 0x84, 0xff, 0xd4, 0x5b, 0x6d, 0x39, 0x12, 0x99, 0x0e, 0xfc,
	0x6d, 0x7e, 0xb6, 0x3d, 0x04, 0x4c, 0x63, 0x8e, 0xde, 0x0c, 0x57, 0xc8, 0x98, 0x0c, 0x77, 0xd4,
	0x7e, 0x1e, 0x42, 0xd5, 0x8f, 0x32, 0x21, 0x45, 0x8a, 0x51, 0x4a, 0x69, 0xad, 0x64, 0x83, 0x86,
	0x3a, 0x11, 0x1e, 0xc5, 0x13, 0xb4, 0x1e, 0xe5, 0xb2, 0x92, 0xad, 0x87, 0x68, 0xca, 0xcf, 0x7e,
	0x76, 0xe6, 0x49, 0xf7, 0xb3, 0x2a, 0x85, 0xf3, 0x31, 0xe6, 0xcb, 0x13, 0x19, 0xff, 0x95, 0x88,
	0xf4, 0x49, 0x16, 0x89, 0x61, 0x91, 0x41, 0x75, 0x98, 0x17, 0xb0, 0xac, 0x98, 0x0a, 0x2a, 0x59,
	0x22, 0x46, 0x93, 0x09, 0xad, 0x89, 0x62, 0xbe, 0x02, 0xc3, 0xbd, 0x70, 0xfd, 0xc0, 0x3d, 0x0e,
	0xb8, 0x2a, 0x2e, 0xd9, 0x13, 0x00, 0x53, 0xb8, 0x7e, 0x36, 0xc4, 0x27, 0x7e, 0x46, 0xe5, 0x70,
	0xc9, 0xae, 0x0e, 0xf9, 0xd1, 0x80, 0x10, 0xde, 0x16, 0xb9, 0xda, 0x14, 0x97, 0x49, 0x5c, 0x35,
	0x0d, 0x2b, 0x46, 0x75, 0x1d, 0x84, 0xb1, 0xcc, 0x4e, 0xd1, 0xbb, 0x97, 0x79, 0xae, 0x44, 0x8a,
	0xae, 0x82, 0xf4, 0x85, 0x32, 0x94, 0xc2, 0xf3, 0x33, 0xaa, 0x74, 0xe9, 0x62, 0x12, 0x2d, 0x02,
	0xf0, 0xf4, 0xb9, 0x52, 0xb1, 0x4e, 0xa4, 0xa2, 0xb6, 0x64, 0x2f, 0x6a, 0x70, 0xc7, 0x4d, 0x85,
	0xf5, 0x1d, 0x58, 0x5a, 0x5d, 0xce, 0xe4, 0x64, 0xab, 0x6c, 0x49, 0x4d, 0xd9, 0xce, 0x4f, 0xd8,
	0x80, 0x05, 0x29, 0x52, 0x21, 0x2f, 0xb8, 0x6e, 0x2d, 0xd9, 0x7a, 0x88, 0x26, 0x2c, 0xbe, 0xda,
	0xd6, 0xf8, 0xc5, 0x90, 0x4d, 0xde, 0x6b, 0x6b, 0x30, 0xaf, 0x76, 0xca, 0x95, 0xa9, 0x1a, 0xa1,
	0x01, 0xf3, 0x43, 0x36, 0xd8, 0x80, 0x7a, 0x8c, 0xda, 0xd2, 0x71, 0xa9, 0x4d, 0xc8, 0x15, 0x67,
	0x4d, 0xc3, 0xca, 0x88, 0x4f, 0xa1, 0x9e, 0x17, 0x68, 0x8a, 0xf1, 0x2e, 0x33, 0x6a, 0x58, 0x31,
	0xfe, 0x39, 0x34, 0xf2, 0x19, 0xaf, 0x4a, 0xdc, 0x23, 0x89, 0x35, 0x4d, 0xdf, 0x9d, 0x96, 0x7c,
	0x0a, 0x75, 0x75, 0xd6, 0xdc, 0x91, 0xbf, 0xe2, 0x25, 0x14, 0xac, 0x9d, 0xf9, 0x35, 0xac, 0xe4,
	0x33, 0x17, 0x5c, 0xea, 0x3e, 0x97, 0xca, 0x9a, 0x54, 0x70, 0xaa, 0x57, 0xb0, 0xa2, 0x3c, 0x30,
	0x93, 0x6e, 0x94, 0x9e, 0x08, 0xe9, 0x9c, 0x08, 0x41, 0x55, 0x68, 0xc9, 0x56, 0xce, 0x39, 0x50,
	0x94, 0x3d, 0x41, 0xaf, 0x29, 0xc5, 0x9f, 0x66, 0x6e, 0x98, 0x38, 0x99, 0x7b, 0x49, 0xb5, 0x68,
	0xc9, 0xae, 0x31, 0xde, 0x47, 0x78, 0xe0, 0x5e, 0xa2, 0x13, 0x4d, 0x4d, 0xf9, 0x88, 0x9d, 0x28,
	0x2b, 0x4c, 0x76, 0x0f, 0x8c, 0xc9, 0x2c, 0x5f, 0xb3, 0xfe, 0x53, 0x2d, 0x7f, 0x1f, 0x20, 0xcc,
	0x42, 0xed, 0xa8, 0x4d, 0xf6, 0xb0, 0x30, 0x0b, 0x95, 0x8f, 0x7e, 0x03, 0x35, 0xf2, 0xd1, 0x09,
	0xcb, 0x63, 0x76, 0x31, 0xf4, 0xd2, 0x9c, 0xeb, 0x21, 0x54, 0xd3, 0x2c, 0x1e, 0x9e, 0x3b, 0x17,
	0x6e, 0x30, 0x12, 0x8d, 0x6f, 0x38, 0xb8, 0x09, 0xfa, 0x88, 0x88, 0xf5, 0x3b, 0x58, 0x3b, 0x8e,
	0xb1, 0x88, 0x15, 0xc9, 0x48, 0x0e, 0xcf, 0xf0, 0xc5, 0xa3, 0x32, 0xca, 0xb7, 0xc4, 0xbb, 0x8a,
	0x54, 0x3b, 0x27, 0xaa, 0xa4, 0xf2, 0x03, 0xdc, 0x91, 0xe2, 0x42, 0xc8, 0x54, 0xdc, 0x20, 0xf8,
	0x84, 0x04, 0xd7, 0x15, 0xc3, 0x35, 0xd9, 0x57, 0xb0, 0xc2, 0x36, 0x77, 0xb8, 0x99, 0xa2, 0xa4,
	0x9e, 0xb2, 0xc6, 0x99, 0x84, 0x37, 0xa4, 0xe6, 0xdf, 0x80, 0xe5, 0xf4, 0x2c, 0x96, 0x19, 0xbf,
	0x3e, 0x14, 0xf7, 0x33, 0xf5, 0xf0, 0x46, 0x02, 0xbe, 0x3f, 0xbe, 0x30, 0xb7, 0xd2, 0xcc, 0xf3,
	0x6b, 0x73, 0x2b, 0xf5, 0x4c, 0xcf, 0xad, 0xb8, 0x37, 0xae, 0xcc, 0xad, 0x78, 0xbf, 0x87, 0x75,
	0x9d, 0xab, 0x28, 0xcf, 0x14, 0xdc, 0xeb, 0x05, 0x49, 0xdc, 0x56, 0x19, 0x0b, 0xa9, 0x05, 0x0f,
	0xfb, 0x16, 0x6a, 0xdc, 0x84, 0xcc, 0x5d, 0xf7, 0x25, 0xb7, 0x34, 0x18, 0xd5, 0x9e, 0xfb, 0x1c,
	0x4b, 0x6d, 0x71, 0x22, 0xa4, 0xf0, 0x72, 0xc6, 0xef, 0x78, 0x27, 0x1a, 0xd7, 0xac, 0x2f, 0xc1,
	0xa2, 0xa7, 0x69, 0x1e, 0x4c, 0x12, 0xe3, 0xf7, 0x15, 0xa7, 0x4d, 0xa4, 0xe8, 0x9e, 0xa3, 0x8d,
	0x71, 0xfc, 0x18, 0x96, 0x3e, 0xbb, 0x32, 0xc2, 0xe4, 0x10, 0x88, 0x0b, 0x11, 0x34, 0x5e, 0xb3,
	0x9f, 0x28, 0x70, 0x1f, 0x31, 0x54, 0xc4, 0x49, 0x2c, 0x87, 0xba, 0xf5, 0xc2, 0x8c, 0x6f, 0x78,
	0x79, 0x22, 0xd0, 0xa9, 0x98, 0x77, 0x0b, 0x6e, 0x0f, 0x03, 0xe1, 0xe2, 0x46, 0x89, 0xdb, 0xd3,
	0x8a, 0xdb, 0x24, 0xfe, 0x15, 0x45, 0x24, 0x09, 0x4f, 0x29, 0x4f, 0xb7, 0xdc, 0xb6, 0x0a, 0x2d,
	0xb7, 0xbb, 0x50, 0xd1, 0xe9, 0xb0, 0xf1, 0x96, 0x9d, 0x5f, 0x8f, 0x31, 0xe0, 0x95, 0xb2, 0x73,
	0x96, 0xdf, 0x15, 0xa3, 0xac, 0xa3, 0xd0, 0xe6, 0x1e, 0xac, 0xdf, 0x70, 0xd5, 0x53, 0xa1, 0xf1,
	0x62, 0xaa, 0xe4, 0x5b, 0x2f, 0x5c, 0xef, 0x45, 0x56, 0x55, 0x08, 0xfd, 0xed, 0x02, 0xac, 0x10,
	0xac, 0x83, 0xdd, 0x16, 0xc3, 0x58, 0x7a, 0xf8, 0x12, 0x1c, 0xa9, 0xa2, 0xa1, 0x6c, 0xe3, 0x27,
	0x5e, 0x43, 0x9e, 0x2f, 0xc5, 0x90, 0x1e, 0x0a, 0x5c, 0xf7, 0x4c, 0x80, 0xeb, 0xcf, 0x84, 0xf2,
	0x6f, 0x7c, 0x26, 0xcc, 0xde, 0xfc, 0x4c, 0xf8, 0x0a, 0x8c, 0x61, 0x1c, 0x9d, 0xf8, 0x32, 0x14,
	0x1e, 0x15, 0x0b, 0x73, 0xf6, 0x04, 0xa0, 0xbb, 0x3b, 0x75, 0xb4, 0x7f, 0xa8, 0xb7, 0x0f, 0xf8,
	0xe9, 0xa1, 0x42, 0xbe, 0xd8, 0xcc, 0xbd, 0x0f, 0xe0, 0xb2, 0x2e, 0xf0, 0x49, 0x57, 0x21, 0xab,
	0x18, 0x0a, 0xe9, 0xd0, 0xbc, 0x71, 0x22, 0xa4, 0x9b, 0xc5, 0x12, 0xe9, 0x06, 0x37, 0x1d, 0x35,
	0xd4, 0xf1, 0x50, 0x3e, 0x15, 0xe4, 0xdf, 0x48, 0xe7, 0x27, 0x8e, 0xa1, 0x90, 0x8e, 0x97, 0xf7,
	0xaf, 0xab, 0x85, 0xfe, 0x75, 0x03, 0x16, 0xd0, 0xe3, 0x45, 0x94, 0x51, 0x29, 0x60, 0xd8, 0x7a,
	0x68, 0x35, 0x61, 0xe9, 0xd8, 0x8d, 0xce, 0x55, 0xcc, 0xfa, 0x1e, 0x55, 0x00, 0x86, 0x5d, 0x45,
	0x90, 0xa2, 0xb5, 0xe3, 0xa1, 0x83, 0x26, 0xee, 0x58, 0xb5, 0x15, 0xa2, 0x13, 0xff, 0x14, 0xf9,
	0x6a, 0x34, 0x7d, 0x5d, 0x11, 0x5a, 0x84, 0x77, 0x3c, 0x74, 0x9e, 0x58, 0xfa, 0xa7, 0x7e, 0xe4,
	0xe6, 0xf9, 0x82, 0xab, 0x81, 0x9a, 0x86, 0x55, 0xba, 0x30, 0xa1, 0x8c, 0x99, 0x99, 0x8b, 0x00,
	0xfc, 0xa4, 0x9b, 0x5f, 0x2d, 0x93, 0xb8, 0xd9, 0x19, 0xdd, 0xfc, 0xf8, 0x24, 0x65, 0xec, 0xd0,
	0xcd, 0xce, 0x70, 0x76, 0xdf, 0x13, 0x51, 0xe6, 0x67, 0x63, 0x27, 0x1a, 0x85, 0xc7, 0x42, 0xd2,
	0xf5, 0x6f, 0xd8, 0x35, 0x0d, 0x1f, 0x10, 0x4a, 0x73, 0x9d, 0xc5, 0x91, 0xd0, 0x5c, 0x2b, 0x6a,
	0x2e, 0xc4, 0x14, 0xcb, 0x3d, 0x30, 0xe8, 0xe4, 0x14, 0x1b, 0xab, 0x44, 0xaf, 0x20, 0x40, 0x6f,
	0xdf, 0x67, 0x60, 0x12, 0xf1, 0x58, 0xba, 0xd1, 0xf0, 0x8c, 0x79, 0x6e, 0xf3, 0x4a, 0x88, 0xef,
	0x10, 0x4c, 0x9c, 0x8f, 0x60, 0x91, 0x38, 0x87, 0xae, 0xf4, 0x9c, 0x28, 0xa6, 0x02, 0xc0, 0xb0,
	0x01, 0xb1, 0x96, 0x2b, 0xbd, 0x83, 0x98, 0x9a, 0xf7, 0x32, 0xbe, 0xf0, 0x23, 0xd5, 0x9c, 0x32,
	0xec, 0x7c, 0x4c, 0x3f, 0x45, 0xf8, 0xd9, 0x98, 0x0a, 0x00, 0xc3, 0xa6, 0x6f, 0xeb, 0x0e, 0x54,
	0x12, 0x57, 0x79, 0xf0, 0x1d, 0xb6, 0x56, 0xe2, 0xb2, 0xf3, 0x62, 0xe5, 0xe3, 0x8e, 0x85, 0xc7,
	0x0f, 0xcf, 0xbb, 0x64, 0x02, 0x83, 0x10, 0x6a, 0x24, 0x53, 0xba, 0x53, 0xfe, 0xc9, 0x2c, 0xf7,
	0x88, 0x65, 0x29, 0x47, 0x07, 0xea, 0xd7, 0x0c, 0x3a, 0xd0, 0x57, 0x93, 0x84, 0xd0, 0xfc, 0x1e,
	0x16, 0xba, 0x03, 0xfb, 0x4b, 0xb1, 0x7b, 0x43, 0x74, 0xaa, 0xd8, 0xbd, 0x0f, 0xd5, 0xa3, 0x54,
	0xc8, 0x3e, 0xbb, 0x5f, 0xa1, 0xcc, 0x2f, 0x63, 0x99, 0xdf, 0xfc, 0x47, 0x80, 0x5a, 0xbf, 0xdf,
	0xee, 0xe3, 0xa5, 0xc7, 0xbd, 0x22, 0xdc, 0xa4, 0xb8, 0x14, 0x72, 0xe8, 0xe7, 0x6d, 0x66, 0x7e,
	0x15, 0x2c, 0x69, 0x94, 0x7b, 0x76, 0xdf, 0x42, 0x4d, 0x35, 0xc5, 0xf1, 0x2a, 0xd3, 0xf1, 0x6e,
	0xd8, 0x4b, 0x8c, 0x7e, 0x64, 0x90, 0xa3, 0x65, 0xd2, 0x69, 0x2b, 0xeb, 0x68, 0xc9, 0x9b, 0x6c,
	0xaf, 0x61, 0xd5, 0x73, 0xfd, 0x60, 0xcc, 0x6b, 0x39, 0xa3, 0x84, 0x7b, 0x91, 0xaa, 0xe1, 0xb1,
	0x4c, 0x34, 0x5a, 0xf1, 0x28, 0xa1, 0x3e, 0x24, 0xfa, 0x05, 0x35, 0x07, 0x52, 0xf7, 0x82, 0xfb,
	0xea, 0x06, 0x37, 0x02, 0xfa, 0x2e, 0x57, 0x7b, 0xbb, 0xed, 0xfd, 0x4e, 0x7f, 0xe0, 0xec, 0x05,
	0xee, 0x29, 0x05, 0xbd, 0x61, 0x03, 0x43, 0x88, 0x50, 0x70, 0x72, 0x7f, 0x18, 0xef, 0x85, 0x05,
	0x0e, 0x6e, 0xee, 0x0b, 0xdf, 0xd0, 0x5f, 0xe6, 0xe0, 0x2f, 0xf6, 0x97, 0x31, 0x87, 0xc5, 0x51,
	0x26, 0xdd, 0x61, 0xe6, 0x8c, 0x22, 0x3f, 0x53, 0xf1, 0xbf, 0xa8, 0xc1, 0xa3, 0xc8, 0xcf, 0xac,
	0x07, 0x40, 0x3d, 0x4a, 0x27, 0x96, 0x4e, 0x32, 0xe2, 0x97, 0x81, 0x61, 0x1b, 0x08, 0xf5, 0xe4,
	0xe1, 0x08, 0x9f, 0xeb, 0xcb, 0x41, 0x48, 0xed, 0x56, 0x27, 0x74, 0x2f, 0x9d, 0x93, 0x20, 0x8e,
	0x25, 0xe5, 0x03, 0xc3, 0xae, 0x05, 0x61, 0xd6, 0x93, 0x5e, 0xd7, 0xbd, 0xdc, 0x43, 0x14, 0xd7,
	0x9b, 0xea, 0xf0, 0xa9, 0xfc, 0xb0, 0x58, 0x6c, 0xe0, 0x51, 0x4f, 0x9d, 0x6f, 0xbb, 0x13, 0x3c,
	0x35, 0xa7, 0x08, 0x60, 0x88, 0x4e, 0xfd, 0x1c, 0x96, 0xc3, 0xf3, 0xab, 0x0b, 0xd6, 0x78, 0xc1,
	0xf0, 0x7c, 0x6a, 0xc1, 0xa7, 0x50, 0x2f, 0x34, 0x54, 0xc9, 0x68, 0x75, 0x66, 0x9c, 0xc0, 0x64,
	0xb8, 0xb7, 0xb0, 0x56, 0x34, 0x9c, 0x17, 0x7f, 0x56, 0x6d, 0x64, 0xca, 0x19, 0x86, 0xbd, 0x32,
	0x31, 0xdd, 0x6e, 0xfc, 0x39, 0xca, 0x8d, 0x27, 0xe3, 0x51, 0xe4, 0x39, 0x41, 0x9c, 0xa9, 0x04,
	0x52, 0x21, 0x60, 0x3f, 0xce, 0x38, 0xf5, 0x0f, 0x47, 0x12, 0xb3, 0x07, 0xbf, 0x4d, 0x3e, 0xa9,
	0xf4, 0x51, 0xd7, 0x38, 0xff, 0xce, 0xf1, 0x89, 0x6a, 0x37, 0xbc, 0x0d, 0x94, 0x87, 0xae, 0xa8,
	0x5f, 0x7e, 0x10, 0x62, 0xf7, 0x7c, 0x0a, 0xf5, 0xdc, 0x4e, 0xea, 0xb9, 0xce, 0x39, 0xa4, 0xa6,
	0x61, 0xd5, 0x9e, 0x36, 0xa1, 0x1c, 0x8d, 0x42, 0x95, 0x3c, 0xf0, 0x93, 0x1f, 0xa1, 0xcc, 0xd3,
	0xd9, 0xd5, 0xf9, 0x62, 0x82, 0x14, 0x0a, 0x29, 0xe9, 0x66, 0x7e, 0xec, 0x24, 0xae, 0x74, 0xc3,
	0x4d, 0x95, 0x3a, 0x54, 0x21, 0x65, 0x23, 0xe5, 0x90, 0x08, 0x37, 0xf3, 0x6f, 0xa9, 0x94, 0x72,
	0x8d, 0x7f, 0x6b, 0xca, 0x3b, 0xfc, 0x48, 0x19, 0xeb, 0xce, 0x94, 0x77, 0xf8, 0x11, 0x1b, 0xab,
	0x68, 0xd7, 0x9c, 0xf5, 0xee, 0x94, 0x5d, 0x35, 0xeb, 0x1d, 0xa8, 0xd0, 0x4f, 0x1d, 0xe8, 0x43,
	0xf7, 0x38, 0x6b, 0x89, 0xc8, 0xd3, 0xbf, 0x82, 0xb0, 0x0d, 0xf9, 0x57, 0x00, 0xb2, 0x39, 0xe7,
	0x9e, 0x1a, 0xe1, 0x64, 0x3a, 0xb2, 0xf9, 0x63, 0xc8, 0xb3, 0x00, 0xcf, 0x74, 0x9f, 0xbd, 0x51,
	0x83, 0xda, 0x1b, 0xd5, 0x79, 0x29, 0x40, 0x1e, 0xb0, 0x02, 0x19, 0x52, 0xe1, 0x01, 0xda, 0x9e,
	0x9d, 0x5d, 0x7a, 0x21, 0x90, 0xed, 0x34, 0x42, 0xbf, 0xe1, 0x68, 0x3f, 0xc0, 0xe4, 0xe7, 0x1c,
	0x23, 0xdf, 0x23, 0xe2, 0xcb, 0x3d, 0x04, 0x93, 0xfb, 0x0e, 0x72, 0x17, 0x23, 0x92, 0xdc, 0xff,
	0xeb, 0xe9, 0x88, 0xa4, 0x00, 0xf8, 0x0e, 0x0a, 0xbf, 0x05, 0xe4, 0xce, 0xd5, 0x64, 0x13, 0x4c,
	0x28, 0xca, 0xbd, 0x36, 0xfe, 0xa7, 0x04, 0x8b, 0xc5, 0x1f, 0xa7, 0xad, 0x0a, 0xcc, 0xf6, 0xdf,
	0xef, 0xb5, 0xcd, 0x5b, 0xf8, 0xd5, 0xfa, 0x63, 0xab, 0x6d, 0x96, 0xac, 0x05, 0x28, 0xef, 0xb6,
	0xda, 0xe6, 0x8c, 0x65, 0xc0, 0x5c, 0x6b, 0x6f, 0xaf, 0xfd, 0xc9, 0x2c, 0x23, 0xd6, 0xef, 0xb7,
	0xcd, 0x59, 0xfa, 0xf8, 0x63, 0xdb, 0x9c, 0xc3, 0x8f, 0xf7, 0x1f, 0x7e, 0x34, 0xe7, 0x51, 0xf0,
	0xfd, 0x87, 0xbd, 0xb6, 0xb9, 0x80, 0xfc, 0x9d, 0x83, 0xdd, 0xf6, 0x27, 0xb3, 0x62, 0xd5, 0x00,
	0x7a, 0x87, 0x83, 0x4e, 0xef, 0xc0, 0x41, 0x31, 0x03, 0x99, 0x0e, 0x7e, 0xea, 0xb6, 0x4d, 0xc0,
	0xaf, 0x1f, 0xf7, 0x77, 0x3e, 0x99, 0x55, 0x5a, 0x71, 0xa7, 0x37, 0x30, 0x17, 0x71, 0xae, 0x56,
	0xb7, 0x6d, 0x2e, 0xd1, 0x8a, 0xbd, 0x6e, 0xfb, 0x93, 0x59, 0xc3, 0xcf, 0xf6, 0x91, 0xdd, 0xfe,
	0x64, 0xd6, 0x91, 0xdc, 0x39, 0x6c, 0x9b, 0x26, 0x62, 0xfb, 0x9d, 0xbd, 0xbd, 0xb6, 0xb9, 0x8c,
	0xd8, 0x7e, 0xb7, 0x6d, 0x5a, 0xb4, 0xa1, 0x1f, 0x3f, 0x99, 0x2b, 0x38, 0xdd, 0x6e, 0xbb, 0xdb,
	0x33, 0x57, 0x89, 0xff, 0xa0, 0x6d, 0xde, 0xb6, 0x96, 0xc0, 0xe8, 0x1c, 0x7c, 0xdc, 0xde, 0xef,
	0xe0, 0xa6, 0xd6, 0x36, 0xfe, 0xb9, 0x94, 0xf7, 0xc5, 0xe9, 0xf0, 0x4b, 0x60, 0x1c, 0x0e, 0x9c,
	0xa3, 0x83, 0x0f, 0xbd, 0x3f, 0x1c, 0x98, 0xb7, 0xd4, 0x70, 0xef, 0x68, 0x70, 0x64, 0xa3, 0x1a,
	0x16, 0xa1, 0x72, 0x38, 0x70, 0xfa, 0x83, 0x5e, 0xeb, 0x83, 0x39, 0x63, 0x55, 0x61, 0xe1, 0x70,
	0xe0, 0xec, 0xf4, 0x0e, 0x76, 0xcd, 0xb2, 0x65, 0x41, 0xed, 0x70, 0xe0, 0xb4, 0x7a, 0xdd, 0x9d,
	0xce, 0xc1, 0x36, 0x9e, 0xd2, 0x9c, 0x55, 0xd2, 0x7c, 0x68, 0x73, 0xce, 0x5a, 0x05, 0x33, 0x9f,
	0x4c, 0xa3, 0xf3, 0xd6, 0x0a, 0xd4, 0xf5, 0x9c, 0x1a, 0x5c, 0xb0, 0x6e, 0xc3, 0x32, 0x82, 0xfd,
	0xb6, 0xd3, 0x1e, 0xec, 0x69, 0xb8, 0xb2, 0x91, 0x02, 0x4c, 0x7e, 0x1a, 0xc7, 0xd3, 0x0d, 0x3a,
	0xad, 0x0f, 0xe6, 0x2d, 0x6b, 0x1e, 0x66, 0xba, 0x9b, 0x66, 0x89, 0xfe, 0xbe, 0x35, 0x67, 0xe8,
	0xef, 0x3b, 0x36, 0x51, 0x77, 0xf3, 0x0d, 0x9b, 0xa8, 0xbb, 0xf9, 0x8e, 0x4d, 0xd4, 0x7d, 0xfb,
	0xc6, 0x9c, 0x47, 0x96, 0xf7, 0x9b, 0xe6, 0x02, 0xfd, 0x7d, 0x6b, 0x56, 0xf0, 0xef, 0xee, 0xa6,
	0x69, 0xe0, 0xdf, 0x3f, 0x6c, 0xb2, 0x4d, 0xba, 0xbd, 0x83, 0x4d, 0xb3, 0xba, 0xf1, 0x06, 0x96,
	0xaf, 0xfd, 0x30, 0x85, 0x47, 0xeb, 0xb5, 0xf0, 0xc0, 0xdb, 0xfb, 0xfb, 0xe6, 0x2d, 0x54, 0x0c,
	0x0d, 0x0f, 0x8f, 0x06, 0x66, 0x69, 0xe3, 0x09, 0xac, 0xdd, 0xfc, 0x63, 0x0c, 0xf1, 0xed, 0xee,
	0x0e, 0x9c, 0xf6, 0x91, 0x6d, 0xde, 0xda, 0xe8, 0xc3, 0x9d, 0x2b, 0xaf, 0xa4, 0xed, 0xe0, 0x34,
	0x96, 0x7e, 0x76, 0xe6, 0x87, 0xe8, 0x2e, 0xad, 0xd6, 0xb6, 0x73, 0xd0, 0xb3, 0xbb, 0xdb, 0x6a,
	0x09, 0x1c, 0xf7, 0x0e, 0xc8, 0x21, 0x1b, 0xb0, 0x8a, 0xa3, 0xee, 0xd1, 0xfe, 0xa0, 0x73, 0xb8,
	0xdf, 0x76, 0x76, 0x7e, 0x72, 0x76, 0xb7, 0x07, 0x6d, 0x73, 0x66, 0x63, 0x03, 0xaa, 0x85, 0xee,
	0x1d, 0x6e, 0xb4, 0x75, 0xa0, 0x2d, 0xc8, 0xb3, 0x1c, 0x28, 0x0b, 0x96, 0x36, 0x1e, 0xc1, 0x62,
	0xb1, 0x77, 0x47, 0x4e, 0x77, 0xf0, 0x93, 0x79, 0x0b, 0x3f, 0x8e, 0xfa, 0xbb, 0x66, 0x69, 0xc7,
	0xfc, 0xb7, 0x5f, 0x1e, 0x94, 0xfe, 0xfd, 0x97, 0x07, 0xa5, 0xff, 0xfc, 0xe5, 0x41, 0xe9, 0xef,
	0xff, 0xeb, 0xc1, 0xad, 0xe3, 0x79, 0xfa, 0x1f, 0x92, 0xb7, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff,
	0x40, 0x54, 0x49, 0x83, 0x53, 0x22, 0x00, 0x00,
}
