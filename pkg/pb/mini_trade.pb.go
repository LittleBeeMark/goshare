// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mini_trade.proto

package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MiniTradeOrder struct {
}

func (m *MiniTradeOrder) Reset()                    { *m = MiniTradeOrder{} }
func (m *MiniTradeOrder) String() string            { return proto.CompactTextString(m) }
func (*MiniTradeOrder) ProtoMessage()               {}
func (*MiniTradeOrder) Descriptor() ([]byte, []int) { return fileDescriptorMiniTrade, []int{0} }

// 微交易单元
type MiniTradeUnit struct {
	// / 合约编号
	Symbol Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	// 历史单
	HistoryOrderList []MiniTradeOrder `protobuf:"bytes,6,rep,name=history_order_list,json=historyOrderList" json:"historyOrderList"`
	// 成交
	HistoryTradeList []CTPTradeReport `protobuf:"bytes,7,rep,name=history_trade_list,json=historyTradeList" json:"historyTradeList"`
	// 最新价
	LastPrice float64 `protobuf:"fixed64,10,opt,name=last_price,json=lastPrice,proto3" json:"lastPrice"`
	// 行情更新时间
	LastMdsUpdateTime int64 `protobuf:"varint,11,opt,name=last_mds_update_time,json=lastMdsUpdateTime,proto3" json:"lastMdsUpdateTime"`
	// 合约信息
	PriceTick float64 `protobuf:"fixed64,12,opt,name=price_tick,json=priceTick,proto3" json:"priceTick"`
	// 合约乘数
	VolumeMultiple int32 `protobuf:"varint,13,opt,name=volume_multiple,json=volumeMultiple,proto3" json:"volumeMultiple"`
	// 手续费
	Cr CTPCommissionRate `protobuf:"bytes,14,opt,name=cr" json:"cr"`
	// 保证金
	Mr CTPMarginRate `protobuf:"bytes,15,opt,name=mr" json:"mr"`
}

func (m *MiniTradeUnit) Reset()                    { *m = MiniTradeUnit{} }
func (m *MiniTradeUnit) String() string            { return proto.CompactTextString(m) }
func (*MiniTradeUnit) ProtoMessage()               {}
func (*MiniTradeUnit) Descriptor() ([]byte, []int) { return fileDescriptorMiniTrade, []int{1} }

func (m *MiniTradeUnit) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *MiniTradeUnit) GetHistoryOrderList() []MiniTradeOrder {
	if m != nil {
		return m.HistoryOrderList
	}
	return nil
}

func (m *MiniTradeUnit) GetHistoryTradeList() []CTPTradeReport {
	if m != nil {
		return m.HistoryTradeList
	}
	return nil
}

func (m *MiniTradeUnit) GetLastPrice() float64 {
	if m != nil {
		return m.LastPrice
	}
	return 0
}

func (m *MiniTradeUnit) GetLastMdsUpdateTime() int64 {
	if m != nil {
		return m.LastMdsUpdateTime
	}
	return 0
}

func (m *MiniTradeUnit) GetPriceTick() float64 {
	if m != nil {
		return m.PriceTick
	}
	return 0
}

func (m *MiniTradeUnit) GetVolumeMultiple() int32 {
	if m != nil {
		return m.VolumeMultiple
	}
	return 0
}

func (m *MiniTradeUnit) GetCr() CTPCommissionRate {
	if m != nil {
		return m.Cr
	}
	return CTPCommissionRate{}
}

func (m *MiniTradeUnit) GetMr() CTPMarginRate {
	if m != nil {
		return m.Mr
	}
	return CTPMarginRate{}
}

// 微交易结算
type MiniTradeAccount struct {
	// 合计
	Summary AccountMoneySummary `protobuf:"bytes,1,opt,name=summary" json:"summary"`
	// 出入金
	MtrList []MoneyTransferRecord `protobuf:"bytes,2,rep,name=mtr_list,json=mtrList" json:"mtrList"`
	// 交易明细
	TuList []MiniTradeUnit `protobuf:"bytes,3,rep,name=tu_list,json=tuList" json:"tuList"`
	// 最后结算日期
	LastSettleDate int32 `protobuf:"varint,4,opt,name=last_settle_date,json=lastSettleDate,proto3" json:"lastSettleDate"`
}

func (m *MiniTradeAccount) Reset()                    { *m = MiniTradeAccount{} }
func (m *MiniTradeAccount) String() string            { return proto.CompactTextString(m) }
func (*MiniTradeAccount) ProtoMessage()               {}
func (*MiniTradeAccount) Descriptor() ([]byte, []int) { return fileDescriptorMiniTrade, []int{2} }

func (m *MiniTradeAccount) GetSummary() AccountMoneySummary {
	if m != nil {
		return m.Summary
	}
	return AccountMoneySummary{}
}

func (m *MiniTradeAccount) GetMtrList() []MoneyTransferRecord {
	if m != nil {
		return m.MtrList
	}
	return nil
}

func (m *MiniTradeAccount) GetTuList() []MiniTradeUnit {
	if m != nil {
		return m.TuList
	}
	return nil
}

func (m *MiniTradeAccount) GetLastSettleDate() int32 {
	if m != nil {
		return m.LastSettleDate
	}
	return 0
}

func init() {
	proto.RegisterType((*MiniTradeOrder)(nil), "pb.MiniTradeOrder")
	proto.RegisterType((*MiniTradeUnit)(nil), "pb.MiniTradeUnit")
	proto.RegisterType((*MiniTradeAccount)(nil), "pb.MiniTradeAccount")
}
func (m *MiniTradeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiniTradeOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MiniTradeUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiniTradeUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMiniTrade(dAtA, i, uint64(m.Symbol.Size()))
	n1, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.HistoryOrderList) > 0 {
		for _, msg := range m.HistoryOrderList {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMiniTrade(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HistoryTradeList) > 0 {
		for _, msg := range m.HistoryTradeList {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMiniTrade(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastPrice != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64MiniTrade(dAtA, i, uint64(math.Float64bits(float64(m.LastPrice))))
	}
	if m.LastMdsUpdateTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMiniTrade(dAtA, i, uint64(m.LastMdsUpdateTime))
	}
	if m.PriceTick != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64MiniTrade(dAtA, i, uint64(math.Float64bits(float64(m.PriceTick))))
	}
	if m.VolumeMultiple != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMiniTrade(dAtA, i, uint64(m.VolumeMultiple))
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintMiniTrade(dAtA, i, uint64(m.Cr.Size()))
	n2, err := m.Cr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x7a
	i++
	i = encodeVarintMiniTrade(dAtA, i, uint64(m.Mr.Size()))
	n3, err := m.Mr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *MiniTradeAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiniTradeAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMiniTrade(dAtA, i, uint64(m.Summary.Size()))
	n4, err := m.Summary.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.MtrList) > 0 {
		for _, msg := range m.MtrList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMiniTrade(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TuList) > 0 {
		for _, msg := range m.TuList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMiniTrade(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastSettleDate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMiniTrade(dAtA, i, uint64(m.LastSettleDate))
	}
	return i, nil
}

func encodeFixed64MiniTrade(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32MiniTrade(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMiniTrade(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MiniTradeOrder) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MiniTradeUnit) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovMiniTrade(uint64(l))
	if len(m.HistoryOrderList) > 0 {
		for _, e := range m.HistoryOrderList {
			l = e.Size()
			n += 1 + l + sovMiniTrade(uint64(l))
		}
	}
	if len(m.HistoryTradeList) > 0 {
		for _, e := range m.HistoryTradeList {
			l = e.Size()
			n += 1 + l + sovMiniTrade(uint64(l))
		}
	}
	if m.LastPrice != 0 {
		n += 9
	}
	if m.LastMdsUpdateTime != 0 {
		n += 1 + sovMiniTrade(uint64(m.LastMdsUpdateTime))
	}
	if m.PriceTick != 0 {
		n += 9
	}
	if m.VolumeMultiple != 0 {
		n += 1 + sovMiniTrade(uint64(m.VolumeMultiple))
	}
	l = m.Cr.Size()
	n += 1 + l + sovMiniTrade(uint64(l))
	l = m.Mr.Size()
	n += 1 + l + sovMiniTrade(uint64(l))
	return n
}

func (m *MiniTradeAccount) Size() (n int) {
	var l int
	_ = l
	l = m.Summary.Size()
	n += 1 + l + sovMiniTrade(uint64(l))
	if len(m.MtrList) > 0 {
		for _, e := range m.MtrList {
			l = e.Size()
			n += 1 + l + sovMiniTrade(uint64(l))
		}
	}
	if len(m.TuList) > 0 {
		for _, e := range m.TuList {
			l = e.Size()
			n += 1 + l + sovMiniTrade(uint64(l))
		}
	}
	if m.LastSettleDate != 0 {
		n += 1 + sovMiniTrade(uint64(m.LastSettleDate))
	}
	return n
}

func sovMiniTrade(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMiniTrade(x uint64) (n int) {
	return sovMiniTrade(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MiniTradeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMiniTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiniTradeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiniTradeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMiniTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMiniTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiniTradeUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMiniTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiniTradeUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiniTradeUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryOrderList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryOrderList = append(m.HistoryOrderList, MiniTradeOrder{})
			if err := m.HistoryOrderList[len(m.HistoryOrderList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryTradeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryTradeList = append(m.HistoryTradeList, CTPTradeReport{})
			if err := m.HistoryTradeList[len(m.HistoryTradeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LastPrice = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMdsUpdateTime", wireType)
			}
			m.LastMdsUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMdsUpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTick", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PriceTick = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMultiple", wireType)
			}
			m.VolumeMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeMultiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Mr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMiniTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMiniTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiniTradeAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMiniTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiniTradeAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiniTradeAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtrList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MtrList = append(m.MtrList, MoneyTransferRecord{})
			if err := m.MtrList[len(m.MtrList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TuList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMiniTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TuList = append(m.TuList, MiniTradeUnit{})
			if err := m.TuList[len(m.TuList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSettleDate", wireType)
			}
			m.LastSettleDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSettleDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMiniTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMiniTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMiniTrade(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMiniTrade
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMiniTrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMiniTrade
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMiniTrade
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMiniTrade(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMiniTrade = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMiniTrade   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mini_trade.proto", fileDescriptorMiniTrade) }

var fileDescriptorMiniTrade = []byte{
	// 457 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x92, 0x41, 0x8e, 0xd3, 0x30,
	0x14, 0x86, 0x71, 0x0b, 0x2d, 0xf3, 0x3a, 0xd3, 0x49, 0x2d, 0x10, 0xd1, 0x48, 0x54, 0xa1, 0x12,
	0x22, 0x62, 0x51, 0x44, 0xb9, 0x00, 0x30, 0x2c, 0x89, 0x18, 0xb9, 0x99, 0x75, 0x94, 0x3a, 0x06,
	0xac, 0x89, 0xe3, 0xc8, 0x7e, 0x41, 0xea, 0x2d, 0xd8, 0x72, 0x23, 0x76, 0x70, 0x04, 0x54, 0x2e,
	0x82, 0xfc, 0x12, 0x0a, 0xb3, 0x4b, 0xbe, 0xff, 0x7f, 0x7f, 0xe2, 0xff, 0x19, 0x22, 0xa3, 0x1b,
	0x5d, 0xa0, 0x2b, 0x2b, 0xb5, 0x6e, 0x9d, 0x45, 0xcb, 0x47, 0xed, 0xee, 0xe2, 0x54, 0x5a, 0x63,
	0x6c, 0xd3, 0x93, 0x8b, 0x13, 0x89, 0x6d, 0xff, 0xb8, 0x8a, 0x60, 0x9e, 0xe9, 0x46, 0xe7, 0xc1,
	0xff, 0xc1, 0x55, 0xca, 0xad, 0xbe, 0x8d, 0xe1, 0xec, 0x88, 0xae, 0x1b, 0x8d, 0x7c, 0x05, 0x13,
	0xbf, 0x37, 0x3b, 0x5b, 0xc7, 0x2c, 0x61, 0xe9, 0x6c, 0x03, 0xeb, 0x76, 0xb7, 0xde, 0x12, 0x11,
	0x83, 0xc2, 0x5f, 0x03, 0xff, 0xac, 0x3d, 0x5a, 0xb7, 0x2f, 0x6c, 0x88, 0x29, 0x6a, 0xed, 0x31,
	0x9e, 0x24, 0xe3, 0x74, 0xb6, 0xe1, 0xc1, 0x7f, 0xfb, 0x2b, 0x22, 0x1a, 0xdc, 0xf4, 0xf6, 0x5e,
	0x7b, 0xfc, 0x3f, 0x81, 0xfe, 0xbe, 0x4f, 0x98, 0xfe, 0x4b, 0xb8, 0xcc, 0xaf, 0x28, 0x40, 0xa8,
	0xd6, 0x3a, 0x3c, 0x26, 0x10, 0xa3, 0x84, 0xc7, 0x00, 0x75, 0xe9, 0xb1, 0x68, 0x9d, 0x96, 0x2a,
	0x86, 0x84, 0xa5, 0x4c, 0x9c, 0x04, 0x72, 0x15, 0x00, 0x7f, 0x01, 0x0f, 0x48, 0x36, 0x95, 0x2f,
	0xba, 0xb6, 0x2a, 0x51, 0x15, 0xa8, 0x8d, 0x8a, 0x67, 0x09, 0x4b, 0xc7, 0x62, 0x11, 0xb4, 0xac,
	0xf2, 0xd7, 0xa4, 0xe4, 0xda, 0xa8, 0x90, 0x47, 0x51, 0x05, 0x6a, 0x79, 0x13, 0x9f, 0xf6, 0x79,
	0x44, 0x72, 0x2d, 0x6f, 0xf8, 0x33, 0x38, 0xff, 0x62, 0xeb, 0xce, 0xa8, 0xc2, 0x74, 0x35, 0xea,
	0xb6, 0x56, 0xf1, 0x59, 0xc2, 0xd2, 0x7b, 0x62, 0xde, 0xe3, 0x6c, 0xa0, 0xfc, 0x29, 0x8c, 0xa4,
	0x8b, 0xe7, 0xd4, 0xdd, 0xc3, 0xe1, 0x24, 0x97, 0xd6, 0x18, 0xed, 0xbd, 0xb6, 0x8d, 0x28, 0x51,
	0x89, 0x91, 0x74, 0xfc, 0x09, 0x8c, 0x8c, 0x8b, 0xcf, 0xc9, 0xb6, 0x18, 0x6c, 0x59, 0xe9, 0x3e,
	0xe9, 0xc1, 0x62, 0xdc, 0xea, 0x07, 0x83, 0xe8, 0x58, 0xe4, 0x1b, 0x29, 0x6d, 0xd7, 0x20, 0x7f,
	0x09, 0x53, 0xdf, 0x19, 0x53, 0xba, 0xfd, 0xb0, 0x9f, 0x47, 0x61, 0x78, 0x50, 0x33, 0xdb, 0xa8,
	0xfd, 0xb6, 0x97, 0xc5, 0x5f, 0x1f, 0xdf, 0xc0, 0x7d, 0x83, 0xc3, 0x8e, 0x46, 0xd4, 0x30, 0xcd,
	0x90, 0x39, 0x77, 0x65, 0xe3, 0x3f, 0x2a, 0x27, 0x94, 0xb4, 0xae, 0x12, 0x53, 0x83, 0xfd, 0x7e,
	0x9e, 0xc3, 0x14, 0xbb, 0x7e, 0x64, 0x4c, 0x23, 0x8b, 0x5b, 0x6b, 0x0d, 0x37, 0x45, 0x4c, 0xb0,
	0x23, 0x6f, 0x0a, 0x11, 0x55, 0xed, 0x15, 0x62, 0xad, 0x8a, 0xd0, 0x68, 0x7c, 0xb7, 0xef, 0x26,
	0xf0, 0x2d, 0xe1, 0x77, 0x25, 0xaa, 0xb7, 0xd1, 0xf7, 0xc3, 0x92, 0xfd, 0x3c, 0x2c, 0xd9, 0xaf,
	0xc3, 0x92, 0x7d, 0xfd, 0xbd, 0xbc, 0xb3, 0x9b, 0xd0, 0xc5, 0x7c, 0xf5, 0x27, 0x00, 0x00, 0xff,
	0xff, 0x08, 0xa9, 0x7c, 0x00, 0xc9, 0x02, 0x00, 0x00,
}
