// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ctp.proto

package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 方向
type CTPDirection int32

const (
	CTPDirection_LONG  CTPDirection = 0
	CTPDirection_SHORT CTPDirection = 1
)

var CTPDirection_name = map[int32]string{
	0: "LONG",
	1: "SHORT",
}
var CTPDirection_value = map[string]int32{
	"LONG":  0,
	"SHORT": 1,
}

func (x CTPDirection) String() string {
	return proto.EnumName(CTPDirection_name, int32(x))
}
func (CTPDirection) EnumDescriptor() ([]byte, []int) { return fileDescriptorCtp, []int{0} }

// 状态
type CTPOrderStatus int32

const (
	// 完全成交
	CTPOrderStatus_DONE CTPOrderStatus = 0
	// 部分成交还在队列中
	CTPOrderStatus_PENDING_WITH_PARTIAL_DONE CTPOrderStatus = 1
	// 部分成交且已撤单
	CTPOrderStatus_CANCELED_WITH_PARTIAL_DONE CTPOrderStatus = 2
	// 队列中
	CTPOrderStatus_PENDING CTPOrderStatus = 3
	// 已经撤单
	CTPOrderStatus_CANCELED CTPOrderStatus = 4
	// 未知
	CTPOrderStatus_UNKOWN CTPOrderStatus = 5
)

var CTPOrderStatus_name = map[int32]string{
	0: "DONE",
	1: "PENDING_WITH_PARTIAL_DONE",
	2: "CANCELED_WITH_PARTIAL_DONE",
	3: "PENDING",
	4: "CANCELED",
	5: "UNKOWN",
}
var CTPOrderStatus_value = map[string]int32{
	"DONE": 0,
	"PENDING_WITH_PARTIAL_DONE":  1,
	"CANCELED_WITH_PARTIAL_DONE": 2,
	"PENDING":                    3,
	"CANCELED":                   4,
	"UNKOWN":                     5,
}

func (x CTPOrderStatus) String() string {
	return proto.EnumName(CTPOrderStatus_name, int32(x))
}
func (CTPOrderStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorCtp, []int{1} }

type CTPPriceType int32

const (
	// 限价
	CTPPriceType_LIMIT_PRICE CTPPriceType = 0
	// 市价
	CTPPriceType_MARKET_PRICE CTPPriceType = 1
	// 最优价
	CTPPriceType_BEST_PRICE CTPPriceType = 2
	// 最新价
	CTPPriceType_LAST_PRICE CTPPriceType = 3
)

var CTPPriceType_name = map[int32]string{
	0: "LIMIT_PRICE",
	1: "MARKET_PRICE",
	2: "BEST_PRICE",
	3: "LAST_PRICE",
}
var CTPPriceType_value = map[string]int32{
	"LIMIT_PRICE":  0,
	"MARKET_PRICE": 1,
	"BEST_PRICE":   2,
	"LAST_PRICE":   3,
}

func (x CTPPriceType) String() string {
	return proto.EnumName(CTPPriceType_name, int32(x))
}
func (CTPPriceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCtp, []int{2} }

type CTPOffsetFlag int32

const (
	CTPOffsetFlag_NONE CTPOffsetFlag = 0
	// 开仓
	CTPOffsetFlag_OPEN CTPOffsetFlag = 1
	// 平仓
	CTPOffsetFlag_CLOSE CTPOffsetFlag = 2
	// 强平
	CTPOffsetFlag_FORCE_CLOSE CTPOffsetFlag = 3
	// 平今
	CTPOffsetFlag_CLOSE_TODAY CTPOffsetFlag = 4
	// 平昨
	CTPOffsetFlag_CLOSE_YESTERDAY CTPOffsetFlag = 5
)

var CTPOffsetFlag_name = map[int32]string{
	0: "NONE",
	1: "OPEN",
	2: "CLOSE",
	3: "FORCE_CLOSE",
	4: "CLOSE_TODAY",
	5: "CLOSE_YESTERDAY",
}
var CTPOffsetFlag_value = map[string]int32{
	"NONE":            0,
	"OPEN":            1,
	"CLOSE":           2,
	"FORCE_CLOSE":     3,
	"CLOSE_TODAY":     4,
	"CLOSE_YESTERDAY": 5,
}

func (x CTPOffsetFlag) String() string {
	return proto.EnumName(CTPOffsetFlag_name, int32(x))
}
func (CTPOffsetFlag) EnumDescriptor() ([]byte, []int) { return fileDescriptorCtp, []int{3} }

// 投机套保标志
type CTPHedgeType int32

const (
	// 投机
	CTPHedgeType_SPECULATION CTPHedgeType = 0
	// 套利
	CTPHedgeType_ARBITRAGE CTPHedgeType = 1
	// 套保
	CTPHedgeType_HEDGE CTPHedgeType = 2
)

var CTPHedgeType_name = map[int32]string{
	0: "SPECULATION",
	1: "ARBITRAGE",
	2: "HEDGE",
}
var CTPHedgeType_value = map[string]int32{
	"SPECULATION": 0,
	"ARBITRAGE":   1,
	"HEDGE":       2,
}

func (x CTPHedgeType) String() string {
	return proto.EnumName(CTPHedgeType_name, int32(x))
}
func (CTPHedgeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCtp, []int{4} }

// 成交类型
type CTPTradeType int32

const (
	// 普通成交
	CTPTradeType_NORMAL CTPTradeType = 0
	// 期权执行
	CTPTradeType_OPTIONS_EXECUTION CTPTradeType = 1
	// OTC成交
	CTPTradeType_OTC CTPTradeType = 2
	// 期转现衍生成交
	CTPTradeType_EFP_DERIVED CTPTradeType = 3
	// 组合衍生成交
	CTPTradeType_COMBINATION_DERIVED CTPTradeType = 4
	// 交割平仓
	CTPTradeType_DELIVERY_CLOSE CTPTradeType = 5
	// 结算衍生
	CTPTradeType_SETTLEMENT_DERIVED CTPTradeType = 6
	// 分红股票
	CTPTradeType_PLACEMENT_DERIVED CTPTradeType = 7
)

var CTPTradeType_name = map[int32]string{
	0: "NORMAL",
	1: "OPTIONS_EXECUTION",
	2: "OTC",
	3: "EFP_DERIVED",
	4: "COMBINATION_DERIVED",
	5: "DELIVERY_CLOSE",
	6: "SETTLEMENT_DERIVED",
	7: "PLACEMENT_DERIVED",
}
var CTPTradeType_value = map[string]int32{
	"NORMAL":              0,
	"OPTIONS_EXECUTION":   1,
	"OTC":                 2,
	"EFP_DERIVED":         3,
	"COMBINATION_DERIVED": 4,
	"DELIVERY_CLOSE":      5,
	"SETTLEMENT_DERIVED":  6,
	"PLACEMENT_DERIVED":   7,
}

func (x CTPTradeType) String() string {
	return proto.EnumName(CTPTradeType_name, int32(x))
}
func (CTPTradeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCtp, []int{5} }

// 报单ID
type CTPOrderID struct {
	FrontId   int64  `protobuf:"varint,1,opt,name=front_id,json=frontId,proto3" json:"frontId"`
	SessionId int64  `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"sessionId"`
	OrderRef  int64  `protobuf:"varint,3,opt,name=order_ref,json=orderRef,proto3" json:"orderRef"`
	StringId  string `protobuf:"bytes,4,opt,name=string_id,json=stringId,proto3" json:"stringId"`
}

func (m *CTPOrderID) Reset()                    { *m = CTPOrderID{} }
func (m *CTPOrderID) String() string            { return proto.CompactTextString(m) }
func (*CTPOrderID) ProtoMessage()               {}
func (*CTPOrderID) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{0} }

func (m *CTPOrderID) GetFrontId() int64 {
	if m != nil {
		return m.FrontId
	}
	return 0
}

func (m *CTPOrderID) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *CTPOrderID) GetOrderRef() int64 {
	if m != nil {
		return m.OrderRef
	}
	return 0
}

func (m *CTPOrderID) GetStringId() string {
	if m != nil {
		return m.StringId
	}
	return ""
}

// 委托
type CTPOrder struct {
	// 合约
	Symbol Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	// ID
	Id CTPOrderID `protobuf:"bytes,2,opt,name=id" json:"id"`
	// 账号
	AccountId string `protobuf:"bytes,3,opt,name=account_id,json=accountId,proto3" json:"accountId"`
	// 方向
	Direction CTPDirection `protobuf:"varint,4,opt,name=direction,proto3,enum=pb.CTPDirection" json:"direction"`
	// 状态
	Status CTPOrderStatus `protobuf:"varint,5,opt,name=status,proto3,enum=pb.CTPOrderStatus" json:"status"`
	// 价格类型
	PriceType CTPPriceType `protobuf:"varint,6,opt,name=price_type,json=priceType,proto3,enum=pb.CTPPriceType" json:"priceType"`
	// 限价
	LimitPrice float64 `protobuf:"fixed64,7,opt,name=limit_price,json=limitPrice,proto3" json:"limitPrice"`
	// 数量
	Volume int32 `protobuf:"varint,8,opt,name=volume,proto3" json:"volume"`
	// 成交数量
	VolumeTraded int32 `protobuf:"varint,9,opt,name=volume_traded,json=volumeTraded,proto3" json:"volumeTraded"`
	// 撤单数量
	VolumeCanceled int32 `protobuf:"varint,10,opt,name=volume_canceled,json=volumeCanceled,proto3" json:"volumeCanceled"`
	// 冻结手续费
	FrozenCommission float64 `protobuf:"fixed64,11,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozenCommission"`
	// 发送时间（成交时间)
	SendOrderTime int64 `protobuf:"varint,12,opt,name=send_order_time,json=sendOrderTime,proto3" json:"sendOrderTime"`
	// 交易日
	SendOrderTradingDay int32 `protobuf:"varint,13,opt,name=send_order_trading_day,json=sendOrderTradingDay,proto3" json:"sendOrderTradingDay"`
	// 备注
	Comment string `protobuf:"bytes,14,opt,name=comment,proto3" json:"comment"`
	// 请求编号
	RequestId int32 `protobuf:"varint,15,opt,name=request_id,json=requestId,proto3" json:"requestId"`
	// 序号
	LocalOrderSeq int32 `protobuf:"varint,16,opt,name=local_order_seq,json=localOrderSeq,proto3" json:"localOrderSeq"`
	// 强平类型
	ForceCloseType int32 `protobuf:"varint,17,opt,name=force_close_type,json=forceCloseType,proto3" json:"forceCloseType"`
	// 来源
	OrderSourceType int32 `protobuf:"varint,18,opt,name=order_source_type,json=orderSourceType,proto3" json:"orderSourceType"`
	// 投机套保类型
	OrderHedgeType CTPHedgeType `protobuf:"varint,19,opt,name=order_hedge_type,json=orderHedgeType,proto3,enum=pb.CTPHedgeType" json:"orderHedgeType"`
	// 产品标识
	UserProductInfo string `protobuf:"bytes,20,opt,name=user_product_info,json=userProductInfo,proto3" json:"userProductInfo"`
	// 币种
	CurrencyType CurrencyType `protobuf:"varint,21,opt,name=currency_type,json=currencyType,proto3,enum=pb.CurrencyType" json:"currencyType"`
	// 交易所ID
	ExchangeOrderId string `protobuf:"bytes,22,opt,name=exchange_order_id,json=exchangeOrderId,proto3" json:"exchangeOrderId"`
	// 有效期类型
	TimeConditionType int32 `protobuf:"varint,23,opt,name=time_condition_type,json=timeConditionType,proto3" json:"timeConditionType"`
	// 主帐户
	RouteAccountId string `protobuf:"bytes,24,opt,name=route_account_id,json=routeAccountId,proto3" json:"routeAccountId"`
	// 本地编号类型
	LocalTypeId int32 `protobuf:"varint,25,opt,name=local_type_id,json=localTypeId,proto3" json:"localTypeId"`
	// 委托收费
	Commission float64 `protobuf:"fixed64,26,opt,name=commission,proto3" json:"commission"`
	// 开平标志
	OffsetFlag CTPOffsetFlag `protobuf:"varint,27,opt,name=offset_flag,json=offsetFlag,proto3,enum=pb.CTPOffsetFlag" json:"offsetFlag"`
	// 错误代码
	ErrorCode int32 `protobuf:"varint,28,opt,name=error_code,json=errorCode,proto3" json:"errorCode"`
	// token
	Token string `protobuf:"bytes,29,opt,name=token,proto3" json:"token"`
	// 止损
	Stoploss float64 `protobuf:"fixed64,30,opt,name=stoploss,proto3" json:"stoploss"`
	// 止赢
	TakeProfit float64 `protobuf:"fixed64,31,opt,name=take_profit,json=takeProfit,proto3" json:"takeProfit"`
	// 成交金额
	TradedAmount float64 `protobuf:"fixed64,32,opt,name=traded_amount,json=tradedAmount,proto3" json:"tradedAmount"`
	// 合约乘数
	VolumeMultiple int32 `protobuf:"varint,33,opt,name=volume_multiple,json=volumeMultiple,proto3" json:"volumeMultiple"`
	// 产品
	ProductId ProductID `protobuf:"bytes,34,opt,name=product_id,json=productId" json:"productId"`
	// 最小变动价位
	PriceTick float64 `protobuf:"fixed64,35,opt,name=price_tick,json=priceTick,proto3" json:"priceTick"`
	// 冻结合计
	FrozenMargin float64 `protobuf:"fixed64,36,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozenMargin"`
	// 合约名称
	SymbolName string `protobuf:"bytes,37,opt,name=symbol_name,json=symbolName,proto3" json:"symbolName"`
	// 发送原因备注
	ReasonComment string `protobuf:"bytes,38,opt,name=reason_comment,json=reasonComment,proto3" json:"reasonComment"`
}

func (m *CTPOrder) Reset()                    { *m = CTPOrder{} }
func (m *CTPOrder) String() string            { return proto.CompactTextString(m) }
func (*CTPOrder) ProtoMessage()               {}
func (*CTPOrder) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{1} }

func (m *CTPOrder) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *CTPOrder) GetId() CTPOrderID {
	if m != nil {
		return m.Id
	}
	return CTPOrderID{}
}

func (m *CTPOrder) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *CTPOrder) GetDirection() CTPDirection {
	if m != nil {
		return m.Direction
	}
	return CTPDirection_LONG
}

func (m *CTPOrder) GetStatus() CTPOrderStatus {
	if m != nil {
		return m.Status
	}
	return CTPOrderStatus_DONE
}

func (m *CTPOrder) GetPriceType() CTPPriceType {
	if m != nil {
		return m.PriceType
	}
	return CTPPriceType_LIMIT_PRICE
}

func (m *CTPOrder) GetLimitPrice() float64 {
	if m != nil {
		return m.LimitPrice
	}
	return 0
}

func (m *CTPOrder) GetVolume() int32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *CTPOrder) GetVolumeTraded() int32 {
	if m != nil {
		return m.VolumeTraded
	}
	return 0
}

func (m *CTPOrder) GetVolumeCanceled() int32 {
	if m != nil {
		return m.VolumeCanceled
	}
	return 0
}

func (m *CTPOrder) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *CTPOrder) GetSendOrderTime() int64 {
	if m != nil {
		return m.SendOrderTime
	}
	return 0
}

func (m *CTPOrder) GetSendOrderTradingDay() int32 {
	if m != nil {
		return m.SendOrderTradingDay
	}
	return 0
}

func (m *CTPOrder) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *CTPOrder) GetRequestId() int32 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *CTPOrder) GetLocalOrderSeq() int32 {
	if m != nil {
		return m.LocalOrderSeq
	}
	return 0
}

func (m *CTPOrder) GetForceCloseType() int32 {
	if m != nil {
		return m.ForceCloseType
	}
	return 0
}

func (m *CTPOrder) GetOrderSourceType() int32 {
	if m != nil {
		return m.OrderSourceType
	}
	return 0
}

func (m *CTPOrder) GetOrderHedgeType() CTPHedgeType {
	if m != nil {
		return m.OrderHedgeType
	}
	return CTPHedgeType_SPECULATION
}

func (m *CTPOrder) GetUserProductInfo() string {
	if m != nil {
		return m.UserProductInfo
	}
	return ""
}

func (m *CTPOrder) GetCurrencyType() CurrencyType {
	if m != nil {
		return m.CurrencyType
	}
	return CurrencyType_CNY
}

func (m *CTPOrder) GetExchangeOrderId() string {
	if m != nil {
		return m.ExchangeOrderId
	}
	return ""
}

func (m *CTPOrder) GetTimeConditionType() int32 {
	if m != nil {
		return m.TimeConditionType
	}
	return 0
}

func (m *CTPOrder) GetRouteAccountId() string {
	if m != nil {
		return m.RouteAccountId
	}
	return ""
}

func (m *CTPOrder) GetLocalTypeId() int32 {
	if m != nil {
		return m.LocalTypeId
	}
	return 0
}

func (m *CTPOrder) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *CTPOrder) GetOffsetFlag() CTPOffsetFlag {
	if m != nil {
		return m.OffsetFlag
	}
	return CTPOffsetFlag_NONE
}

func (m *CTPOrder) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *CTPOrder) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CTPOrder) GetStoploss() float64 {
	if m != nil {
		return m.Stoploss
	}
	return 0
}

func (m *CTPOrder) GetTakeProfit() float64 {
	if m != nil {
		return m.TakeProfit
	}
	return 0
}

func (m *CTPOrder) GetTradedAmount() float64 {
	if m != nil {
		return m.TradedAmount
	}
	return 0
}

func (m *CTPOrder) GetVolumeMultiple() int32 {
	if m != nil {
		return m.VolumeMultiple
	}
	return 0
}

func (m *CTPOrder) GetProductId() ProductID {
	if m != nil {
		return m.ProductId
	}
	return ProductID{}
}

func (m *CTPOrder) GetPriceTick() float64 {
	if m != nil {
		return m.PriceTick
	}
	return 0
}

func (m *CTPOrder) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *CTPOrder) GetSymbolName() string {
	if m != nil {
		return m.SymbolName
	}
	return ""
}

func (m *CTPOrder) GetReasonComment() string {
	if m != nil {
		return m.ReasonComment
	}
	return ""
}

type CTPOrderList struct {
	List []CTPOrder `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *CTPOrderList) Reset()                    { *m = CTPOrderList{} }
func (m *CTPOrderList) String() string            { return proto.CompactTextString(m) }
func (*CTPOrderList) ProtoMessage()               {}
func (*CTPOrderList) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{2} }

func (m *CTPOrderList) GetList() []CTPOrder {
	if m != nil {
		return m.List
	}
	return nil
}

type JointOrder struct {
	LocalOrder    CTPOrder `protobuf:"bytes,1,opt,name=local_order,json=localOrder" json:"localOrder"`
	ExchangeOrder CTPOrder `protobuf:"bytes,2,opt,name=exchange_order,json=exchangeOrder" json:"exchangeOrder"`
}

func (m *JointOrder) Reset()                    { *m = JointOrder{} }
func (m *JointOrder) String() string            { return proto.CompactTextString(m) }
func (*JointOrder) ProtoMessage()               {}
func (*JointOrder) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{3} }

func (m *JointOrder) GetLocalOrder() CTPOrder {
	if m != nil {
		return m.LocalOrder
	}
	return CTPOrder{}
}

func (m *JointOrder) GetExchangeOrder() CTPOrder {
	if m != nil {
		return m.ExchangeOrder
	}
	return CTPOrder{}
}

type CTPOrderLink struct {
	Parent   CTPOrder   `protobuf:"bytes,1,opt,name=parent" json:"parent"`
	Children []CTPOrder `protobuf:"bytes,2,rep,name=children" json:"children"`
}

func (m *CTPOrderLink) Reset()                    { *m = CTPOrderLink{} }
func (m *CTPOrderLink) String() string            { return proto.CompactTextString(m) }
func (*CTPOrderLink) ProtoMessage()               {}
func (*CTPOrderLink) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{4} }

func (m *CTPOrderLink) GetParent() CTPOrder {
	if m != nil {
		return m.Parent
	}
	return CTPOrder{}
}

func (m *CTPOrderLink) GetChildren() []CTPOrder {
	if m != nil {
		return m.Children
	}
	return nil
}

// 发送撤单请求
type CTPCancelOrderRequest struct {
	// 帐户
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountId"`
	// 委托编号
	CTPOrderID CTPOrderID `protobuf:"bytes,2,opt,name=CTPOrderID" json:"CTPOrderID"`
	// 合约
	Symbol Symbol `protobuf:"bytes,3,opt,name=symbol" json:"symbol"`
	// 请求id
	RequestId int32 `protobuf:"varint,4,opt,name=request_id,json=requestId,proto3" json:"requestId"`
	// 发起前置
	FrontId int32 `protobuf:"varint,5,opt,name=front_id,json=frontId,proto3" json:"frontId"`
	// 发起session
	SessionId int32 `protobuf:"varint,6,opt,name=session_id,json=sessionId,proto3" json:"sessionId"`
	// 发起终端信息
	ExchangeOrderId string `protobuf:"bytes,7,opt,name=exchange_order_id,json=exchangeOrderId,proto3" json:"exchangeOrderId"`
	// token
	Token string `protobuf:"bytes,8,opt,name=token,proto3" json:"token"`
	// router account id
	RouteAccountId string `protobuf:"bytes,9,opt,name=route_account_id,json=routeAccountId,proto3" json:"routeAccountId"`
}

func (m *CTPCancelOrderRequest) Reset()                    { *m = CTPCancelOrderRequest{} }
func (m *CTPCancelOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*CTPCancelOrderRequest) ProtoMessage()               {}
func (*CTPCancelOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{5} }

func (m *CTPCancelOrderRequest) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *CTPCancelOrderRequest) GetCTPOrderID() CTPOrderID {
	if m != nil {
		return m.CTPOrderID
	}
	return CTPOrderID{}
}

func (m *CTPCancelOrderRequest) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *CTPCancelOrderRequest) GetRequestId() int32 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *CTPCancelOrderRequest) GetFrontId() int32 {
	if m != nil {
		return m.FrontId
	}
	return 0
}

func (m *CTPCancelOrderRequest) GetSessionId() int32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *CTPCancelOrderRequest) GetExchangeOrderId() string {
	if m != nil {
		return m.ExchangeOrderId
	}
	return ""
}

func (m *CTPCancelOrderRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CTPCancelOrderRequest) GetRouteAccountId() string {
	if m != nil {
		return m.RouteAccountId
	}
	return ""
}

type CTPOnRtnCancelOrder struct {
	AccountId       string     `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountId"`
	OrderId         CTPOrderID `protobuf:"bytes,2,opt,name=order_id,json=orderId" json:"orderId"`
	ExchangeOrderId string     `protobuf:"bytes,3,opt,name=exchange_order_id,json=exchangeOrderId,proto3" json:"exchangeOrderId"`
	Symbol          Symbol     `protobuf:"bytes,4,opt,name=symbol" json:"symbol"`
	RequestId       int32      `protobuf:"varint,5,opt,name=request_id,json=requestId,proto3" json:"requestId"`
	ErrorType       int32      `protobuf:"varint,6,opt,name=error_type,json=errorType,proto3" json:"errorType"`
	Error           int32      `protobuf:"varint,7,opt,name=error,proto3" json:"error"`
	Msg             string     `protobuf:"bytes,8,opt,name=msg,proto3" json:"msg"`
	RouteAccountId  string     `protobuf:"bytes,9,opt,name=route_account_id,json=routeAccountId,proto3" json:"routeAccountId"`
}

func (m *CTPOnRtnCancelOrder) Reset()                    { *m = CTPOnRtnCancelOrder{} }
func (m *CTPOnRtnCancelOrder) String() string            { return proto.CompactTextString(m) }
func (*CTPOnRtnCancelOrder) ProtoMessage()               {}
func (*CTPOnRtnCancelOrder) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{6} }

func (m *CTPOnRtnCancelOrder) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *CTPOnRtnCancelOrder) GetOrderId() CTPOrderID {
	if m != nil {
		return m.OrderId
	}
	return CTPOrderID{}
}

func (m *CTPOnRtnCancelOrder) GetExchangeOrderId() string {
	if m != nil {
		return m.ExchangeOrderId
	}
	return ""
}

func (m *CTPOnRtnCancelOrder) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *CTPOnRtnCancelOrder) GetRequestId() int32 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *CTPOnRtnCancelOrder) GetErrorType() int32 {
	if m != nil {
		return m.ErrorType
	}
	return 0
}

func (m *CTPOnRtnCancelOrder) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

func (m *CTPOnRtnCancelOrder) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *CTPOnRtnCancelOrder) GetRouteAccountId() string {
	if m != nil {
		return m.RouteAccountId
	}
	return ""
}

// 成交
type CTPTradeReport struct {
	// 账号
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountId"`
	// 成交编号
	TradeId string `protobuf:"bytes,2,opt,name=trade_id,json=tradeId,proto3" json:"tradeId"`
	// 合约
	Symbol Symbol `protobuf:"bytes,3,opt,name=symbol" json:"symbol"`
	// 买卖
	Direction CTPDirection `protobuf:"varint,4,opt,name=direction,proto3,enum=pb.CTPDirection" json:"direction"`
	// 价格
	Price float64 `protobuf:"fixed64,5,opt,name=price,proto3" json:"price"`
	// 数量
	Volume int32 `protobuf:"varint,6,opt,name=volume,proto3" json:"volume"`
	// 时间
	TradedTime int64 `protobuf:"varint,7,opt,name=traded_time,json=tradedTime,proto3" json:"tradedTime"`
	// 交易日
	TradedTradingDay int32 `protobuf:"varint,8,opt,name=traded_trading_day,json=tradedTradingDay,proto3" json:"tradedTradingDay"`
	// 报单编号
	OrderId CTPOrderID `protobuf:"bytes,9,opt,name=order_id,json=orderId" json:"orderId"`
	// 类型
	PriceType CTPPriceType `protobuf:"varint,10,opt,name=price_type,json=priceType,proto3,enum=pb.CTPPriceType" json:"priceType"`
	// 投机套保
	HedgeType CTPHedgeType `protobuf:"varint,11,opt,name=hedge_type,json=hedgeType,proto3,enum=pb.CTPHedgeType" json:"hedgeType"`
	// 成交类型
	TradeType CTPTradeType `protobuf:"varint,12,opt,name=trade_type,json=tradeType,proto3,enum=pb.CTPTradeType" json:"tradeType"`
	// 币种
	CurrencyType int32 `protobuf:"varint,13,opt,name=currency_type,json=currencyType,proto3" json:"currencyType"`
	// 交易所ID
	ExchangeOrderId string `protobuf:"bytes,14,opt,name=exchange_order_id,json=exchangeOrderId,proto3" json:"exchangeOrderId"`
	// 本地编号类型
	LocalTypeId int32 `protobuf:"varint,15,opt,name=local_type_id,json=localTypeId,proto3" json:"localTypeId"`
	// 手续费
	Commission float64 `protobuf:"fixed64,16,opt,name=commission,proto3" json:"commission"`
	// 成交金额
	Tax float64 `protobuf:"fixed64,17,opt,name=tax,proto3" json:"tax"`
	// 其他费用
	TotalOtherFee float64 `protobuf:"fixed64,18,opt,name=total_other_fee,json=totalOtherFee,proto3" json:"totalOtherFee"`
	// 原成交价（结算衍生时)
	InitialTradedPrice float64 `protobuf:"fixed64,19,opt,name=initial_traded_price,json=initialTradedPrice,proto3" json:"initialTradedPrice"`
	// 保留附加金额(已经有用了的)
	Reserve float64 `protobuf:"fixed64,20,opt,name=reserve,proto3" json:"reserve"`
	// 开平标志
	OffsetFlag CTPOffsetFlag `protobuf:"varint,21,opt,name=offset_flag,json=offsetFlag,proto3,enum=pb.CTPOffsetFlag" json:"offsetFlag"`
	// 下单帐户
	RouteAccountId string `protobuf:"bytes,22,opt,name=route_account_id,json=routeAccountId,proto3" json:"routeAccountId"`
	// 名称
	SymbolName string `protobuf:"bytes,23,opt,name=symbol_name,json=symbolName,proto3" json:"symbolName"`
	// 变动点
	PriceTick float64 `protobuf:"fixed64,24,opt,name=price_tick,json=priceTick,proto3" json:"priceTick"`
}

func (m *CTPTradeReport) Reset()                    { *m = CTPTradeReport{} }
func (m *CTPTradeReport) String() string            { return proto.CompactTextString(m) }
func (*CTPTradeReport) ProtoMessage()               {}
func (*CTPTradeReport) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{7} }

func (m *CTPTradeReport) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *CTPTradeReport) GetTradeId() string {
	if m != nil {
		return m.TradeId
	}
	return ""
}

func (m *CTPTradeReport) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *CTPTradeReport) GetDirection() CTPDirection {
	if m != nil {
		return m.Direction
	}
	return CTPDirection_LONG
}

func (m *CTPTradeReport) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *CTPTradeReport) GetVolume() int32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *CTPTradeReport) GetTradedTime() int64 {
	if m != nil {
		return m.TradedTime
	}
	return 0
}

func (m *CTPTradeReport) GetTradedTradingDay() int32 {
	if m != nil {
		return m.TradedTradingDay
	}
	return 0
}

func (m *CTPTradeReport) GetOrderId() CTPOrderID {
	if m != nil {
		return m.OrderId
	}
	return CTPOrderID{}
}

func (m *CTPTradeReport) GetPriceType() CTPPriceType {
	if m != nil {
		return m.PriceType
	}
	return CTPPriceType_LIMIT_PRICE
}

func (m *CTPTradeReport) GetHedgeType() CTPHedgeType {
	if m != nil {
		return m.HedgeType
	}
	return CTPHedgeType_SPECULATION
}

func (m *CTPTradeReport) GetTradeType() CTPTradeType {
	if m != nil {
		return m.TradeType
	}
	return CTPTradeType_NORMAL
}

func (m *CTPTradeReport) GetCurrencyType() int32 {
	if m != nil {
		return m.CurrencyType
	}
	return 0
}

func (m *CTPTradeReport) GetExchangeOrderId() string {
	if m != nil {
		return m.ExchangeOrderId
	}
	return ""
}

func (m *CTPTradeReport) GetLocalTypeId() int32 {
	if m != nil {
		return m.LocalTypeId
	}
	return 0
}

func (m *CTPTradeReport) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *CTPTradeReport) GetTax() float64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *CTPTradeReport) GetTotalOtherFee() float64 {
	if m != nil {
		return m.TotalOtherFee
	}
	return 0
}

func (m *CTPTradeReport) GetInitialTradedPrice() float64 {
	if m != nil {
		return m.InitialTradedPrice
	}
	return 0
}

func (m *CTPTradeReport) GetReserve() float64 {
	if m != nil {
		return m.Reserve
	}
	return 0
}

func (m *CTPTradeReport) GetOffsetFlag() CTPOffsetFlag {
	if m != nil {
		return m.OffsetFlag
	}
	return CTPOffsetFlag_NONE
}

func (m *CTPTradeReport) GetRouteAccountId() string {
	if m != nil {
		return m.RouteAccountId
	}
	return ""
}

func (m *CTPTradeReport) GetSymbolName() string {
	if m != nil {
		return m.SymbolName
	}
	return ""
}

func (m *CTPTradeReport) GetPriceTick() float64 {
	if m != nil {
		return m.PriceTick
	}
	return 0
}

type CTPTradeReportList struct {
	List []CTPTradeReport `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *CTPTradeReportList) Reset()                    { *m = CTPTradeReportList{} }
func (m *CTPTradeReportList) String() string            { return proto.CompactTextString(m) }
func (*CTPTradeReportList) ProtoMessage()               {}
func (*CTPTradeReportList) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{8} }

func (m *CTPTradeReportList) GetList() []CTPTradeReport {
	if m != nil {
		return m.List
	}
	return nil
}

// 持仓统计
type CTPPositionSummation struct {
	// 方向
	Direction CTPDirection `protobuf:"varint,1,opt,name=direction,proto3,enum=pb.CTPDirection" json:"direction"`
	// 类型
	Type int32 `protobuf:"varint,2,opt,name=type,proto3" json:"type"`
	// 路由分组
	RouteAccountId string `protobuf:"bytes,3,opt,name=route_account_id,json=routeAccountId,proto3" json:"routeAccountId"`
	// 持仓
	Position int32 `protobuf:"varint,4,opt,name=position,proto3" json:"position"`
	// 金额
	Amount float64 `protobuf:"fixed64,5,opt,name=amount,proto3" json:"amount"`
	// 成本
	Cost float64 `protobuf:"fixed64,6,opt,name=cost,proto3" json:"cost"`
	// 冻结
	Frozen int32 `protobuf:"varint,7,opt,name=frozen,proto3" json:"frozen"`
	// 可用
	Available int32 `protobuf:"varint,8,opt,name=available,proto3" json:"available"`
	// 盈亏
	PositionProfit float64 `protobuf:"fixed64,9,opt,name=position_profit,json=positionProfit,proto3" json:"positionProfit"`
	// 平盈
	ClosedProfit float64 `protobuf:"fixed64,10,opt,name=closed_profit,json=closedProfit,proto3" json:"closedProfit"`
	// 保证金
	Margin float64 `protobuf:"fixed64,11,opt,name=margin,proto3" json:"margin"`
	// 冻结保证金
	FrozenMargin float64 `protobuf:"fixed64,12,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozenMargin"`
	// 手续费
	Commission float64 `protobuf:"fixed64,13,opt,name=commission,proto3" json:"commission"`
	// 冻结手续费
	FrozenCommission float64 `protobuf:"fixed64,14,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozenCommission"`
	// 利息
	Interest float64 `protobuf:"fixed64,15,opt,name=interest,proto3" json:"interest"`
	// 冻结利息
	FrozenInterest float64 `protobuf:"fixed64,16,opt,name=frozen_interest,json=frozenInterest,proto3" json:"frozenInterest"`
	// 盯市盈亏
	MtmProfit float64 `protobuf:"fixed64,17,opt,name=mtm_profit,json=mtmProfit,proto3" json:"mtmProfit"`
	// 进入清算的平仓盈亏
	ClearedClosedProfit float64 `protobuf:"fixed64,18,opt,name=cleared_closed_profit,json=clearedClosedProfit,proto3" json:"clearedClosedProfit"`
}

func (m *CTPPositionSummation) Reset()                    { *m = CTPPositionSummation{} }
func (m *CTPPositionSummation) String() string            { return proto.CompactTextString(m) }
func (*CTPPositionSummation) ProtoMessage()               {}
func (*CTPPositionSummation) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{9} }

func (m *CTPPositionSummation) GetDirection() CTPDirection {
	if m != nil {
		return m.Direction
	}
	return CTPDirection_LONG
}

func (m *CTPPositionSummation) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CTPPositionSummation) GetRouteAccountId() string {
	if m != nil {
		return m.RouteAccountId
	}
	return ""
}

func (m *CTPPositionSummation) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *CTPPositionSummation) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *CTPPositionSummation) GetCost() float64 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *CTPPositionSummation) GetFrozen() int32 {
	if m != nil {
		return m.Frozen
	}
	return 0
}

func (m *CTPPositionSummation) GetAvailable() int32 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *CTPPositionSummation) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

func (m *CTPPositionSummation) GetClosedProfit() float64 {
	if m != nil {
		return m.ClosedProfit
	}
	return 0
}

func (m *CTPPositionSummation) GetMargin() float64 {
	if m != nil {
		return m.Margin
	}
	return 0
}

func (m *CTPPositionSummation) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *CTPPositionSummation) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *CTPPositionSummation) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *CTPPositionSummation) GetInterest() float64 {
	if m != nil {
		return m.Interest
	}
	return 0
}

func (m *CTPPositionSummation) GetFrozenInterest() float64 {
	if m != nil {
		return m.FrozenInterest
	}
	return 0
}

func (m *CTPPositionSummation) GetMtmProfit() float64 {
	if m != nil {
		return m.MtmProfit
	}
	return 0
}

func (m *CTPPositionSummation) GetClearedClosedProfit() float64 {
	if m != nil {
		return m.ClearedClosedProfit
	}
	return 0
}

// 持仓
type CTPPosition struct {
	// / 合约编号
	Symbol Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	// 统计
	Summation CTPPositionSummation `protobuf:"bytes,2,opt,name=summation" json:"summation"`
	// 今仓
	TodaySummation CTPPositionSummation `protobuf:"bytes,3,opt,name=today_summation,json=todaySummation" json:"todaySummation"`
	// 今仓
	YesterdaySummation CTPPositionSummation `protobuf:"bytes,4,opt,name=yesterday_summation,json=yesterdaySummation" json:"yesterdaySummation"`
	// 昨结算
	PreSettlementPrice float64 `protobuf:"fixed64,5,opt,name=pre_settlement_price,json=preSettlementPrice,proto3" json:"preSettlementPrice"`
	// 今结算
	SettlementPrice float64 `protobuf:"fixed64,6,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlementPrice"`
	// 最新价
	LastPrice float64 `protobuf:"fixed64,7,opt,name=last_price,json=lastPrice,proto3" json:"lastPrice"`
	// 交易日
	TradingDay int32 `protobuf:"varint,8,opt,name=trading_day,json=tradingDay,proto3" json:"tradingDay"`
	// 交易品种类型
	ProductType int32 `protobuf:"varint,9,opt,name=product_type,json=productType,proto3" json:"productType"`
	// 合约乘数
	VolumeMultiple int32 `protobuf:"varint,11,opt,name=volume_multiple,json=volumeMultiple,proto3" json:"volumeMultiple"`
	// 产品
	ProductId ProductID `protobuf:"bytes,12,opt,name=product_id,json=productId" json:"productId"`
	// 最小变动价位
	PriceTick float64 `protobuf:"fixed64,13,opt,name=price_tick,json=priceTick,proto3" json:"priceTick"`
	// 名称
	SymbolName string `protobuf:"bytes,14,opt,name=symbol_name,json=symbolName,proto3" json:"symbolName"`
	// 账号
	AccountId string `protobuf:"bytes,15,opt,name=account_id,json=accountId,proto3" json:"accountId"`
}

func (m *CTPPosition) Reset()                    { *m = CTPPosition{} }
func (m *CTPPosition) String() string            { return proto.CompactTextString(m) }
func (*CTPPosition) ProtoMessage()               {}
func (*CTPPosition) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{10} }

func (m *CTPPosition) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *CTPPosition) GetSummation() CTPPositionSummation {
	if m != nil {
		return m.Summation
	}
	return CTPPositionSummation{}
}

func (m *CTPPosition) GetTodaySummation() CTPPositionSummation {
	if m != nil {
		return m.TodaySummation
	}
	return CTPPositionSummation{}
}

func (m *CTPPosition) GetYesterdaySummation() CTPPositionSummation {
	if m != nil {
		return m.YesterdaySummation
	}
	return CTPPositionSummation{}
}

func (m *CTPPosition) GetPreSettlementPrice() float64 {
	if m != nil {
		return m.PreSettlementPrice
	}
	return 0
}

func (m *CTPPosition) GetSettlementPrice() float64 {
	if m != nil {
		return m.SettlementPrice
	}
	return 0
}

func (m *CTPPosition) GetLastPrice() float64 {
	if m != nil {
		return m.LastPrice
	}
	return 0
}

func (m *CTPPosition) GetTradingDay() int32 {
	if m != nil {
		return m.TradingDay
	}
	return 0
}

func (m *CTPPosition) GetProductType() int32 {
	if m != nil {
		return m.ProductType
	}
	return 0
}

func (m *CTPPosition) GetVolumeMultiple() int32 {
	if m != nil {
		return m.VolumeMultiple
	}
	return 0
}

func (m *CTPPosition) GetProductId() ProductID {
	if m != nil {
		return m.ProductId
	}
	return ProductID{}
}

func (m *CTPPosition) GetPriceTick() float64 {
	if m != nil {
		return m.PriceTick
	}
	return 0
}

func (m *CTPPosition) GetSymbolName() string {
	if m != nil {
		return m.SymbolName
	}
	return ""
}

func (m *CTPPosition) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

type CTPPositionList struct {
	List []CTPPosition `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *CTPPositionList) Reset()                    { *m = CTPPositionList{} }
func (m *CTPPositionList) String() string            { return proto.CompactTextString(m) }
func (*CTPPositionList) ProtoMessage()               {}
func (*CTPPositionList) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{11} }

func (m *CTPPositionList) GetList() []CTPPosition {
	if m != nil {
		return m.List
	}
	return nil
}

// 平仓明细.
type CTPCloseTradeRecord struct {
	// 帐号
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountId"`
	// 合约
	Symbol Symbol `protobuf:"bytes,2,opt,name=symbol" json:"symbol"`
	// 方向
	Direction CTPDirection `protobuf:"varint,3,opt,name=direction,proto3,enum=pb.CTPDirection" json:"direction"`
	// 数量
	OpenVolume int32 `protobuf:"varint,4,opt,name=open_volume,json=openVolume,proto3" json:"openVolume"`
	// 开仓金额
	OpenAmount float64 `protobuf:"fixed64,5,opt,name=open_amount,json=openAmount,proto3" json:"openAmount"`
	// 平仓数量
	ClosedVolume int32 `protobuf:"varint,6,opt,name=closed_volume,json=closedVolume,proto3" json:"closedVolume"`
	// 平仓金额
	ClosedAmount float64 `protobuf:"fixed64,7,opt,name=closed_amount,json=closedAmount,proto3" json:"closedAmount"`
	// 开仓时间
	OpenTime int64 `protobuf:"varint,8,opt,name=open_time,json=openTime,proto3" json:"openTime"`
	// 开仓交易日
	OpenTradingDay int32 `protobuf:"varint,9,opt,name=open_trading_day,json=openTradingDay,proto3" json:"openTradingDay"`
	// 开仓委托单号
	OpenOrderId CTPOrderID `protobuf:"bytes,10,opt,name=open_order_id,json=openOrderId" json:"openOrderId"`
	// 开仓成交编号
	OpenTradeId string `protobuf:"bytes,11,opt,name=open_trade_id,json=openTradeId,proto3" json:"openTradeId"`
	// 开仓成交类型
	OpenTradeType int32 `protobuf:"varint,12,opt,name=open_trade_type,json=openTradeType,proto3" json:"openTradeType"`
	// 开仓投机套保类型
	OpenHedgeType int32 `protobuf:"varint,13,opt,name=open_hedge_type,json=openHedgeType,proto3" json:"openHedgeType"`
	// 平仓时间
	CloseTime int64 `protobuf:"varint,14,opt,name=close_time,json=closeTime,proto3" json:"closeTime"`
	// 平仓交易日
	CloseTradingDay int32 `protobuf:"varint,15,opt,name=close_trading_day,json=closeTradingDay,proto3" json:"closeTradingDay"`
	// 平仓委托单号
	CloseOrderId CTPOrderID `protobuf:"bytes,16,opt,name=close_order_id,json=closeOrderId" json:"closeOrderId"`
	// 平仓成交编号
	CloseTradeId string `protobuf:"bytes,17,opt,name=close_trade_id,json=closeTradeId,proto3" json:"closeTradeId"`
	// 平仓成交类型
	CloseTradeType int32 `protobuf:"varint,18,opt,name=close_trade_type,json=closeTradeType,proto3" json:"closeTradeType"`
	// 平仓投机套保类型
	CloseHedgeType int32 `protobuf:"varint,19,opt,name=close_hedge_type,json=closeHedgeType,proto3" json:"closeHedgeType"`
	// 平仓盈亏
	CloseProfit float64 `protobuf:"fixed64,20,opt,name=close_profit,json=closeProfit,proto3" json:"closeProfit"`
	// 昨结
	PreSettlementPrice float64 `protobuf:"fixed64,21,opt,name=pre_settlement_price,json=preSettlementPrice,proto3" json:"preSettlementPrice"`
	// 币种
	CurrencyType CurrencyType `protobuf:"varint,22,opt,name=currency_type,json=currencyType,proto3,enum=pb.CurrencyType" json:"currencyType"`
	// 开仓手续费
	OpenCommission float64 `protobuf:"fixed64,23,opt,name=open_commission,json=openCommission,proto3" json:"openCommission"`
	// 平仓手续费
	CloseCommission float64 `protobuf:"fixed64,24,opt,name=close_commission,json=closeCommission,proto3" json:"closeCommission"`
	// 保证金占用
	Margin float64 `protobuf:"fixed64,25,opt,name=margin,proto3" json:"margin"`
	// 初始开仓金额
	InitialOpenAmount float64 `protobuf:"fixed64,26,opt,name=initial_open_amount,json=initialOpenAmount,proto3" json:"initialOpenAmount"`
	// 合约乘数
	VolumeMultiple int32 `protobuf:"varint,27,opt,name=volume_multiple,json=volumeMultiple,proto3" json:"volumeMultiple"`
	// 冻结利息
	FrozenInterest float64 `protobuf:"fixed64,28,opt,name=frozen_interest,json=frozenInterest,proto3" json:"frozenInterest"`
	// 上游账户
	RouteAccountId string `protobuf:"bytes,29,opt,name=route_account_id,json=routeAccountId,proto3" json:"routeAccountId"`
	// 持仓盈亏
	PositionProfit float64 `protobuf:"fixed64,30,opt,name=position_profit,json=positionProfit,proto3" json:"positionProfit"`
}

func (m *CTPCloseTradeRecord) Reset()                    { *m = CTPCloseTradeRecord{} }
func (m *CTPCloseTradeRecord) String() string            { return proto.CompactTextString(m) }
func (*CTPCloseTradeRecord) ProtoMessage()               {}
func (*CTPCloseTradeRecord) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{12} }

func (m *CTPCloseTradeRecord) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *CTPCloseTradeRecord) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *CTPCloseTradeRecord) GetDirection() CTPDirection {
	if m != nil {
		return m.Direction
	}
	return CTPDirection_LONG
}

func (m *CTPCloseTradeRecord) GetOpenVolume() int32 {
	if m != nil {
		return m.OpenVolume
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetOpenAmount() float64 {
	if m != nil {
		return m.OpenAmount
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetClosedVolume() int32 {
	if m != nil {
		return m.ClosedVolume
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetClosedAmount() float64 {
	if m != nil {
		return m.ClosedAmount
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetOpenTime() int64 {
	if m != nil {
		return m.OpenTime
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetOpenTradingDay() int32 {
	if m != nil {
		return m.OpenTradingDay
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetOpenOrderId() CTPOrderID {
	if m != nil {
		return m.OpenOrderId
	}
	return CTPOrderID{}
}

func (m *CTPCloseTradeRecord) GetOpenTradeId() string {
	if m != nil {
		return m.OpenTradeId
	}
	return ""
}

func (m *CTPCloseTradeRecord) GetOpenTradeType() int32 {
	if m != nil {
		return m.OpenTradeType
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetOpenHedgeType() int32 {
	if m != nil {
		return m.OpenHedgeType
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetCloseTime() int64 {
	if m != nil {
		return m.CloseTime
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetCloseTradingDay() int32 {
	if m != nil {
		return m.CloseTradingDay
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetCloseOrderId() CTPOrderID {
	if m != nil {
		return m.CloseOrderId
	}
	return CTPOrderID{}
}

func (m *CTPCloseTradeRecord) GetCloseTradeId() string {
	if m != nil {
		return m.CloseTradeId
	}
	return ""
}

func (m *CTPCloseTradeRecord) GetCloseTradeType() int32 {
	if m != nil {
		return m.CloseTradeType
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetCloseHedgeType() int32 {
	if m != nil {
		return m.CloseHedgeType
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetCloseProfit() float64 {
	if m != nil {
		return m.CloseProfit
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetPreSettlementPrice() float64 {
	if m != nil {
		return m.PreSettlementPrice
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetCurrencyType() CurrencyType {
	if m != nil {
		return m.CurrencyType
	}
	return CurrencyType_CNY
}

func (m *CTPCloseTradeRecord) GetOpenCommission() float64 {
	if m != nil {
		return m.OpenCommission
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetCloseCommission() float64 {
	if m != nil {
		return m.CloseCommission
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetMargin() float64 {
	if m != nil {
		return m.Margin
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetInitialOpenAmount() float64 {
	if m != nil {
		return m.InitialOpenAmount
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetVolumeMultiple() int32 {
	if m != nil {
		return m.VolumeMultiple
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetFrozenInterest() float64 {
	if m != nil {
		return m.FrozenInterest
	}
	return 0
}

func (m *CTPCloseTradeRecord) GetRouteAccountId() string {
	if m != nil {
		return m.RouteAccountId
	}
	return ""
}

func (m *CTPCloseTradeRecord) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

type CTPCloseTradeRecordList struct {
	List []CTPCloseTradeRecord `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *CTPCloseTradeRecordList) Reset()                    { *m = CTPCloseTradeRecordList{} }
func (m *CTPCloseTradeRecordList) String() string            { return proto.CompactTextString(m) }
func (*CTPCloseTradeRecordList) ProtoMessage()               {}
func (*CTPCloseTradeRecordList) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{13} }

func (m *CTPCloseTradeRecordList) GetList() []CTPCloseTradeRecord {
	if m != nil {
		return m.List
	}
	return nil
}

// 保证金率
type CTPMarginRate struct {
	// 交易所
	Exchange ExchangeType `protobuf:"varint,1,opt,name=exchange,proto3,enum=pb.ExchangeType" json:"exchange"`
	// symbol
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol"`
	// product
	Product string `protobuf:"bytes,3,opt,name=product,proto3" json:"product"`
	// / 多头保证金率（按手数)
	LongByVolume float64 `protobuf:"fixed64,4,opt,name=long_by_volume,json=longByVolume,proto3" json:"longByVolume"`
	// / 多头保证金率（按金额)
	LongByAmount float64 `protobuf:"fixed64,5,opt,name=long_by_amount,json=longByAmount,proto3" json:"longByAmount"`
	// / 空头保证金率（按手数)
	ShortByVolume float64 `protobuf:"fixed64,6,opt,name=short_by_volume,json=shortByVolume,proto3" json:"shortByVolume"`
	// / 空头保证金率（按金额)
	ShortByAmount float64 `protobuf:"fixed64,7,opt,name=short_by_amount,json=shortByAmount,proto3" json:"shortByAmount"`
	// uid
	Id int64 `protobuf:"varint,10,opt,name=id,proto3" json:"id"`
}

func (m *CTPMarginRate) Reset()                    { *m = CTPMarginRate{} }
func (m *CTPMarginRate) String() string            { return proto.CompactTextString(m) }
func (*CTPMarginRate) ProtoMessage()               {}
func (*CTPMarginRate) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{14} }

func (m *CTPMarginRate) GetExchange() ExchangeType {
	if m != nil {
		return m.Exchange
	}
	return ExchangeType_SHFE
}

func (m *CTPMarginRate) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CTPMarginRate) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

func (m *CTPMarginRate) GetLongByVolume() float64 {
	if m != nil {
		return m.LongByVolume
	}
	return 0
}

func (m *CTPMarginRate) GetLongByAmount() float64 {
	if m != nil {
		return m.LongByAmount
	}
	return 0
}

func (m *CTPMarginRate) GetShortByVolume() float64 {
	if m != nil {
		return m.ShortByVolume
	}
	return 0
}

func (m *CTPMarginRate) GetShortByAmount() float64 {
	if m != nil {
		return m.ShortByAmount
	}
	return 0
}

func (m *CTPMarginRate) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// CTPMarginItem
type CTPMarginItem struct {
	// / 多头保证金率（按手数)
	LongByVolume float64 `protobuf:"fixed64,1,opt,name=long_by_volume,json=longByVolume,proto3" json:"longByVolume"`
	// / 多头保证金率（按金额)
	LongByAmount float64 `protobuf:"fixed64,2,opt,name=long_by_amount,json=longByAmount,proto3" json:"longByAmount"`
	// / 空头保证金率（按手数)
	ShortByVolume float64 `protobuf:"fixed64,3,opt,name=short_by_volume,json=shortByVolume,proto3" json:"shortByVolume"`
	// / 空头保证金率（按金额)
	ShortByAmount float64 `protobuf:"fixed64,4,opt,name=short_by_amount,json=shortByAmount,proto3" json:"shortByAmount"`
}

func (m *CTPMarginItem) Reset()                    { *m = CTPMarginItem{} }
func (m *CTPMarginItem) String() string            { return proto.CompactTextString(m) }
func (*CTPMarginItem) ProtoMessage()               {}
func (*CTPMarginItem) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{15} }

func (m *CTPMarginItem) GetLongByVolume() float64 {
	if m != nil {
		return m.LongByVolume
	}
	return 0
}

func (m *CTPMarginItem) GetLongByAmount() float64 {
	if m != nil {
		return m.LongByAmount
	}
	return 0
}

func (m *CTPMarginItem) GetShortByVolume() float64 {
	if m != nil {
		return m.ShortByVolume
	}
	return 0
}

func (m *CTPMarginItem) GetShortByAmount() float64 {
	if m != nil {
		return m.ShortByAmount
	}
	return 0
}

// 手续费
type CTPCommissionRateItem struct {
	ByAmount   float64       `protobuf:"fixed64,1,opt,name=by_amount,json=byAmount,proto3" json:"byAmount"`
	ByVolume   float64       `protobuf:"fixed64,2,opt,name=by_volume,json=byVolume,proto3" json:"byVolume"`
	Minimum    float64       `protobuf:"fixed64,3,opt,name=minimum,proto3" json:"minimum"`
	OffsetFlag CTPOffsetFlag `protobuf:"varint,4,opt,name=offset_flag,json=offsetFlag,proto3,enum=pb.CTPOffsetFlag" json:"offsetFlag"`
	Tag        string        `protobuf:"bytes,5,opt,name=tag,proto3" json:"tag"`
}

func (m *CTPCommissionRateItem) Reset()                    { *m = CTPCommissionRateItem{} }
func (m *CTPCommissionRateItem) String() string            { return proto.CompactTextString(m) }
func (*CTPCommissionRateItem) ProtoMessage()               {}
func (*CTPCommissionRateItem) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{16} }

func (m *CTPCommissionRateItem) GetByAmount() float64 {
	if m != nil {
		return m.ByAmount
	}
	return 0
}

func (m *CTPCommissionRateItem) GetByVolume() float64 {
	if m != nil {
		return m.ByVolume
	}
	return 0
}

func (m *CTPCommissionRateItem) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *CTPCommissionRateItem) GetOffsetFlag() CTPOffsetFlag {
	if m != nil {
		return m.OffsetFlag
	}
	return CTPOffsetFlag_NONE
}

func (m *CTPCommissionRateItem) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// 手续费率
type CTPCommissionRate struct {
	// 交易所
	Exchange ExchangeType `protobuf:"varint,1,opt,name=exchange,proto3,enum=pb.ExchangeType" json:"exchange"`
	// symbol
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol"`
	// product
	Product string `protobuf:"bytes,3,opt,name=product,proto3" json:"product"`
	// 设置
	Settings []CTPCommissionRateItem `protobuf:"bytes,4,rep,name=settings" json:"settings"`
	// ID
	Id int64 `protobuf:"varint,5,opt,name=id,proto3" json:"id"`
}

func (m *CTPCommissionRate) Reset()                    { *m = CTPCommissionRate{} }
func (m *CTPCommissionRate) String() string            { return proto.CompactTextString(m) }
func (*CTPCommissionRate) ProtoMessage()               {}
func (*CTPCommissionRate) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{17} }

func (m *CTPCommissionRate) GetExchange() ExchangeType {
	if m != nil {
		return m.Exchange
	}
	return ExchangeType_SHFE
}

func (m *CTPCommissionRate) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CTPCommissionRate) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

func (m *CTPCommissionRate) GetSettings() []CTPCommissionRateItem {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *CTPCommissionRate) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 交易单元
type CTPTradingUnit struct {
	// / 合约编号
	Symbol Symbol `protobuf:"bytes,1,opt,name=symbol" json:"symbol"`
	// 统计
	Position []CTPPosition `protobuf:"bytes,2,rep,name=position" json:"position"`
	// 报单
	OrderLinkList []CTPOrderLink `protobuf:"bytes,3,rep,name=order_link_list,json=orderLinkList" json:"orderLinkList"`
	// 持仓明细
	PositionDetailList []CTPCloseTradeRecord `protobuf:"bytes,4,rep,name=position_detail_list,json=positionDetailList" json:"positionDetailList"`
	// 平仓明细
	HistoryCtrList []CTPCloseTradeRecord `protobuf:"bytes,5,rep,name=history_ctr_list,json=historyCtrList" json:"historyCtrList"`
	// 历史单
	HistoryOrderList []CTPOrder `protobuf:"bytes,6,rep,name=history_order_list,json=historyOrderList" json:"historyOrderList"`
	// 成交
	HistoryTradeList []CTPTradeReport `protobuf:"bytes,7,rep,name=history_trade_list,json=historyTradeList" json:"historyTradeList"`
	// 最新价
	LastPrice float64 `protobuf:"fixed64,10,opt,name=last_price,json=lastPrice,proto3" json:"lastPrice"`
	// 行情更新时间
	LastMdsUpdateTime int64 `protobuf:"varint,11,opt,name=last_mds_update_time,json=lastMdsUpdateTime,proto3" json:"lastMdsUpdateTime"`
	// 合约信息
	PriceTick float64 `protobuf:"fixed64,12,opt,name=price_tick,json=priceTick,proto3" json:"priceTick"`
	// 合约乘数
	VolumeMultiple int32 `protobuf:"varint,13,opt,name=volume_multiple,json=volumeMultiple,proto3" json:"volumeMultiple"`
	// 手续费
	Cr CTPCommissionRate `protobuf:"bytes,14,opt,name=cr" json:"cr"`
	// 保证金
	Mr CTPMarginRate `protobuf:"bytes,15,opt,name=mr" json:"mr"`
}

func (m *CTPTradingUnit) Reset()                    { *m = CTPTradingUnit{} }
func (m *CTPTradingUnit) String() string            { return proto.CompactTextString(m) }
func (*CTPTradingUnit) ProtoMessage()               {}
func (*CTPTradingUnit) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{18} }

func (m *CTPTradingUnit) GetSymbol() Symbol {
	if m != nil {
		return m.Symbol
	}
	return Symbol{}
}

func (m *CTPTradingUnit) GetPosition() []CTPPosition {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *CTPTradingUnit) GetOrderLinkList() []CTPOrderLink {
	if m != nil {
		return m.OrderLinkList
	}
	return nil
}

func (m *CTPTradingUnit) GetPositionDetailList() []CTPCloseTradeRecord {
	if m != nil {
		return m.PositionDetailList
	}
	return nil
}

func (m *CTPTradingUnit) GetHistoryCtrList() []CTPCloseTradeRecord {
	if m != nil {
		return m.HistoryCtrList
	}
	return nil
}

func (m *CTPTradingUnit) GetHistoryOrderList() []CTPOrder {
	if m != nil {
		return m.HistoryOrderList
	}
	return nil
}

func (m *CTPTradingUnit) GetHistoryTradeList() []CTPTradeReport {
	if m != nil {
		return m.HistoryTradeList
	}
	return nil
}

func (m *CTPTradingUnit) GetLastPrice() float64 {
	if m != nil {
		return m.LastPrice
	}
	return 0
}

func (m *CTPTradingUnit) GetLastMdsUpdateTime() int64 {
	if m != nil {
		return m.LastMdsUpdateTime
	}
	return 0
}

func (m *CTPTradingUnit) GetPriceTick() float64 {
	if m != nil {
		return m.PriceTick
	}
	return 0
}

func (m *CTPTradingUnit) GetVolumeMultiple() int32 {
	if m != nil {
		return m.VolumeMultiple
	}
	return 0
}

func (m *CTPTradingUnit) GetCr() CTPCommissionRate {
	if m != nil {
		return m.Cr
	}
	return CTPCommissionRate{}
}

func (m *CTPTradingUnit) GetMr() CTPMarginRate {
	if m != nil {
		return m.Mr
	}
	return CTPMarginRate{}
}

type CTPForceCloseTimeRule struct {
	Start            int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	End              int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end"`
	DisableOpenStart int64 `protobuf:"varint,3,opt,name=disable_open_start,json=disableOpenStart,proto3" json:"disableOpenStart"`
}

func (m *CTPForceCloseTimeRule) Reset()                    { *m = CTPForceCloseTimeRule{} }
func (m *CTPForceCloseTimeRule) String() string            { return proto.CompactTextString(m) }
func (*CTPForceCloseTimeRule) ProtoMessage()               {}
func (*CTPForceCloseTimeRule) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{19} }

func (m *CTPForceCloseTimeRule) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *CTPForceCloseTimeRule) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *CTPForceCloseTimeRule) GetDisableOpenStart() int64 {
	if m != nil {
		return m.DisableOpenStart
	}
	return 0
}

// CTPTradingUnitOption 品种参数
type CTPTradingUnitOption struct {
	// 涨跌停N点内禁止开仓
	LimitPriceDisableOpen int32 `protobuf:"varint,1,opt,name=limit_price_disable_open,json=limitPriceDisableOpen,proto3" json:"limitPriceDisableOpen"`
	// 涨跌停N点内强制平仓
	LimitPriceForceClose int32 `protobuf:"varint,2,opt,name=limit_price_force_close,json=limitPriceForceClose,proto3" json:"limitPriceForceClose"`
	// 昨持仓阀值
	PrePositionPercentageThreshold float64 `protobuf:"fixed64,3,opt,name=pre_position_percentage_threshold,json=prePositionPercentageThreshold,proto3" json:"prePositionPercentageThreshold"`
	// 昨持仓绝对数量阀值
	PrePositionThreshold float64 `protobuf:"fixed64,4,opt,name=pre_position_threshold,json=prePositionThreshold,proto3" json:"prePositionThreshold"`
	// 昨成交占比阀值
	PreVolumePercentageThreshold float64 `protobuf:"fixed64,5,opt,name=pre_volume_percentage_threshold,json=preVolumePercentageThreshold,proto3" json:"preVolumePercentageThreshold"`
	// 昨成交量绝对数量阀值
	PreVolumeThreshold float64 `protobuf:"fixed64,6,opt,name=pre_volume_threshold,json=preVolumeThreshold,proto3" json:"preVolumeThreshold"`
	// 单资产持仓限制
	SingleProductMarginWeightLimit float64 `protobuf:"fixed64,7,opt,name=single_product_margin_weight_limit,json=singleProductMarginWeightLimit,proto3" json:"singleProductMarginWeightLimit"`
	// 开始时间
	FcrList []CTPForceCloseTimeRule `protobuf:"bytes,8,rep,name=fcr_list,json=fcrList" json:"fcrList"`
	// 禁止开仓
	DisableOpen bool `protobuf:"varint,9,opt,name=disable_open,json=disableOpen,proto3" json:"disableOpen"`
	// 手续费
	CrSettings []CTPCommissionRateItem `protobuf:"bytes,10,rep,name=cr_settings,json=crSettings" json:"crSettings"`
	// 保证金
	MarginRate CTPMarginItem `protobuf:"bytes,11,opt,name=margin_rate,json=marginRate" json:"marginRate"`
	// 止损点数
	StoplossCandidates []int32 `protobuf:"varint,12,rep,packed,name=stoploss_candidates,json=stoplossCandidates" json:"stoplossCandidates"`
	// 止赢点数
	TakeProfitCandidates []int32 `protobuf:"varint,13,rep,packed,name=take_profit_candidates,json=takeProfitCandidates" json:"takeProfitCandidates"`
	// 手数
	VolumeCandidates []int32 `protobuf:"varint,14,rep,packed,name=volume_candidates,json=volumeCandidates" json:"volumeCandidates"`
	// 禁止开仓
	DisableOpenSymbolList []string `protobuf:"bytes,15,rep,name=disable_open_symbol_list,json=disableOpenSymbolList" json:"disableOpenSymbolList"`
	// 禁止开仓
	DisableOpenClassList []string `protobuf:"bytes,16,rep,name=disable_open_class_list,json=disableOpenClassList" json:"disableOpenClassList"`
	// 上市<N天的品种禁止开仓
	OpenDaysLimit int32 `protobuf:"varint,17,opt,name=open_days_limit,json=openDaysLimit,proto3" json:"openDaysLimit"`
}

func (m *CTPTradingUnitOption) Reset()                    { *m = CTPTradingUnitOption{} }
func (m *CTPTradingUnitOption) String() string            { return proto.CompactTextString(m) }
func (*CTPTradingUnitOption) ProtoMessage()               {}
func (*CTPTradingUnitOption) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{20} }

func (m *CTPTradingUnitOption) GetLimitPriceDisableOpen() int32 {
	if m != nil {
		return m.LimitPriceDisableOpen
	}
	return 0
}

func (m *CTPTradingUnitOption) GetLimitPriceForceClose() int32 {
	if m != nil {
		return m.LimitPriceForceClose
	}
	return 0
}

func (m *CTPTradingUnitOption) GetPrePositionPercentageThreshold() float64 {
	if m != nil {
		return m.PrePositionPercentageThreshold
	}
	return 0
}

func (m *CTPTradingUnitOption) GetPrePositionThreshold() float64 {
	if m != nil {
		return m.PrePositionThreshold
	}
	return 0
}

func (m *CTPTradingUnitOption) GetPreVolumePercentageThreshold() float64 {
	if m != nil {
		return m.PreVolumePercentageThreshold
	}
	return 0
}

func (m *CTPTradingUnitOption) GetPreVolumeThreshold() float64 {
	if m != nil {
		return m.PreVolumeThreshold
	}
	return 0
}

func (m *CTPTradingUnitOption) GetSingleProductMarginWeightLimit() float64 {
	if m != nil {
		return m.SingleProductMarginWeightLimit
	}
	return 0
}

func (m *CTPTradingUnitOption) GetFcrList() []CTPForceCloseTimeRule {
	if m != nil {
		return m.FcrList
	}
	return nil
}

func (m *CTPTradingUnitOption) GetDisableOpen() bool {
	if m != nil {
		return m.DisableOpen
	}
	return false
}

func (m *CTPTradingUnitOption) GetCrSettings() []CTPCommissionRateItem {
	if m != nil {
		return m.CrSettings
	}
	return nil
}

func (m *CTPTradingUnitOption) GetMarginRate() CTPMarginItem {
	if m != nil {
		return m.MarginRate
	}
	return CTPMarginItem{}
}

func (m *CTPTradingUnitOption) GetStoplossCandidates() []int32 {
	if m != nil {
		return m.StoplossCandidates
	}
	return nil
}

func (m *CTPTradingUnitOption) GetTakeProfitCandidates() []int32 {
	if m != nil {
		return m.TakeProfitCandidates
	}
	return nil
}

func (m *CTPTradingUnitOption) GetVolumeCandidates() []int32 {
	if m != nil {
		return m.VolumeCandidates
	}
	return nil
}

func (m *CTPTradingUnitOption) GetDisableOpenSymbolList() []string {
	if m != nil {
		return m.DisableOpenSymbolList
	}
	return nil
}

func (m *CTPTradingUnitOption) GetDisableOpenClassList() []string {
	if m != nil {
		return m.DisableOpenClassList
	}
	return nil
}

func (m *CTPTradingUnitOption) GetOpenDaysLimit() int32 {
	if m != nil {
		return m.OpenDaysLimit
	}
	return 0
}

// 隔夜自有资金检查.
type MarginCheckRule struct {
	// 开始时间
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	// 结束时间
	End int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end"`
	// 平仓顺序
	ForceCloseOrder int32 `protobuf:"varint,3,opt,name=force_close_order,json=forceCloseOrder,proto3" json:"forceCloseOrder"`
	// 报警
	WarningLevel float64 `protobuf:"fixed64,4,opt,name=warning_level,json=warningLevel,proto3" json:"warningLevel"`
	// 强平
	ForceCloseLevel float64 `protobuf:"fixed64,5,opt,name=force_close_level,json=forceCloseLevel,proto3" json:"forceCloseLevel"`
	// 自有可用倍率
	CommonBalanceMultiple float64 `protobuf:"fixed64,6,opt,name=common_balance_multiple,json=commonBalanceMultiple,proto3" json:"commonBalanceMultiple"`
	// 报警线下禁止开仓
	DisableOpenUnderWarningLevel bool `protobuf:"varint,7,opt,name=disable_open_under_warning_level,json=disableOpenUnderWarningLevel,proto3" json:"disableOpenUnderWarningLevel"`
	// 按比例报警
	WarningLevelByPreferRatio float64 `protobuf:"fixed64,8,opt,name=warning_level_by_prefer_ratio,json=warningLevelByPreferRatio,proto3" json:"warningLevelByPreferRatio"`
	// 按比例强平
	ForceCloseLevelByPreferRatio float64 `protobuf:"fixed64,9,opt,name=force_close_level_by_prefer_ratio,json=forceCloseLevelByPreferRatio,proto3" json:"forceCloseLevelByPreferRatio"`
	// 报警按市值比例
	WarningLevelByMargin float64 `protobuf:"fixed64,10,opt,name=warning_level_by_margin,json=warningLevelByMargin,proto3" json:"warningLevelByMargin"`
	// 强平按市值比例
	ForceCloseLevelByMargin float64 `protobuf:"fixed64,11,opt,name=force_close_level_by_margin,json=forceCloseLevelByMargin,proto3" json:"forceCloseLevelByMargin"`
	// 总持仓占用上限
	MarginCeiling float64 `protobuf:"fixed64,12,opt,name=margin_ceiling,json=marginCeiling,proto3" json:"marginCeiling"`
	// 买入金额上限
	PositionAmountCeiling float64 `protobuf:"fixed64,13,opt,name=position_amount_ceiling,json=positionAmountCeiling,proto3" json:"positionAmountCeiling"`
}

func (m *MarginCheckRule) Reset()                    { *m = MarginCheckRule{} }
func (m *MarginCheckRule) String() string            { return proto.CompactTextString(m) }
func (*MarginCheckRule) ProtoMessage()               {}
func (*MarginCheckRule) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{21} }

func (m *MarginCheckRule) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MarginCheckRule) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *MarginCheckRule) GetForceCloseOrder() int32 {
	if m != nil {
		return m.ForceCloseOrder
	}
	return 0
}

func (m *MarginCheckRule) GetWarningLevel() float64 {
	if m != nil {
		return m.WarningLevel
	}
	return 0
}

func (m *MarginCheckRule) GetForceCloseLevel() float64 {
	if m != nil {
		return m.ForceCloseLevel
	}
	return 0
}

func (m *MarginCheckRule) GetCommonBalanceMultiple() float64 {
	if m != nil {
		return m.CommonBalanceMultiple
	}
	return 0
}

func (m *MarginCheckRule) GetDisableOpenUnderWarningLevel() bool {
	if m != nil {
		return m.DisableOpenUnderWarningLevel
	}
	return false
}

func (m *MarginCheckRule) GetWarningLevelByPreferRatio() float64 {
	if m != nil {
		return m.WarningLevelByPreferRatio
	}
	return 0
}

func (m *MarginCheckRule) GetForceCloseLevelByPreferRatio() float64 {
	if m != nil {
		return m.ForceCloseLevelByPreferRatio
	}
	return 0
}

func (m *MarginCheckRule) GetWarningLevelByMargin() float64 {
	if m != nil {
		return m.WarningLevelByMargin
	}
	return 0
}

func (m *MarginCheckRule) GetForceCloseLevelByMargin() float64 {
	if m != nil {
		return m.ForceCloseLevelByMargin
	}
	return 0
}

func (m *MarginCheckRule) GetMarginCeiling() float64 {
	if m != nil {
		return m.MarginCeiling
	}
	return 0
}

func (m *MarginCheckRule) GetPositionAmountCeiling() float64 {
	if m != nil {
		return m.PositionAmountCeiling
	}
	return 0
}

// SettlementUnitOption 结算组参数
type SettlementUnitOption struct {
	// ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 备注
	Comment string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment"`
	// 结算组
	SettlementGroup int32 `protobuf:"varint,3,opt,name=settlement_group,json=settlementGroup,proto3" json:"settlementGroup"`
	// 资金检查水平
	AvailableCheckLevel int32 `protobuf:"varint,4,opt,name=available_check_level,json=availableCheckLevel,proto3" json:"availableCheckLevel"`
	// 强平开启
	ForceCloseOn bool `protobuf:"varint,5,opt,name=force_close_on,json=forceCloseOn,proto3" json:"forceCloseOn"`
	// 强平检查
	McrList []MarginCheckRule `protobuf:"bytes,6,rep,name=mcr_list,json=mcrList" json:"mcrList"`
	// 禁止开仓
	DisableOpen bool `protobuf:"varint,7,opt,name=disable_open,json=disableOpen,proto3" json:"disableOpen"`
}

func (m *SettlementUnitOption) Reset()                    { *m = SettlementUnitOption{} }
func (m *SettlementUnitOption) String() string            { return proto.CompactTextString(m) }
func (*SettlementUnitOption) ProtoMessage()               {}
func (*SettlementUnitOption) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{22} }

func (m *SettlementUnitOption) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SettlementUnitOption) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *SettlementUnitOption) GetSettlementGroup() int32 {
	if m != nil {
		return m.SettlementGroup
	}
	return 0
}

func (m *SettlementUnitOption) GetAvailableCheckLevel() int32 {
	if m != nil {
		return m.AvailableCheckLevel
	}
	return 0
}

func (m *SettlementUnitOption) GetForceCloseOn() bool {
	if m != nil {
		return m.ForceCloseOn
	}
	return false
}

func (m *SettlementUnitOption) GetMcrList() []MarginCheckRule {
	if m != nil {
		return m.McrList
	}
	return nil
}

func (m *SettlementUnitOption) GetDisableOpen() bool {
	if m != nil {
		return m.DisableOpen
	}
	return false
}

// 普通结算
type CTPTradingAccount struct {
	// 合计
	Summary AccountMoneySummary `protobuf:"bytes,1,opt,name=summary" json:"summary"`
	// 出入金
	MtrList []MoneyTransferRecord `protobuf:"bytes,2,rep,name=mtr_list,json=mtrList" json:"mtrList"`
	// 交易明细
	TuList []CTPTradingUnit `protobuf:"bytes,3,rep,name=tu_list,json=tuList" json:"tuList"`
	// 最后结算日期
	LastSettleDate int32 `protobuf:"varint,4,opt,name=last_settle_date,json=lastSettleDate,proto3" json:"lastSettleDate"`
	// 设置
	Options SettlementUnitOption `protobuf:"bytes,5,opt,name=options" json:"options"`
}

func (m *CTPTradingAccount) Reset()                    { *m = CTPTradingAccount{} }
func (m *CTPTradingAccount) String() string            { return proto.CompactTextString(m) }
func (*CTPTradingAccount) ProtoMessage()               {}
func (*CTPTradingAccount) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{23} }

func (m *CTPTradingAccount) GetSummary() AccountMoneySummary {
	if m != nil {
		return m.Summary
	}
	return AccountMoneySummary{}
}

func (m *CTPTradingAccount) GetMtrList() []MoneyTransferRecord {
	if m != nil {
		return m.MtrList
	}
	return nil
}

func (m *CTPTradingAccount) GetTuList() []CTPTradingUnit {
	if m != nil {
		return m.TuList
	}
	return nil
}

func (m *CTPTradingAccount) GetLastSettleDate() int32 {
	if m != nil {
		return m.LastSettleDate
	}
	return 0
}

func (m *CTPTradingAccount) GetOptions() SettlementUnitOption {
	if m != nil {
		return m.Options
	}
	return SettlementUnitOption{}
}

// 账户快照
type CTPTradingAccountSnapshot struct {
	// 账户
	Account CTPTradingAccount `protobuf:"bytes,1,opt,name=account" json:"account"`
	// 快照时间
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time"`
	// 快照备注
	Comment string `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment"`
}

func (m *CTPTradingAccountSnapshot) Reset()                    { *m = CTPTradingAccountSnapshot{} }
func (m *CTPTradingAccountSnapshot) String() string            { return proto.CompactTextString(m) }
func (*CTPTradingAccountSnapshot) ProtoMessage()               {}
func (*CTPTradingAccountSnapshot) Descriptor() ([]byte, []int) { return fileDescriptorCtp, []int{24} }

func (m *CTPTradingAccountSnapshot) GetAccount() CTPTradingAccount {
	if m != nil {
		return m.Account
	}
	return CTPTradingAccount{}
}

func (m *CTPTradingAccountSnapshot) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CTPTradingAccountSnapshot) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func init() {
	proto.RegisterType((*CTPOrderID)(nil), "pb.CTPOrderID")
	proto.RegisterType((*CTPOrder)(nil), "pb.CTPOrder")
	proto.RegisterType((*CTPOrderList)(nil), "pb.CTPOrderList")
	proto.RegisterType((*JointOrder)(nil), "pb.JointOrder")
	proto.RegisterType((*CTPOrderLink)(nil), "pb.CTPOrderLink")
	proto.RegisterType((*CTPCancelOrderRequest)(nil), "pb.CTPCancelOrderRequest")
	proto.RegisterType((*CTPOnRtnCancelOrder)(nil), "pb.CTPOnRtnCancelOrder")
	proto.RegisterType((*CTPTradeReport)(nil), "pb.CTPTradeReport")
	proto.RegisterType((*CTPTradeReportList)(nil), "pb.CTPTradeReportList")
	proto.RegisterType((*CTPPositionSummation)(nil), "pb.CTPPositionSummation")
	proto.RegisterType((*CTPPosition)(nil), "pb.CTPPosition")
	proto.RegisterType((*CTPPositionList)(nil), "pb.CTPPositionList")
	proto.RegisterType((*CTPCloseTradeRecord)(nil), "pb.CTPCloseTradeRecord")
	proto.RegisterType((*CTPCloseTradeRecordList)(nil), "pb.CTPCloseTradeRecordList")
	proto.RegisterType((*CTPMarginRate)(nil), "pb.CTPMarginRate")
	proto.RegisterType((*CTPMarginItem)(nil), "pb.CTPMarginItem")
	proto.RegisterType((*CTPCommissionRateItem)(nil), "pb.CTPCommissionRateItem")
	proto.RegisterType((*CTPCommissionRate)(nil), "pb.CTPCommissionRate")
	proto.RegisterType((*CTPTradingUnit)(nil), "pb.CTPTradingUnit")
	proto.RegisterType((*CTPForceCloseTimeRule)(nil), "pb.CTPForceCloseTimeRule")
	proto.RegisterType((*CTPTradingUnitOption)(nil), "pb.CTPTradingUnitOption")
	proto.RegisterType((*MarginCheckRule)(nil), "pb.MarginCheckRule")
	proto.RegisterType((*SettlementUnitOption)(nil), "pb.SettlementUnitOption")
	proto.RegisterType((*CTPTradingAccount)(nil), "pb.CTPTradingAccount")
	proto.RegisterType((*CTPTradingAccountSnapshot)(nil), "pb.CTPTradingAccountSnapshot")
	proto.RegisterEnum("pb.CTPDirection", CTPDirection_name, CTPDirection_value)
	proto.RegisterEnum("pb.CTPOrderStatus", CTPOrderStatus_name, CTPOrderStatus_value)
	proto.RegisterEnum("pb.CTPPriceType", CTPPriceType_name, CTPPriceType_value)
	proto.RegisterEnum("pb.CTPOffsetFlag", CTPOffsetFlag_name, CTPOffsetFlag_value)
	proto.RegisterEnum("pb.CTPHedgeType", CTPHedgeType_name, CTPHedgeType_value)
	proto.RegisterEnum("pb.CTPTradeType", CTPTradeType_name, CTPTradeType_value)
}
func (m *CTPOrderID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPOrderID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FrontId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.FrontId))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.SessionId))
	}
	if m.OrderRef != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OrderRef))
	}
	if len(m.StringId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.StringId)))
		i += copy(dAtA[i:], m.StringId)
	}
	return i, nil
}

func (m *CTPOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Symbol.Size()))
	n1, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Id.Size()))
	n2, err := m.Id.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if m.Direction != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Direction))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Status))
	}
	if m.PriceType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.PriceType))
	}
	if m.LimitPrice != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.LimitPrice))))
	}
	if m.Volume != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Volume))
	}
	if m.VolumeTraded != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.VolumeTraded))
	}
	if m.VolumeCanceled != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.VolumeCanceled))
	}
	if m.FrozenCommission != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.FrozenCommission))))
	}
	if m.SendOrderTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.SendOrderTime))
	}
	if m.SendOrderTradingDay != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.SendOrderTradingDay))
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.RequestId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.RequestId))
	}
	if m.LocalOrderSeq != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.LocalOrderSeq))
	}
	if m.ForceCloseType != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.ForceCloseType))
	}
	if m.OrderSourceType != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OrderSourceType))
	}
	if m.OrderHedgeType != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OrderHedgeType))
	}
	if len(m.UserProductInfo) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.UserProductInfo)))
		i += copy(dAtA[i:], m.UserProductInfo)
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.CurrencyType))
	}
	if len(m.ExchangeOrderId) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.ExchangeOrderId)))
		i += copy(dAtA[i:], m.ExchangeOrderId)
	}
	if m.TimeConditionType != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.TimeConditionType))
	}
	if len(m.RouteAccountId) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.RouteAccountId)))
		i += copy(dAtA[i:], m.RouteAccountId)
	}
	if m.LocalTypeId != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.LocalTypeId))
	}
	if m.Commission != 0 {
		dAtA[i] = 0xd1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Commission))))
	}
	if m.OffsetFlag != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OffsetFlag))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.Stoploss != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Stoploss))))
	}
	if m.TakeProfit != 0 {
		dAtA[i] = 0xf9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.TakeProfit))))
	}
	if m.TradedAmount != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.TradedAmount))))
	}
	if m.VolumeMultiple != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.VolumeMultiple))
	}
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.ProductId.Size()))
	n3, err := m.ProductId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.PriceTick != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PriceTick))))
	}
	if m.FrozenMargin != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.FrozenMargin))))
	}
	if len(m.SymbolName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.SymbolName)))
		i += copy(dAtA[i:], m.SymbolName)
	}
	if len(m.ReasonComment) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.ReasonComment)))
		i += copy(dAtA[i:], m.ReasonComment)
	}
	return i, nil
}

func (m *CTPOrderList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPOrderList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *JointOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JointOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.LocalOrder.Size()))
	n4, err := m.LocalOrder.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.ExchangeOrder.Size()))
	n5, err := m.ExchangeOrder.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *CTPOrderLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPOrderLink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Parent.Size()))
	n6, err := m.Parent.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CTPCancelOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPCancelOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.CTPOrderID.Size()))
	n7, err := m.CTPOrderID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Symbol.Size()))
	n8, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.RequestId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.RequestId))
	}
	if m.FrontId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.FrontId))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.SessionId))
	}
	if len(m.ExchangeOrderId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.ExchangeOrderId)))
		i += copy(dAtA[i:], m.ExchangeOrderId)
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.RouteAccountId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.RouteAccountId)))
		i += copy(dAtA[i:], m.RouteAccountId)
	}
	return i, nil
}

func (m *CTPOnRtnCancelOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPOnRtnCancelOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.OrderId.Size()))
	n9, err := m.OrderId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.ExchangeOrderId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.ExchangeOrderId)))
		i += copy(dAtA[i:], m.ExchangeOrderId)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Symbol.Size()))
	n10, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.RequestId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.RequestId))
	}
	if m.ErrorType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.ErrorType))
	}
	if m.Error != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Error))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.RouteAccountId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.RouteAccountId)))
		i += copy(dAtA[i:], m.RouteAccountId)
	}
	return i, nil
}

func (m *CTPTradeReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPTradeReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if len(m.TradeId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.TradeId)))
		i += copy(dAtA[i:], m.TradeId)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Symbol.Size()))
	n11, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if m.Direction != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Direction))
	}
	if m.Price != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Price))))
	}
	if m.Volume != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Volume))
	}
	if m.TradedTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.TradedTime))
	}
	if m.TradedTradingDay != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.TradedTradingDay))
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.OrderId.Size()))
	n12, err := m.OrderId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.PriceType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.PriceType))
	}
	if m.HedgeType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.HedgeType))
	}
	if m.TradeType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.TradeType))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.CurrencyType))
	}
	if len(m.ExchangeOrderId) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.ExchangeOrderId)))
		i += copy(dAtA[i:], m.ExchangeOrderId)
	}
	if m.LocalTypeId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.LocalTypeId))
	}
	if m.Commission != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Commission))))
	}
	if m.Tax != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Tax))))
	}
	if m.TotalOtherFee != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.TotalOtherFee))))
	}
	if m.InitialTradedPrice != 0 {
		dAtA[i] = 0x99
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.InitialTradedPrice))))
	}
	if m.Reserve != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Reserve))))
	}
	if m.OffsetFlag != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OffsetFlag))
	}
	if len(m.RouteAccountId) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.RouteAccountId)))
		i += copy(dAtA[i:], m.RouteAccountId)
	}
	if len(m.SymbolName) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.SymbolName)))
		i += copy(dAtA[i:], m.SymbolName)
	}
	if m.PriceTick != 0 {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PriceTick))))
	}
	return i, nil
}

func (m *CTPTradeReportList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPTradeReportList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CTPPositionSummation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPPositionSummation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Direction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Direction))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Type))
	}
	if len(m.RouteAccountId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.RouteAccountId)))
		i += copy(dAtA[i:], m.RouteAccountId)
	}
	if m.Position != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Position))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Amount))))
	}
	if m.Cost != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Cost))))
	}
	if m.Frozen != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Frozen))
	}
	if m.Available != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Available))
	}
	if m.PositionProfit != 0 {
		dAtA[i] = 0x49
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PositionProfit))))
	}
	if m.ClosedProfit != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ClosedProfit))))
	}
	if m.Margin != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Margin))))
	}
	if m.FrozenMargin != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.FrozenMargin))))
	}
	if m.Commission != 0 {
		dAtA[i] = 0x69
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Commission))))
	}
	if m.FrozenCommission != 0 {
		dAtA[i] = 0x71
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.FrozenCommission))))
	}
	if m.Interest != 0 {
		dAtA[i] = 0x79
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Interest))))
	}
	if m.FrozenInterest != 0 {
		dAtA[i] = 0x81
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.FrozenInterest))))
	}
	if m.MtmProfit != 0 {
		dAtA[i] = 0x89
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.MtmProfit))))
	}
	if m.ClearedClosedProfit != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ClearedClosedProfit))))
	}
	return i, nil
}

func (m *CTPPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Symbol.Size()))
	n13, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Summation.Size()))
	n14, err := m.Summation.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.TodaySummation.Size()))
	n15, err := m.TodaySummation.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x22
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.YesterdaySummation.Size()))
	n16, err := m.YesterdaySummation.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if m.PreSettlementPrice != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PreSettlementPrice))))
	}
	if m.SettlementPrice != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.SettlementPrice))))
	}
	if m.LastPrice != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.LastPrice))))
	}
	if m.TradingDay != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.TradingDay))
	}
	if m.ProductType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.ProductType))
	}
	if m.VolumeMultiple != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.VolumeMultiple))
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.ProductId.Size()))
	n17, err := m.ProductId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if m.PriceTick != 0 {
		dAtA[i] = 0x69
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PriceTick))))
	}
	if len(m.SymbolName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.SymbolName)))
		i += copy(dAtA[i:], m.SymbolName)
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	return i, nil
}

func (m *CTPPositionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPPositionList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CTPCloseTradeRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPCloseTradeRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Symbol.Size()))
	n18, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if m.Direction != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Direction))
	}
	if m.OpenVolume != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OpenVolume))
	}
	if m.OpenAmount != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.OpenAmount))))
	}
	if m.ClosedVolume != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.ClosedVolume))
	}
	if m.ClosedAmount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ClosedAmount))))
	}
	if m.OpenTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OpenTime))
	}
	if m.OpenTradingDay != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OpenTradingDay))
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.OpenOrderId.Size()))
	n19, err := m.OpenOrderId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.OpenTradeId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.OpenTradeId)))
		i += copy(dAtA[i:], m.OpenTradeId)
	}
	if m.OpenTradeType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OpenTradeType))
	}
	if m.OpenHedgeType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OpenHedgeType))
	}
	if m.CloseTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.CloseTime))
	}
	if m.CloseTradingDay != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.CloseTradingDay))
	}
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.CloseOrderId.Size()))
	n20, err := m.CloseOrderId.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if len(m.CloseTradeId) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.CloseTradeId)))
		i += copy(dAtA[i:], m.CloseTradeId)
	}
	if m.CloseTradeType != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.CloseTradeType))
	}
	if m.CloseHedgeType != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.CloseHedgeType))
	}
	if m.CloseProfit != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.CloseProfit))))
	}
	if m.PreSettlementPrice != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PreSettlementPrice))))
	}
	if m.CurrencyType != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.CurrencyType))
	}
	if m.OpenCommission != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.OpenCommission))))
	}
	if m.CloseCommission != 0 {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.CloseCommission))))
	}
	if m.Margin != 0 {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Margin))))
	}
	if m.InitialOpenAmount != 0 {
		dAtA[i] = 0xd1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.InitialOpenAmount))))
	}
	if m.VolumeMultiple != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.VolumeMultiple))
	}
	if m.FrozenInterest != 0 {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.FrozenInterest))))
	}
	if len(m.RouteAccountId) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.RouteAccountId)))
		i += copy(dAtA[i:], m.RouteAccountId)
	}
	if m.PositionProfit != 0 {
		dAtA[i] = 0xf1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PositionProfit))))
	}
	return i, nil
}

func (m *CTPCloseTradeRecordList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPCloseTradeRecordList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CTPMarginRate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPMarginRate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Exchange))
	}
	if len(m.Symbol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Symbol)))
		i += copy(dAtA[i:], m.Symbol)
	}
	if len(m.Product) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Product)))
		i += copy(dAtA[i:], m.Product)
	}
	if m.LongByVolume != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.LongByVolume))))
	}
	if m.LongByAmount != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.LongByAmount))))
	}
	if m.ShortByVolume != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ShortByVolume))))
	}
	if m.ShortByAmount != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ShortByAmount))))
	}
	if m.Id != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *CTPMarginItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPMarginItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LongByVolume != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.LongByVolume))))
	}
	if m.LongByAmount != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.LongByAmount))))
	}
	if m.ShortByVolume != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ShortByVolume))))
	}
	if m.ShortByAmount != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ShortByAmount))))
	}
	return i, nil
}

func (m *CTPCommissionRateItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPCommissionRateItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ByAmount != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ByAmount))))
	}
	if m.ByVolume != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ByVolume))))
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.Minimum))))
	}
	if m.OffsetFlag != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OffsetFlag))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	return i, nil
}

func (m *CTPCommissionRate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPCommissionRate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exchange != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Exchange))
	}
	if len(m.Symbol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Symbol)))
		i += copy(dAtA[i:], m.Symbol)
	}
	if len(m.Product) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Product)))
		i += copy(dAtA[i:], m.Product)
	}
	if len(m.Settings) > 0 {
		for _, msg := range m.Settings {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *CTPTradingUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPTradingUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Symbol.Size()))
	n21, err := m.Symbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if len(m.Position) > 0 {
		for _, msg := range m.Position {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderLinkList) > 0 {
		for _, msg := range m.OrderLinkList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PositionDetailList) > 0 {
		for _, msg := range m.PositionDetailList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HistoryCtrList) > 0 {
		for _, msg := range m.HistoryCtrList {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HistoryOrderList) > 0 {
		for _, msg := range m.HistoryOrderList {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HistoryTradeList) > 0 {
		for _, msg := range m.HistoryTradeList {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastPrice != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.LastPrice))))
	}
	if m.LastMdsUpdateTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.LastMdsUpdateTime))
	}
	if m.PriceTick != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PriceTick))))
	}
	if m.VolumeMultiple != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.VolumeMultiple))
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Cr.Size()))
	n22, err := m.Cr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x7a
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Mr.Size()))
	n23, err := m.Mr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	return i, nil
}

func (m *CTPForceCloseTimeRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPForceCloseTimeRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.End))
	}
	if m.DisableOpenStart != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.DisableOpenStart))
	}
	return i, nil
}

func (m *CTPTradingUnitOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPTradingUnitOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LimitPriceDisableOpen != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.LimitPriceDisableOpen))
	}
	if m.LimitPriceForceClose != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.LimitPriceForceClose))
	}
	if m.PrePositionPercentageThreshold != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PrePositionPercentageThreshold))))
	}
	if m.PrePositionThreshold != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PrePositionThreshold))))
	}
	if m.PreVolumePercentageThreshold != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PreVolumePercentageThreshold))))
	}
	if m.PreVolumeThreshold != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PreVolumeThreshold))))
	}
	if m.SingleProductMarginWeightLimit != 0 {
		dAtA[i] = 0x39
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.SingleProductMarginWeightLimit))))
	}
	if len(m.FcrList) > 0 {
		for _, msg := range m.FcrList {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DisableOpen {
		dAtA[i] = 0x48
		i++
		if m.DisableOpen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CrSettings) > 0 {
		for _, msg := range m.CrSettings {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.MarginRate.Size()))
	n24, err := m.MarginRate.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	if len(m.StoplossCandidates) > 0 {
		dAtA26 := make([]byte, len(m.StoplossCandidates)*10)
		var j25 int
		for _, num1 := range m.StoplossCandidates {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintCtp(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if len(m.TakeProfitCandidates) > 0 {
		dAtA28 := make([]byte, len(m.TakeProfitCandidates)*10)
		var j27 int
		for _, num1 := range m.TakeProfitCandidates {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	if len(m.VolumeCandidates) > 0 {
		dAtA30 := make([]byte, len(m.VolumeCandidates)*10)
		var j29 int
		for _, num1 := range m.VolumeCandidates {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintCtp(dAtA, i, uint64(j29))
		i += copy(dAtA[i:], dAtA30[:j29])
	}
	if len(m.DisableOpenSymbolList) > 0 {
		for _, s := range m.DisableOpenSymbolList {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DisableOpenClassList) > 0 {
		for _, s := range m.DisableOpenClassList {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.OpenDaysLimit != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.OpenDaysLimit))
	}
	return i, nil
}

func (m *MarginCheckRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarginCheckRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.End))
	}
	if m.ForceCloseOrder != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.ForceCloseOrder))
	}
	if m.WarningLevel != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.WarningLevel))))
	}
	if m.ForceCloseLevel != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ForceCloseLevel))))
	}
	if m.CommonBalanceMultiple != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.CommonBalanceMultiple))))
	}
	if m.DisableOpenUnderWarningLevel {
		dAtA[i] = 0x38
		i++
		if m.DisableOpenUnderWarningLevel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WarningLevelByPreferRatio != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.WarningLevelByPreferRatio))))
	}
	if m.ForceCloseLevelByPreferRatio != 0 {
		dAtA[i] = 0x49
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ForceCloseLevelByPreferRatio))))
	}
	if m.WarningLevelByMargin != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.WarningLevelByMargin))))
	}
	if m.ForceCloseLevelByMargin != 0 {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.ForceCloseLevelByMargin))))
	}
	if m.MarginCeiling != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.MarginCeiling))))
	}
	if m.PositionAmountCeiling != 0 {
		dAtA[i] = 0x69
		i++
		i = encodeFixed64Ctp(dAtA, i, uint64(math.Float64bits(float64(m.PositionAmountCeiling))))
	}
	return i, nil
}

func (m *SettlementUnitOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SettlementUnitOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Id))
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if m.SettlementGroup != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.SettlementGroup))
	}
	if m.AvailableCheckLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.AvailableCheckLevel))
	}
	if m.ForceCloseOn {
		dAtA[i] = 0x28
		i++
		if m.ForceCloseOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.McrList) > 0 {
		for _, msg := range m.McrList {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DisableOpen {
		dAtA[i] = 0x38
		i++
		if m.DisableOpen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CTPTradingAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPTradingAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Summary.Size()))
	n31, err := m.Summary.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	if len(m.MtrList) > 0 {
		for _, msg := range m.MtrList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TuList) > 0 {
		for _, msg := range m.TuList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCtp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastSettleDate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.LastSettleDate))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Options.Size()))
	n32, err := m.Options.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	return i, nil
}

func (m *CTPTradingAccountSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTPTradingAccountSnapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintCtp(dAtA, i, uint64(m.Account.Size()))
	n33, err := m.Account.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n33
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCtp(dAtA, i, uint64(m.Time))
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCtp(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	return i, nil
}

func encodeFixed64Ctp(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Ctp(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCtp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CTPOrderID) Size() (n int) {
	var l int
	_ = l
	if m.FrontId != 0 {
		n += 1 + sovCtp(uint64(m.FrontId))
	}
	if m.SessionId != 0 {
		n += 1 + sovCtp(uint64(m.SessionId))
	}
	if m.OrderRef != 0 {
		n += 1 + sovCtp(uint64(m.OrderRef))
	}
	l = len(m.StringId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	return n
}

func (m *CTPOrder) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = m.Id.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovCtp(uint64(m.Direction))
	}
	if m.Status != 0 {
		n += 1 + sovCtp(uint64(m.Status))
	}
	if m.PriceType != 0 {
		n += 1 + sovCtp(uint64(m.PriceType))
	}
	if m.LimitPrice != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 1 + sovCtp(uint64(m.Volume))
	}
	if m.VolumeTraded != 0 {
		n += 1 + sovCtp(uint64(m.VolumeTraded))
	}
	if m.VolumeCanceled != 0 {
		n += 1 + sovCtp(uint64(m.VolumeCanceled))
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.SendOrderTime != 0 {
		n += 1 + sovCtp(uint64(m.SendOrderTime))
	}
	if m.SendOrderTradingDay != 0 {
		n += 1 + sovCtp(uint64(m.SendOrderTradingDay))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovCtp(uint64(m.RequestId))
	}
	if m.LocalOrderSeq != 0 {
		n += 2 + sovCtp(uint64(m.LocalOrderSeq))
	}
	if m.ForceCloseType != 0 {
		n += 2 + sovCtp(uint64(m.ForceCloseType))
	}
	if m.OrderSourceType != 0 {
		n += 2 + sovCtp(uint64(m.OrderSourceType))
	}
	if m.OrderHedgeType != 0 {
		n += 2 + sovCtp(uint64(m.OrderHedgeType))
	}
	l = len(m.UserProductInfo)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	if m.CurrencyType != 0 {
		n += 2 + sovCtp(uint64(m.CurrencyType))
	}
	l = len(m.ExchangeOrderId)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	if m.TimeConditionType != 0 {
		n += 2 + sovCtp(uint64(m.TimeConditionType))
	}
	l = len(m.RouteAccountId)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	if m.LocalTypeId != 0 {
		n += 2 + sovCtp(uint64(m.LocalTypeId))
	}
	if m.Commission != 0 {
		n += 10
	}
	if m.OffsetFlag != 0 {
		n += 2 + sovCtp(uint64(m.OffsetFlag))
	}
	if m.ErrorCode != 0 {
		n += 2 + sovCtp(uint64(m.ErrorCode))
	}
	l = len(m.Token)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	if m.Stoploss != 0 {
		n += 10
	}
	if m.TakeProfit != 0 {
		n += 10
	}
	if m.TradedAmount != 0 {
		n += 10
	}
	if m.VolumeMultiple != 0 {
		n += 2 + sovCtp(uint64(m.VolumeMultiple))
	}
	l = m.ProductId.Size()
	n += 2 + l + sovCtp(uint64(l))
	if m.PriceTick != 0 {
		n += 10
	}
	if m.FrozenMargin != 0 {
		n += 10
	}
	l = len(m.SymbolName)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	l = len(m.ReasonComment)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	return n
}

func (m *CTPOrderList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	return n
}

func (m *JointOrder) Size() (n int) {
	var l int
	_ = l
	l = m.LocalOrder.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = m.ExchangeOrder.Size()
	n += 1 + l + sovCtp(uint64(l))
	return n
}

func (m *CTPOrderLink) Size() (n int) {
	var l int
	_ = l
	l = m.Parent.Size()
	n += 1 + l + sovCtp(uint64(l))
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	return n
}

func (m *CTPCancelOrderRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = m.CTPOrderID.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = m.Symbol.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.RequestId != 0 {
		n += 1 + sovCtp(uint64(m.RequestId))
	}
	if m.FrontId != 0 {
		n += 1 + sovCtp(uint64(m.FrontId))
	}
	if m.SessionId != 0 {
		n += 1 + sovCtp(uint64(m.SessionId))
	}
	l = len(m.ExchangeOrderId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = len(m.RouteAccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	return n
}

func (m *CTPOnRtnCancelOrder) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = m.OrderId.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = len(m.ExchangeOrderId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = m.Symbol.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.RequestId != 0 {
		n += 1 + sovCtp(uint64(m.RequestId))
	}
	if m.ErrorType != 0 {
		n += 1 + sovCtp(uint64(m.ErrorType))
	}
	if m.Error != 0 {
		n += 1 + sovCtp(uint64(m.Error))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = len(m.RouteAccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	return n
}

func (m *CTPTradeReport) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = len(m.TradeId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = m.Symbol.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.Direction != 0 {
		n += 1 + sovCtp(uint64(m.Direction))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 1 + sovCtp(uint64(m.Volume))
	}
	if m.TradedTime != 0 {
		n += 1 + sovCtp(uint64(m.TradedTime))
	}
	if m.TradedTradingDay != 0 {
		n += 1 + sovCtp(uint64(m.TradedTradingDay))
	}
	l = m.OrderId.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.PriceType != 0 {
		n += 1 + sovCtp(uint64(m.PriceType))
	}
	if m.HedgeType != 0 {
		n += 1 + sovCtp(uint64(m.HedgeType))
	}
	if m.TradeType != 0 {
		n += 1 + sovCtp(uint64(m.TradeType))
	}
	if m.CurrencyType != 0 {
		n += 1 + sovCtp(uint64(m.CurrencyType))
	}
	l = len(m.ExchangeOrderId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if m.LocalTypeId != 0 {
		n += 1 + sovCtp(uint64(m.LocalTypeId))
	}
	if m.Commission != 0 {
		n += 10
	}
	if m.Tax != 0 {
		n += 10
	}
	if m.TotalOtherFee != 0 {
		n += 10
	}
	if m.InitialTradedPrice != 0 {
		n += 10
	}
	if m.Reserve != 0 {
		n += 10
	}
	if m.OffsetFlag != 0 {
		n += 2 + sovCtp(uint64(m.OffsetFlag))
	}
	l = len(m.RouteAccountId)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	l = len(m.SymbolName)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	if m.PriceTick != 0 {
		n += 10
	}
	return n
}

func (m *CTPTradeReportList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	return n
}

func (m *CTPPositionSummation) Size() (n int) {
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovCtp(uint64(m.Direction))
	}
	if m.Type != 0 {
		n += 1 + sovCtp(uint64(m.Type))
	}
	l = len(m.RouteAccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovCtp(uint64(m.Position))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.Cost != 0 {
		n += 9
	}
	if m.Frozen != 0 {
		n += 1 + sovCtp(uint64(m.Frozen))
	}
	if m.Available != 0 {
		n += 1 + sovCtp(uint64(m.Available))
	}
	if m.PositionProfit != 0 {
		n += 9
	}
	if m.ClosedProfit != 0 {
		n += 9
	}
	if m.Margin != 0 {
		n += 9
	}
	if m.FrozenMargin != 0 {
		n += 9
	}
	if m.Commission != 0 {
		n += 9
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.Interest != 0 {
		n += 9
	}
	if m.FrozenInterest != 0 {
		n += 10
	}
	if m.MtmProfit != 0 {
		n += 10
	}
	if m.ClearedClosedProfit != 0 {
		n += 10
	}
	return n
}

func (m *CTPPosition) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = m.Summation.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = m.TodaySummation.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = m.YesterdaySummation.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.PreSettlementPrice != 0 {
		n += 9
	}
	if m.SettlementPrice != 0 {
		n += 9
	}
	if m.LastPrice != 0 {
		n += 9
	}
	if m.TradingDay != 0 {
		n += 1 + sovCtp(uint64(m.TradingDay))
	}
	if m.ProductType != 0 {
		n += 1 + sovCtp(uint64(m.ProductType))
	}
	if m.VolumeMultiple != 0 {
		n += 1 + sovCtp(uint64(m.VolumeMultiple))
	}
	l = m.ProductId.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.PriceTick != 0 {
		n += 9
	}
	l = len(m.SymbolName)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	return n
}

func (m *CTPPositionList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	return n
}

func (m *CTPCloseTradeRecord) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = m.Symbol.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.Direction != 0 {
		n += 1 + sovCtp(uint64(m.Direction))
	}
	if m.OpenVolume != 0 {
		n += 1 + sovCtp(uint64(m.OpenVolume))
	}
	if m.OpenAmount != 0 {
		n += 9
	}
	if m.ClosedVolume != 0 {
		n += 1 + sovCtp(uint64(m.ClosedVolume))
	}
	if m.ClosedAmount != 0 {
		n += 9
	}
	if m.OpenTime != 0 {
		n += 1 + sovCtp(uint64(m.OpenTime))
	}
	if m.OpenTradingDay != 0 {
		n += 1 + sovCtp(uint64(m.OpenTradingDay))
	}
	l = m.OpenOrderId.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = len(m.OpenTradeId)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if m.OpenTradeType != 0 {
		n += 1 + sovCtp(uint64(m.OpenTradeType))
	}
	if m.OpenHedgeType != 0 {
		n += 1 + sovCtp(uint64(m.OpenHedgeType))
	}
	if m.CloseTime != 0 {
		n += 1 + sovCtp(uint64(m.CloseTime))
	}
	if m.CloseTradingDay != 0 {
		n += 1 + sovCtp(uint64(m.CloseTradingDay))
	}
	l = m.CloseOrderId.Size()
	n += 2 + l + sovCtp(uint64(l))
	l = len(m.CloseTradeId)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	if m.CloseTradeType != 0 {
		n += 2 + sovCtp(uint64(m.CloseTradeType))
	}
	if m.CloseHedgeType != 0 {
		n += 2 + sovCtp(uint64(m.CloseHedgeType))
	}
	if m.CloseProfit != 0 {
		n += 10
	}
	if m.PreSettlementPrice != 0 {
		n += 10
	}
	if m.CurrencyType != 0 {
		n += 2 + sovCtp(uint64(m.CurrencyType))
	}
	if m.OpenCommission != 0 {
		n += 10
	}
	if m.CloseCommission != 0 {
		n += 10
	}
	if m.Margin != 0 {
		n += 10
	}
	if m.InitialOpenAmount != 0 {
		n += 10
	}
	if m.VolumeMultiple != 0 {
		n += 2 + sovCtp(uint64(m.VolumeMultiple))
	}
	if m.FrozenInterest != 0 {
		n += 10
	}
	l = len(m.RouteAccountId)
	if l > 0 {
		n += 2 + l + sovCtp(uint64(l))
	}
	if m.PositionProfit != 0 {
		n += 10
	}
	return n
}

func (m *CTPCloseTradeRecordList) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	return n
}

func (m *CTPMarginRate) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCtp(uint64(m.Exchange))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if m.LongByVolume != 0 {
		n += 9
	}
	if m.LongByAmount != 0 {
		n += 9
	}
	if m.ShortByVolume != 0 {
		n += 9
	}
	if m.ShortByAmount != 0 {
		n += 9
	}
	if m.Id != 0 {
		n += 1 + sovCtp(uint64(m.Id))
	}
	return n
}

func (m *CTPMarginItem) Size() (n int) {
	var l int
	_ = l
	if m.LongByVolume != 0 {
		n += 9
	}
	if m.LongByAmount != 0 {
		n += 9
	}
	if m.ShortByVolume != 0 {
		n += 9
	}
	if m.ShortByAmount != 0 {
		n += 9
	}
	return n
}

func (m *CTPCommissionRateItem) Size() (n int) {
	var l int
	_ = l
	if m.ByAmount != 0 {
		n += 9
	}
	if m.ByVolume != 0 {
		n += 9
	}
	if m.Minimum != 0 {
		n += 9
	}
	if m.OffsetFlag != 0 {
		n += 1 + sovCtp(uint64(m.OffsetFlag))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	return n
}

func (m *CTPCommissionRate) Size() (n int) {
	var l int
	_ = l
	if m.Exchange != 0 {
		n += 1 + sovCtp(uint64(m.Exchange))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if len(m.Settings) > 0 {
		for _, e := range m.Settings {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if m.Id != 0 {
		n += 1 + sovCtp(uint64(m.Id))
	}
	return n
}

func (m *CTPTradingUnit) Size() (n int) {
	var l int
	_ = l
	l = m.Symbol.Size()
	n += 1 + l + sovCtp(uint64(l))
	if len(m.Position) > 0 {
		for _, e := range m.Position {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if len(m.OrderLinkList) > 0 {
		for _, e := range m.OrderLinkList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if len(m.PositionDetailList) > 0 {
		for _, e := range m.PositionDetailList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if len(m.HistoryCtrList) > 0 {
		for _, e := range m.HistoryCtrList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if len(m.HistoryOrderList) > 0 {
		for _, e := range m.HistoryOrderList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if len(m.HistoryTradeList) > 0 {
		for _, e := range m.HistoryTradeList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if m.LastPrice != 0 {
		n += 9
	}
	if m.LastMdsUpdateTime != 0 {
		n += 1 + sovCtp(uint64(m.LastMdsUpdateTime))
	}
	if m.PriceTick != 0 {
		n += 9
	}
	if m.VolumeMultiple != 0 {
		n += 1 + sovCtp(uint64(m.VolumeMultiple))
	}
	l = m.Cr.Size()
	n += 1 + l + sovCtp(uint64(l))
	l = m.Mr.Size()
	n += 1 + l + sovCtp(uint64(l))
	return n
}

func (m *CTPForceCloseTimeRule) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovCtp(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCtp(uint64(m.End))
	}
	if m.DisableOpenStart != 0 {
		n += 1 + sovCtp(uint64(m.DisableOpenStart))
	}
	return n
}

func (m *CTPTradingUnitOption) Size() (n int) {
	var l int
	_ = l
	if m.LimitPriceDisableOpen != 0 {
		n += 1 + sovCtp(uint64(m.LimitPriceDisableOpen))
	}
	if m.LimitPriceForceClose != 0 {
		n += 1 + sovCtp(uint64(m.LimitPriceForceClose))
	}
	if m.PrePositionPercentageThreshold != 0 {
		n += 9
	}
	if m.PrePositionThreshold != 0 {
		n += 9
	}
	if m.PreVolumePercentageThreshold != 0 {
		n += 9
	}
	if m.PreVolumeThreshold != 0 {
		n += 9
	}
	if m.SingleProductMarginWeightLimit != 0 {
		n += 9
	}
	if len(m.FcrList) > 0 {
		for _, e := range m.FcrList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if m.DisableOpen {
		n += 2
	}
	if len(m.CrSettings) > 0 {
		for _, e := range m.CrSettings {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	l = m.MarginRate.Size()
	n += 1 + l + sovCtp(uint64(l))
	if len(m.StoplossCandidates) > 0 {
		l = 0
		for _, e := range m.StoplossCandidates {
			l += sovCtp(uint64(e))
		}
		n += 1 + sovCtp(uint64(l)) + l
	}
	if len(m.TakeProfitCandidates) > 0 {
		l = 0
		for _, e := range m.TakeProfitCandidates {
			l += sovCtp(uint64(e))
		}
		n += 1 + sovCtp(uint64(l)) + l
	}
	if len(m.VolumeCandidates) > 0 {
		l = 0
		for _, e := range m.VolumeCandidates {
			l += sovCtp(uint64(e))
		}
		n += 1 + sovCtp(uint64(l)) + l
	}
	if len(m.DisableOpenSymbolList) > 0 {
		for _, s := range m.DisableOpenSymbolList {
			l = len(s)
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if len(m.DisableOpenClassList) > 0 {
		for _, s := range m.DisableOpenClassList {
			l = len(s)
			n += 2 + l + sovCtp(uint64(l))
		}
	}
	if m.OpenDaysLimit != 0 {
		n += 2 + sovCtp(uint64(m.OpenDaysLimit))
	}
	return n
}

func (m *MarginCheckRule) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovCtp(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovCtp(uint64(m.End))
	}
	if m.ForceCloseOrder != 0 {
		n += 1 + sovCtp(uint64(m.ForceCloseOrder))
	}
	if m.WarningLevel != 0 {
		n += 9
	}
	if m.ForceCloseLevel != 0 {
		n += 9
	}
	if m.CommonBalanceMultiple != 0 {
		n += 9
	}
	if m.DisableOpenUnderWarningLevel {
		n += 2
	}
	if m.WarningLevelByPreferRatio != 0 {
		n += 9
	}
	if m.ForceCloseLevelByPreferRatio != 0 {
		n += 9
	}
	if m.WarningLevelByMargin != 0 {
		n += 9
	}
	if m.ForceCloseLevelByMargin != 0 {
		n += 9
	}
	if m.MarginCeiling != 0 {
		n += 9
	}
	if m.PositionAmountCeiling != 0 {
		n += 9
	}
	return n
}

func (m *SettlementUnitOption) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCtp(uint64(m.Id))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	if m.SettlementGroup != 0 {
		n += 1 + sovCtp(uint64(m.SettlementGroup))
	}
	if m.AvailableCheckLevel != 0 {
		n += 1 + sovCtp(uint64(m.AvailableCheckLevel))
	}
	if m.ForceCloseOn {
		n += 2
	}
	if len(m.McrList) > 0 {
		for _, e := range m.McrList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if m.DisableOpen {
		n += 2
	}
	return n
}

func (m *CTPTradingAccount) Size() (n int) {
	var l int
	_ = l
	l = m.Summary.Size()
	n += 1 + l + sovCtp(uint64(l))
	if len(m.MtrList) > 0 {
		for _, e := range m.MtrList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if len(m.TuList) > 0 {
		for _, e := range m.TuList {
			l = e.Size()
			n += 1 + l + sovCtp(uint64(l))
		}
	}
	if m.LastSettleDate != 0 {
		n += 1 + sovCtp(uint64(m.LastSettleDate))
	}
	l = m.Options.Size()
	n += 1 + l + sovCtp(uint64(l))
	return n
}

func (m *CTPTradingAccountSnapshot) Size() (n int) {
	var l int
	_ = l
	l = m.Account.Size()
	n += 1 + l + sovCtp(uint64(l))
	if m.Time != 0 {
		n += 1 + sovCtp(uint64(m.Time))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovCtp(uint64(l))
	}
	return n
}

func sovCtp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCtp(x uint64) (n int) {
	return sovCtp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CTPOrderID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPOrderID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPOrderID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontId", wireType)
			}
			m.FrontId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRef", wireType)
			}
			m.OrderRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderRef |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (CTPDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (CTPOrderStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= (CTPPriceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LimitPrice = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeTraded", wireType)
			}
			m.VolumeTraded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeTraded |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCanceled", wireType)
			}
			m.VolumeCanceled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeCanceled |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendOrderTime", wireType)
			}
			m.SendOrderTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendOrderTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendOrderTradingDay", wireType)
			}
			m.SendOrderTradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendOrderTradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalOrderSeq", wireType)
			}
			m.LocalOrderSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalOrderSeq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseType", wireType)
			}
			m.ForceCloseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceCloseType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSourceType", wireType)
			}
			m.OrderSourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderSourceType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHedgeType", wireType)
			}
			m.OrderHedgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderHedgeType |= (CTPHedgeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProductInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProductInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (CurrencyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeOrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeOrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConditionType", wireType)
			}
			m.TimeConditionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeConditionType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalTypeId", wireType)
			}
			m.LocalTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalTypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Commission = float64(math.Float64frombits(v))
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetFlag", wireType)
			}
			m.OffsetFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetFlag |= (CTPOffsetFlag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stoploss", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Stoploss = float64(math.Float64frombits(v))
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakeProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.TakeProfit = float64(math.Float64frombits(v))
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradedAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.TradedAmount = float64(math.Float64frombits(v))
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMultiple", wireType)
			}
			m.VolumeMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeMultiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTick", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PriceTick = float64(math.Float64frombits(v))
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPOrderList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPOrderList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPOrderList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, CTPOrder{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JointOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JointOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JointOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LocalOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExchangeOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPOrderLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPOrderLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPOrderLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, CTPOrder{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPCancelOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPCancelOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPCancelOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTPOrderID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CTPOrderID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontId", wireType)
			}
			m.FrontId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeOrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeOrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPOnRtnCancelOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPOnRtnCancelOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPOnRtnCancelOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeOrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeOrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorType", wireType)
			}
			m.ErrorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPTradeReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPTradeReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPTradeReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (CTPDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Price = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradedTime", wireType)
			}
			m.TradedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradedTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradedTradingDay", wireType)
			}
			m.TradedTradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradedTradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= (CTPPriceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgeType", wireType)
			}
			m.HedgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HedgeType |= (CTPHedgeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeType", wireType)
			}
			m.TradeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradeType |= (CTPTradeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeOrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeOrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalTypeId", wireType)
			}
			m.LocalTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalTypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Commission = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Tax = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalOtherFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.TotalOtherFee = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialTradedPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.InitialTradedPrice = float64(math.Float64frombits(v))
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Reserve = float64(math.Float64frombits(v))
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetFlag", wireType)
			}
			m.OffsetFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetFlag |= (CTPOffsetFlag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTick", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PriceTick = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPTradeReportList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPTradeReportList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPTradeReportList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, CTPTradeReport{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPPositionSummation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPPositionSummation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPPositionSummation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (CTPDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Amount = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Cost = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frozen", wireType)
			}
			m.Frozen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frozen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PositionProfit = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ClosedProfit = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Margin = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Commission = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Interest = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenInterest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenInterest = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtmProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MtmProfit = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearedClosedProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ClearedClosedProfit = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Summation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodaySummation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TodaySummation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesterdaySummation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YesterdaySummation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSettlementPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreSettlementPrice = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.SettlementPrice = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LastPrice = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			m.TradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductType", wireType)
			}
			m.ProductType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMultiple", wireType)
			}
			m.VolumeMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeMultiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProductId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTick", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PriceTick = float64(math.Float64frombits(v))
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SymbolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPPositionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPPositionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPPositionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, CTPPosition{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPCloseTradeRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPCloseTradeRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPCloseTradeRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= (CTPDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenVolume", wireType)
			}
			m.OpenVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.OpenAmount = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedVolume", wireType)
			}
			m.ClosedVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedVolume |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ClosedAmount = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTime", wireType)
			}
			m.OpenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTradingDay", wireType)
			}
			m.OpenTradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpenOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenTradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTradeType", wireType)
			}
			m.OpenTradeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTradeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenHedgeType", wireType)
			}
			m.OpenHedgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenHedgeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTime", wireType)
			}
			m.CloseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTradingDay", wireType)
			}
			m.CloseTradingDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTradingDay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CloseOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloseTradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTradeType", wireType)
			}
			m.CloseTradeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTradeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseHedgeType", wireType)
			}
			m.CloseHedgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseHedgeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CloseProfit = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSettlementPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreSettlementPrice = float64(math.Float64frombits(v))
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyType", wireType)
			}
			m.CurrencyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyType |= (CurrencyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.OpenCommission = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CloseCommission = float64(math.Float64frombits(v))
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Margin = float64(math.Float64frombits(v))
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialOpenAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.InitialOpenAmount = float64(math.Float64frombits(v))
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMultiple", wireType)
			}
			m.VolumeMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeMultiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenInterest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FrozenInterest = float64(math.Float64frombits(v))
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PositionProfit = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPCloseTradeRecordList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPCloseTradeRecordList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPCloseTradeRecordList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, CTPCloseTradeRecord{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPMarginRate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPMarginRate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPMarginRate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongByVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LongByVolume = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongByAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LongByAmount = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortByVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortByVolume = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortByAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortByAmount = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPMarginItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPMarginItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPMarginItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongByVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LongByVolume = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongByAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LongByAmount = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortByVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortByVolume = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortByAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ShortByAmount = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPCommissionRateItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPCommissionRateItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPCommissionRateItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ByAmount = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ByVolume = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Minimum = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetFlag", wireType)
			}
			m.OffsetFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetFlag |= (CTPOffsetFlag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPCommissionRate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPCommissionRate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPCommissionRate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			m.Exchange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exchange |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = append(m.Settings, CTPCommissionRateItem{})
			if err := m.Settings[len(m.Settings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPTradingUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPTradingUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPTradingUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = append(m.Position, CTPPosition{})
			if err := m.Position[len(m.Position)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderLinkList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderLinkList = append(m.OrderLinkList, CTPOrderLink{})
			if err := m.OrderLinkList[len(m.OrderLinkList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionDetailList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionDetailList = append(m.PositionDetailList, CTPCloseTradeRecord{})
			if err := m.PositionDetailList[len(m.PositionDetailList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryCtrList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryCtrList = append(m.HistoryCtrList, CTPCloseTradeRecord{})
			if err := m.HistoryCtrList[len(m.HistoryCtrList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryOrderList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryOrderList = append(m.HistoryOrderList, CTPOrder{})
			if err := m.HistoryOrderList[len(m.HistoryOrderList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryTradeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryTradeList = append(m.HistoryTradeList, CTPTradeReport{})
			if err := m.HistoryTradeList[len(m.HistoryTradeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.LastPrice = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMdsUpdateTime", wireType)
			}
			m.LastMdsUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMdsUpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceTick", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PriceTick = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMultiple", wireType)
			}
			m.VolumeMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeMultiple |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Mr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPForceCloseTimeRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPForceCloseTimeRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPForceCloseTimeRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOpenStart", wireType)
			}
			m.DisableOpenStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisableOpenStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPTradingUnitOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPTradingUnitOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPTradingUnitOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPriceDisableOpen", wireType)
			}
			m.LimitPriceDisableOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitPriceDisableOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPriceForceClose", wireType)
			}
			m.LimitPriceForceClose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitPriceForceClose |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePositionPercentageThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PrePositionPercentageThreshold = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePositionThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PrePositionThreshold = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVolumePercentageThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreVolumePercentageThreshold = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVolumeThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PreVolumeThreshold = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleProductMarginWeightLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.SingleProductMarginWeightLimit = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FcrList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FcrList = append(m.FcrList, CTPForceCloseTimeRule{})
			if err := m.FcrList[len(m.FcrList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOpen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableOpen = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrSettings = append(m.CrSettings, CTPCommissionRateItem{})
			if err := m.CrSettings[len(m.CrSettings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarginRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCtp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoplossCandidates = append(m.StoplossCandidates, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCtp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCtp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCtp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoplossCandidates = append(m.StoplossCandidates, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoplossCandidates", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCtp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TakeProfitCandidates = append(m.TakeProfitCandidates, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCtp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCtp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCtp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TakeProfitCandidates = append(m.TakeProfitCandidates, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TakeProfitCandidates", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCtp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VolumeCandidates = append(m.VolumeCandidates, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCtp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCtp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCtp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VolumeCandidates = append(m.VolumeCandidates, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCandidates", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOpenSymbolList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisableOpenSymbolList = append(m.DisableOpenSymbolList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOpenClassList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisableOpenClassList = append(m.DisableOpenClassList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenDaysLimit", wireType)
			}
			m.OpenDaysLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenDaysLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarginCheckRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarginCheckRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarginCheckRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseOrder", wireType)
			}
			m.ForceCloseOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceCloseOrder |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningLevel", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WarningLevel = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseLevel", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ForceCloseLevel = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonBalanceMultiple", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CommonBalanceMultiple = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOpenUnderWarningLevel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableOpenUnderWarningLevel = bool(v != 0)
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningLevelByPreferRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WarningLevelByPreferRatio = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseLevelByPreferRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ForceCloseLevelByPreferRatio = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningLevelByMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WarningLevelByMargin = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseLevelByMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ForceCloseLevelByMargin = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginCeiling", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MarginCeiling = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionAmountCeiling", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PositionAmountCeiling = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SettlementUnitOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SettlementUnitOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SettlementUnitOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementGroup", wireType)
			}
			m.SettlementGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableCheckLevel", wireType)
			}
			m.AvailableCheckLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableCheckLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceCloseOn = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McrList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McrList = append(m.McrList, MarginCheckRule{})
			if err := m.McrList[len(m.McrList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOpen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableOpen = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPTradingAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPTradingAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPTradingAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtrList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MtrList = append(m.MtrList, MoneyTransferRecord{})
			if err := m.MtrList[len(m.MtrList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TuList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TuList = append(m.TuList, CTPTradingUnit{})
			if err := m.TuList[len(m.TuList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSettleDate", wireType)
			}
			m.LastSettleDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSettleDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTPTradingAccountSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTPTradingAccountSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTPTradingAccountSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCtp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCtp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCtp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCtp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCtp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCtp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCtp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCtp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ctp.proto", fileDescriptorCtp) }

var fileDescriptorCtp = []byte{
	// 3749 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x5a, 0xbd, 0x73, 0x23, 0x47,
	0x76, 0x5f, 0x00, 0x04, 0x01, 0x3c, 0x7c, 0x0d, 0x9b, 0xe4, 0x72, 0xf6, 0x8b, 0xe2, 0x62, 0x25,
	0x1d, 0xc5, 0x95, 0x77, 0x65, 0x4a, 0xab, 0xb3, 0x55, 0x17, 0x1c, 0x17, 0xc4, 0xae, 0x70, 0xc7,
	0x2f, 0x0f, 0xb1, 0x92, 0x95, 0x78, 0x6a, 0x76, 0xa6, 0x49, 0x4e, 0x2d, 0x30, 0x03, 0xcd, 0x0c,
	0x74, 0x87, 0x8b, 0x2e, 0x71, 0xe0, 0xcc, 0xe5, 0x2a, 0x57, 0xb9, 0xca, 0x7f, 0x80, 0x03, 0x47,
	0x4e, 0x9d, 0xb8, 0x9c, 0xb9, 0xca, 0x81, 0x9d, 0x3a, 0x73, 0xc9, 0xb1, 0x13, 0xff, 0x05, 0xae,
	0x7e, 0xaf, 0x7b, 0xa6, 0x07, 0x18, 0x8a, 0xdc, 0xe0, 0x32, 0xf4, 0xfb, 0xe8, 0xcf, 0xf7, 0x7e,
	0xef, 0xd7, 0x3d, 0x80, 0x86, 0x9b, 0x4c, 0x9f, 0x4d, 0xa3, 0x30, 0x09, 0x59, 0x79, 0xfa, 0xf6,
	0x7e, 0xcb, 0x0d, 0x27, 0x93, 0x30, 0x20, 0x49, 0xef, 0xf7, 0x25, 0x80, 0xfe, 0xe8, 0xec, 0x34,
	0xf2, 0x78, 0x34, 0x3c, 0x64, 0xf7, 0xa0, 0x7e, 0x11, 0x85, 0x41, 0x62, 0xfb, 0x9e, 0x59, 0xda,
	0x29, 0xed, 0x56, 0xac, 0x1a, 0xb6, 0x87, 0x1e, 0x7b, 0x04, 0x10, 0xf3, 0x38, 0xf6, 0xc3, 0x40,
	0x28, 0xcb, 0xa8, 0x6c, 0x48, 0xc9, 0xd0, 0x63, 0x0f, 0xa0, 0x11, 0x8a, 0x4e, 0xec, 0x88, 0x5f,
	0x98, 0x15, 0xd4, 0xd6, 0x51, 0x60, 0xf1, 0x0b, 0xa1, 0x8c, 0x93, 0xc8, 0x0f, 0x2e, 0x85, 0xeb,
	0xca, 0x4e, 0x69, 0xb7, 0x61, 0xd5, 0x49, 0x30, 0xf4, 0x7a, 0xff, 0xd5, 0x84, 0xba, 0x9a, 0x02,
	0xeb, 0xc1, 0x6a, 0x3c, 0x9f, 0xbc, 0x0d, 0xc7, 0x38, 0x7c, 0x73, 0x1f, 0x9e, 0x4d, 0xdf, 0x3e,
	0x3b, 0x47, 0x89, 0x25, 0x35, 0x6c, 0x1b, 0xca, 0x72, 0x06, 0xcd, 0xfd, 0x8e, 0xd0, 0x67, 0x0b,
	0xb0, 0xca, 0x3e, 0xce, 0xd4, 0x71, 0xdd, 0x70, 0x46, 0xcb, 0xa8, 0xe0, 0x70, 0x0d, 0x29, 0x19,
	0x7a, 0xec, 0x19, 0x34, 0x3c, 0x3f, 0xe2, 0x6e, 0xe2, 0x87, 0x01, 0x4e, 0xa6, 0xb3, 0x6f, 0xc8,
	0x5e, 0x0e, 0x95, 0xdc, 0xca, 0x4c, 0xd8, 0x1e, 0xac, 0xc6, 0x89, 0x93, 0xcc, 0x62, 0xb3, 0x8a,
	0xc6, 0x4c, 0x1f, 0xf2, 0x1c, 0x35, 0x96, 0xb4, 0x60, 0xcf, 0x01, 0xa6, 0x91, 0xef, 0x72, 0x3b,
	0x99, 0x4f, 0xb9, 0xb9, 0x9a, 0xeb, 0xfc, 0x4c, 0x28, 0x46, 0xf3, 0x29, 0xb7, 0x1a, 0x53, 0xf5,
	0x93, 0x7d, 0x00, 0xcd, 0xb1, 0x3f, 0xf1, 0x13, 0x1b, 0x45, 0x66, 0x6d, 0xa7, 0xb4, 0x5b, 0xb2,
	0x00, 0x45, 0x68, 0xcf, 0xee, 0xc2, 0xea, 0x0f, 0xe1, 0x78, 0x36, 0xe1, 0x66, 0x7d, 0xa7, 0xb4,
	0x5b, 0xb5, 0x64, 0x8b, 0x3d, 0x81, 0x36, 0xfd, 0xb2, 0x93, 0xc8, 0xf1, 0xb8, 0x67, 0x36, 0x50,
	0xdd, 0x22, 0xe1, 0x08, 0x65, 0xec, 0x67, 0xd0, 0x95, 0x46, 0xae, 0x13, 0xb8, 0x7c, 0xcc, 0x3d,
	0x13, 0xd0, 0xac, 0x43, 0xe2, 0xbe, 0x94, 0xb2, 0xa7, 0xb0, 0x76, 0x11, 0x85, 0xbf, 0xe3, 0x81,
	0x2d, 0xa2, 0xc3, 0xc7, 0x43, 0x35, 0x9b, 0x38, 0x19, 0x83, 0x14, 0xfd, 0x54, 0xce, 0x3e, 0x86,
	0x6e, 0xcc, 0x03, 0xcf, 0xa6, 0xf3, 0x4e, 0xfc, 0x09, 0x37, 0x5b, 0x78, 0xe0, 0x6d, 0x21, 0xc6,
	0x6d, 0x19, 0xf9, 0x13, 0xce, 0x3e, 0x87, 0xbb, 0xba, 0x5d, 0xe4, 0x78, 0x22, 0x02, 0x3c, 0x67,
	0x6e, 0xb6, 0x71, 0x12, 0xeb, 0x99, 0x39, 0xe9, 0x0e, 0x9d, 0x39, 0x33, 0xa1, 0x26, 0xa6, 0xc0,
	0x83, 0xc4, 0xec, 0xe0, 0xc9, 0xa9, 0xa6, 0x38, 0xd6, 0x88, 0x7f, 0x3f, 0xe3, 0x31, 0x1e, 0x6b,
	0x17, 0xbb, 0x68, 0x48, 0xc9, 0xd0, 0x13, 0xb3, 0x1a, 0x87, 0xae, 0x33, 0x96, 0xc3, 0xc5, 0xfc,
	0x7b, 0xd3, 0x40, 0x9b, 0x36, 0x8a, 0xe9, 0xb4, 0xf8, 0xf7, 0x6c, 0x17, 0x8c, 0x8b, 0x30, 0x72,
	0xb9, 0xed, 0x8e, 0xc3, 0x58, 0x1e, 0xd4, 0x1a, 0x6d, 0x0a, 0xca, 0xfb, 0x42, 0x8c, 0x67, 0xb3,
	0x07, 0x6b, 0xb2, 0xaf, 0x70, 0x16, 0xa9, 0x33, 0x65, 0x68, 0xda, 0x45, 0xc5, 0x39, 0xca, 0xd1,
	0xf6, 0x2b, 0x30, 0xc8, 0xf6, 0x8a, 0x7b, 0x97, 0xd2, 0x74, 0x3d, 0x77, 0xfc, 0x5f, 0x0b, 0x05,
	0x1e, 0x7f, 0x07, 0x2d, 0xd3, 0xb6, 0x18, 0x67, 0x16, 0xf3, 0xc8, 0x9e, 0x46, 0xa1, 0x37, 0x73,
	0x13, 0xdb, 0x0f, 0x2e, 0x42, 0x73, 0x03, 0x17, 0xdf, 0x15, 0x8a, 0x33, 0x92, 0x0f, 0x83, 0x8b,
	0x90, 0xbd, 0x80, 0xb6, 0x3b, 0x8b, 0x22, 0x1e, 0xb8, 0x73, 0x1a, 0x64, 0x53, 0x1b, 0x44, 0x2a,
	0x70, 0x90, 0x96, 0xab, 0xb5, 0xc4, 0x10, 0xfc, 0xb7, 0xee, 0x95, 0x13, 0x5c, 0x72, 0xb9, 0x3f,
	0xbe, 0x67, 0xde, 0xa5, 0x21, 0x94, 0x82, 0x52, 0x48, 0xe4, 0xc7, 0xba, 0x38, 0x53, 0xdb, 0x0d,
	0x03, 0xcf, 0x17, 0x19, 0x40, 0x03, 0x6d, 0xe1, 0xc2, 0xd7, 0x84, 0xaa, 0xaf, 0x34, 0xd8, 0xf7,
	0x2e, 0x18, 0x51, 0x38, 0x4b, 0xb8, 0xad, 0x25, 0x9d, 0x89, 0x5d, 0x77, 0x50, 0x7e, 0x90, 0x66,
	0x5e, 0x0f, 0xe8, 0x2c, 0xb0, 0x43, 0x61, 0x76, 0x0f, 0xfb, 0x6c, 0xa2, 0x50, 0xf4, 0x35, 0xf4,
	0xd8, 0x36, 0x80, 0x16, 0x82, 0xf7, 0x29, 0x1f, 0x32, 0x09, 0xdb, 0x87, 0x66, 0x78, 0x71, 0x11,
	0xf3, 0xc4, 0xbe, 0x18, 0x3b, 0x97, 0xe6, 0x03, 0x5c, 0xfe, 0x9a, 0x4a, 0x49, 0xd4, 0xbc, 0x1a,
	0x3b, 0x97, 0x16, 0x84, 0xe9, 0x6f, 0x11, 0x39, 0x3c, 0x8a, 0xc2, 0xc8, 0x76, 0x43, 0x8f, 0x9b,
	0x0f, 0x29, 0x72, 0x50, 0xd2, 0x0f, 0x3d, 0xce, 0x36, 0xa0, 0x9a, 0x84, 0xef, 0x78, 0x60, 0x3e,
	0xc2, 0x59, 0x53, 0x83, 0xdd, 0x87, 0x7a, 0x9c, 0x84, 0xd3, 0x71, 0x18, 0xc7, 0xe6, 0x36, 0x4e,
	0x23, 0x6d, 0x8b, 0xac, 0x4d, 0x9c, 0x77, 0x5c, 0x9c, 0xd8, 0x85, 0x9f, 0x98, 0x1f, 0xd0, 0x2c,
	0x85, 0xe8, 0x0c, 0x25, 0x22, 0x3b, 0x29, 0x2d, 0x6d, 0x67, 0x22, 0x16, 0x6f, 0xee, 0xa0, 0x49,
	0x8b, 0x84, 0x07, 0x28, 0xd3, 0xb2, 0x73, 0x32, 0x1b, 0x27, 0xfe, 0x74, 0xcc, 0xcd, 0xc7, 0x7a,
	0x76, 0x1e, 0x4b, 0x29, 0xfb, 0x54, 0xa0, 0x8a, 0x8c, 0x0d, 0xcf, 0xec, 0x21, 0xf0, 0xb5, 0xc5,
	0x92, 0x55, 0x64, 0x1c, 0x0a, 0x48, 0xa1, 0x9f, 0x08, 0x7f, 0x12, 0x83, 0x7c, 0xf7, 0x9d, 0xf9,
	0x04, 0x07, 0x96, 0x88, 0xe3, 0xbb, 0xef, 0xc4, 0xd4, 0x64, 0xaa, 0x4f, 0x9c, 0xe8, 0xd2, 0x0f,
	0xcc, 0x0f, 0x69, 0x6a, 0x24, 0x3c, 0x46, 0x99, 0x58, 0x20, 0x81, 0xad, 0x1d, 0x38, 0x13, 0x6e,
	0x7e, 0x84, 0x1b, 0x03, 0x24, 0x3a, 0x71, 0x26, 0x9c, 0x7d, 0x04, 0x9d, 0x88, 0x3b, 0x71, 0x48,
	0x80, 0x21, 0xb2, 0xf5, 0x63, 0xb4, 0x69, 0x93, 0xb4, 0x4f, 0xc2, 0xde, 0x67, 0xd0, 0x52, 0x48,
	0x79, 0xe4, 0xc7, 0x09, 0xdb, 0x81, 0x95, 0xb1, 0x1f, 0x27, 0x66, 0x69, 0xa7, 0xb2, 0xdb, 0xdc,
	0x6f, 0xe9, 0x48, 0x6a, 0xa1, 0xa6, 0x37, 0x05, 0xf8, 0x55, 0xe8, 0x07, 0x09, 0x95, 0x83, 0x3f,
	0x82, 0xa6, 0x96, 0xd4, 0xb2, 0x26, 0xe4, 0xdd, 0x20, 0x4b, 0x6f, 0xf6, 0x39, 0x74, 0xf2, 0x61,
	0x2e, 0xab, 0x44, 0xde, 0xa3, 0x9d, 0x8b, 0xf8, 0xde, 0x5f, 0xe8, 0x73, 0x0c, 0xde, 0xb1, 0x0f,
	0x61, 0x75, 0xea, 0x44, 0x62, 0x49, 0x45, 0xc3, 0x49, 0x1d, 0xdb, 0x85, 0xba, 0x7b, 0xe5, 0x8f,
	0xbd, 0x88, 0x07, 0x66, 0xb9, 0x60, 0x35, 0xa9, 0xb6, 0xf7, 0x1f, 0x65, 0xd8, 0xec, 0x8f, 0xce,
	0x08, 0x6b, 0x49, 0x49, 0xa0, 0xb5, 0x50, 0xa8, 0x4a, 0xcb, 0x85, 0x4a, 0x2b, 0xcd, 0xd7, 0xd4,
	0x3b, 0xbd, 0x78, 0x67, 0xb5, 0xb3, 0x72, 0x6d, 0xed, 0xcc, 0x83, 0xe8, 0xca, 0x22, 0x88, 0xea,
	0xf5, 0xbf, 0x8a, 0xca, 0x6b, 0xea, 0xff, 0x2a, 0x79, 0x66, 0xf5, 0xbf, 0x10, 0x61, 0x6a, 0xc5,
	0x08, 0x93, 0x26, 0x5c, 0x5d, 0x4f, 0xb8, 0x22, 0x1c, 0x69, 0x14, 0xe1, 0x48, 0xef, 0x5f, 0xca,
	0xb0, 0x2e, 0xd6, 0x1d, 0x58, 0x49, 0xa0, 0x6d, 0xeb, 0x4d, 0xfb, 0xf9, 0x09, 0xd4, 0xd3, 0x99,
	0x15, 0xef, 0x66, 0x2d, 0x94, 0x33, 0x2c, 0x5c, 0x4d, 0xa5, 0x78, 0x35, 0xd9, 0xb6, 0xaf, 0xdc,
	0x72, 0xdb, 0xab, 0x8b, 0xdb, 0x9e, 0x02, 0x54, 0x4a, 0x1b, 0x14, 0x40, 0x21, 0xc2, 0x6e, 0x40,
	0x15, 0x1b, 0xb8, 0x9f, 0x55, 0x8b, 0x1a, 0xcc, 0x80, 0xca, 0x24, 0xbe, 0x94, 0x7b, 0x28, 0x7e,
	0xbe, 0xc7, 0x0e, 0xfe, 0x4d, 0x0d, 0x3a, 0xfd, 0xd1, 0x19, 0xd2, 0x04, 0x8b, 0x4f, 0xc3, 0xe8,
	0xc6, 0x60, 0xbc, 0x07, 0x75, 0x04, 0x2f, 0xb5, 0x79, 0x0d, 0xab, 0x86, 0xed, 0xdc, 0x06, 0x5c,
	0x1f, 0x77, 0xef, 0x4b, 0xba, 0x36, 0xa0, 0x4a, 0x8c, 0xa8, 0x8a, 0xe8, 0x44, 0x0d, 0x8d, 0x0c,
	0xad, 0xe6, 0xc8, 0x90, 0xc0, 0x63, 0x82, 0x5b, 0x64, 0x23, 0x35, 0x64, 0x23, 0x40, 0x22, 0xa4,
	0x22, 0x9f, 0x02, 0x53, 0x06, 0x1a, 0x0d, 0x21, 0x46, 0x65, 0x48, 0xbb, 0x8c, 0x83, 0xe8, 0x81,
	0xd2, 0xf8, 0xe9, 0x40, 0xc9, 0x13, 0x3e, 0xb8, 0x99, 0xf0, 0x3d, 0x07, 0xd0, 0x28, 0x42, 0xf3,
	0x1a, 0x8a, 0xd0, 0xb8, 0x4a, 0xd9, 0xc1, 0x73, 0xa0, 0x85, 0x90, 0x43, 0x2b, 0xe7, 0x80, 0xe7,
	0x47, 0x0e, 0x89, 0xfa, 0x29, 0x00, 0x3e, 0x4f, 0x11, 0x88, 0x6d, 0xdd, 0x82, 0x10, 0x74, 0xae,
	0x0b, 0xf0, 0x85, 0xb2, 0xdd, 0xbd, 0xa9, 0x6c, 0x1b, 0x4b, 0x65, 0xdb, 0x80, 0x4a, 0xe2, 0xfc,
	0x16, 0x89, 0x56, 0xc9, 0x12, 0x3f, 0x05, 0x5f, 0x4b, 0xc2, 0x44, 0x40, 0x7b, 0x72, 0xc5, 0x23,
	0xfb, 0x82, 0x13, 0xb7, 0x2a, 0x59, 0x6d, 0x14, 0x9f, 0x0a, 0xe9, 0x2b, 0xce, 0xd9, 0x67, 0xb0,
	0xe1, 0x07, 0x7e, 0xe2, 0x8b, 0xf1, 0xe9, 0x08, 0x29, 0x30, 0xd6, 0xd1, 0x98, 0x49, 0x1d, 0x11,
	0x5e, 0xa2, 0xcc, 0x26, 0xd4, 0x22, 0x1e, 0xf3, 0xe8, 0x07, 0x8e, 0x2c, 0xaa, 0x64, 0xa9, 0xe6,
	0x22, 0x79, 0xd8, 0xbc, 0x0d, 0x79, 0x28, 0x4a, 0xaa, 0xbb, 0x85, 0xf4, 0x66, 0xa1, 0x68, 0x6e,
	0x2d, 0x15, 0xcd, 0x7c, 0x65, 0x36, 0x17, 0x2a, 0x73, 0xef, 0x17, 0xc0, 0xf2, 0x39, 0x89, 0x25,
	0xf3, 0xe3, 0x5c, 0xc9, 0x64, 0xfa, 0xc9, 0x93, 0x95, 0x2c, 0x9c, 0xff, 0xb7, 0x02, 0x1b, 0x22,
	0xe8, 0xc2, 0x18, 0xa9, 0xd9, 0xf9, 0x6c, 0x32, 0x71, 0x30, 0x95, 0x72, 0xa9, 0x57, 0xba, 0x39,
	0xf5, 0x18, 0xac, 0x60, 0xd8, 0x94, 0xf1, 0x94, 0xf1, 0x77, 0xe1, 0x26, 0x54, 0x0a, 0x37, 0xe1,
	0x3e, 0xd4, 0xa7, 0x72, 0x0a, 0xb2, 0xbc, 0xa4, 0x6d, 0x91, 0xbe, 0x92, 0x0e, 0x51, 0x56, 0xcb,
	0x96, 0x18, 0xd1, 0x0d, 0xe3, 0x04, 0x93, 0xba, 0x64, 0xe1, 0x6f, 0x61, 0x4b, 0x8c, 0x44, 0x82,
	0x9e, 0x6c, 0xb1, 0x87, 0xd0, 0x70, 0x7e, 0x70, 0xfc, 0xb1, 0xf3, 0x76, 0xac, 0xae, 0x44, 0x99,
	0x40, 0x50, 0x2a, 0x35, 0x9a, 0x22, 0x67, 0x0d, 0xec, 0xb4, 0xa3, 0xc4, 0x19, 0x41, 0x43, 0xfe,
	0xef, 0x29, 0x33, 0x20, 0x16, 0x44, 0x42, 0x69, 0x74, 0x17, 0x56, 0x25, 0x47, 0xa2, 0xab, 0x90,
	0x6c, 0x2d, 0x53, 0xa8, 0x56, 0x01, 0x85, 0xca, 0x67, 0x44, 0x7b, 0x29, 0x23, 0x0a, 0xaf, 0x5c,
	0x9d, 0x6b, 0xae, 0x5c, 0xf7, 0xa1, 0xee, 0x07, 0x09, 0x8f, 0x78, 0x9c, 0x60, 0xf6, 0x95, 0xac,
	0xb4, 0x2d, 0xd6, 0x2c, 0x3b, 0x4a, 0x4d, 0x28, 0xff, 0x3a, 0x24, 0x1e, 0x2a, 0xc3, 0x47, 0x00,
	0x93, 0x64, 0xa2, 0x16, 0x4c, 0xa9, 0xd8, 0x98, 0x24, 0x13, 0xb9, 0xda, 0x7d, 0xd8, 0x74, 0xc7,
	0xdc, 0x89, 0xb8, 0x67, 0xe7, 0xb7, 0x86, 0xd2, 0x72, 0x5d, 0x2a, 0xfb, 0xda, 0x0e, 0xf5, 0xfe,
	0x77, 0x05, 0x9a, 0x5a, 0xd0, 0xdd, 0xea, 0xfa, 0xfe, 0x25, 0x34, 0x62, 0x15, 0x9c, 0xb2, 0x0e,
	0x9b, 0x0a, 0x31, 0x17, 0x83, 0xd7, 0xca, 0x4c, 0xd9, 0x81, 0x00, 0x0c, 0xcf, 0x99, 0xdb, 0x99,
	0x77, 0xe5, 0x06, 0xef, 0x0e, 0x3a, 0x64, 0xa9, 0x30, 0x84, 0xf5, 0x39, 0x8f, 0x13, 0x1e, 0xe5,
	0xbb, 0x59, 0xb9, 0xa1, 0x1b, 0x96, 0x3a, 0x65, 0x5d, 0x7d, 0x06, 0x1b, 0xd3, 0x88, 0xdb, 0x31,
	0x4f, 0x92, 0x31, 0x17, 0x5c, 0xd7, 0xd6, 0xeb, 0x15, 0x9b, 0x46, 0xfc, 0x3c, 0x55, 0x11, 0x2c,
	0x7d, 0x02, 0xc6, 0x92, 0x35, 0x45, 0x7c, 0x37, 0x5e, 0x30, 0x7d, 0x04, 0x30, 0x76, 0xe2, 0xfc,
	0xa3, 0x40, 0x43, 0x48, 0x48, 0x2d, 0xcb, 0x5d, 0xbe, 0x8c, 0x41, 0x92, 0x15, 0xb0, 0xc7, 0xd0,
	0x52, 0x17, 0x06, 0x4c, 0x65, 0x7a, 0x1b, 0x68, 0x4a, 0x19, 0x16, 0x80, 0x82, 0xcb, 0x47, 0xf3,
	0x16, 0x97, 0x8f, 0xd6, 0x7b, 0x5d, 0x3e, 0xda, 0x8b, 0x97, 0x8f, 0x05, 0x88, 0xec, 0x14, 0x41,
	0xa4, 0x06, 0x31, 0xdd, 0x05, 0x16, 0xd2, 0xfb, 0x12, 0xba, 0xda, 0x09, 0x21, 0x3e, 0x3e, 0xc9,
	0xe1, 0x63, 0x77, 0xe1, 0x10, 0x25, 0x38, 0xfe, 0x7b, 0x03, 0x19, 0x23, 0xdd, 0xed, 0x09, 0x3a,
	0xdd, 0x30, 0xf2, 0x6e, 0x22, 0x3d, 0x59, 0x38, 0x97, 0x6f, 0xc7, 0x6c, 0x2a, 0x37, 0xc3, 0xeb,
	0x07, 0xd0, 0x0c, 0xa7, 0x3c, 0xb0, 0x25, 0x91, 0x21, 0x8c, 0x04, 0x21, 0xfa, 0x26, 0x25, 0x33,
	0x68, 0x90, 0x83, 0x4a, 0x34, 0x90, 0xf7, 0xc6, 0x0c, 0xbb, 0x72, 0x64, 0x48, 0x62, 0xd7, 0x37,
	0xe9, 0xfb, 0x90, 0x34, 0x92, 0xfd, 0xd4, 0x74, 0x80, 0x93, 0x3d, 0x3d, 0x80, 0x06, 0x0e, 0x85,
	0xac, 0xa9, 0x2e, 0x1f, 0xed, 0xa6, 0x3c, 0x40, 0xce, 0xb4, 0x0b, 0x06, 0x29, 0xb5, 0x50, 0xa3,
	0x40, 0xea, 0xa0, 0x4d, 0x16, 0x6e, 0xfb, 0xd0, 0x46, 0xcb, 0x94, 0x48, 0x40, 0x21, 0x69, 0xc2,
	0x65, 0x69, 0xa4, 0x22, 0xed, 0x1d, 0x49, 0x45, 0x13, 0x37, 0xbf, 0xa9, 0xba, 0xe6, 0xf4, 0xa4,
	0xa3, 0xd9, 0xa4, 0xfc, 0xa7, 0x6a, 0xb5, 0x53, 0x2b, 0x8c, 0x65, 0x65, 0xa7, 0x11, 0xab, 0x76,
	0x66, 0x97, 0x3d, 0xb4, 0x3c, 0x02, 0x90, 0x8f, 0x3e, 0xbe, 0x0c, 0xbe, 0x8a, 0xd5, 0x40, 0x09,
	0x2e, 0x78, 0x0f, 0xd6, 0xa4, 0x5a, 0x5b, 0x31, 0x71, 0x9d, 0xae, 0xab, 0x22, 0x47, 0x2e, 0xf9,
	0x0b, 0xe8, 0x90, 0x6d, 0xba, 0x66, 0xa3, 0x70, 0xcd, 0xb4, 0xdf, 0x6a, 0xd1, 0x1f, 0x2a, 0xaf,
	0x74, 0xd5, 0x6b, 0xb8, 0xea, 0x56, 0xda, 0xbd, 0x58, 0xf6, 0x2e, 0x18, 0xba, 0x95, 0xf6, 0xec,
	0xd4, 0xc9, 0xec, 0xd4, 0xd3, 0x0b, 0x59, 0x2e, 0xbc, 0x3a, 0x29, 0xcb, 0x6c, 0xe9, 0x8f, 0x81,
	0xc6, 0x50, 0x98, 0x4e, 0xc4, 0xa8, 0x89, 0x32, 0x89, 0xff, 0xd7, 0x21, 0xda, 0xe6, 0xb5, 0x88,
	0xb6, 0xf4, 0x18, 0x75, 0xf7, 0x56, 0x8f, 0x51, 0x3f, 0x93, 0xc7, 0xa5, 0xd5, 0xbd, 0x2d, 0x2a,
	0x58, 0x42, 0xac, 0x55, 0xbd, 0x4f, 0xd4, 0xf2, 0x34, 0x4b, 0x62, 0x4d, 0x74, 0x1e, 0x9a, 0x69,
	0x56, 0xaa, 0xef, 0xe5, 0x4a, 0xf5, 0x33, 0x58, 0x57, 0xec, 0x51, 0x4f, 0x2a, 0x7a, 0x57, 0x5a,
	0x93, 0xaa, 0xd3, 0x2c, 0xb7, 0x0a, 0x60, 0xf1, 0x41, 0x21, 0x2c, 0x16, 0x54, 0xdd, 0x87, 0x85,
	0x55, 0xb7, 0x88, 0x3a, 0x3d, 0x2a, 0xa4, 0x4e, 0x05, 0xe4, 0x65, 0xbb, 0x88, 0xbc, 0xf4, 0x5e,
	0xc1, 0x56, 0x01, 0x98, 0x21, 0x1a, 0x3e, 0xcd, 0xa1, 0xe1, 0x96, 0x8c, 0xc6, 0x45, 0x53, 0x89,
	0x8a, 0x7f, 0x5f, 0x86, 0x76, 0x7f, 0x74, 0x46, 0x84, 0xc5, 0x72, 0x12, 0x01, 0xf6, 0x75, 0xc5,
	0xfe, 0x75, 0xaa, 0x38, 0x90, 0x32, 0x3c, 0xcc, 0xd4, 0x42, 0x6c, 0xba, 0x06, 0x8f, 0x8d, 0x14,
	0x12, 0x4d, 0xa8, 0xc9, 0x8a, 0x20, 0x49, 0xa2, 0x6a, 0x8a, 0x04, 0x18, 0x87, 0xc1, 0xa5, 0xfd,
	0x76, 0xae, 0xe3, 0x5f, 0xc9, 0x6a, 0x09, 0xe9, 0xcb, 0xb9, 0xc4, 0x2e, 0xcd, 0x2a, 0x07, 0x82,
	0xd2, 0x4a, 0x1e, 0xd5, 0xc7, 0xd0, 0x8d, 0xaf, 0xc2, 0x28, 0xd1, 0x3a, 0xa3, 0x72, 0xda, 0x46,
	0x71, 0xda, 0x9b, 0x6e, 0x97, 0xc3, 0x42, 0x65, 0x27, 0xfb, 0xeb, 0xe0, 0x67, 0x05, 0x40, 0x54,
	0x28, 0xfb, 0x5e, 0xef, 0x1f, 0x4b, 0xda, 0xee, 0x0c, 0x13, 0x3e, 0x29, 0x98, 0x7d, 0xe9, 0x56,
	0xb3, 0x2f, 0xdf, 0x6e, 0xf6, 0x95, 0x5b, 0xce, 0x7e, 0xa5, 0x60, 0xf6, 0xbd, 0x7f, 0x2a, 0xd1,
	0x2b, 0x53, 0x9a, 0x12, 0xe2, 0x3c, 0x71, 0xd6, 0x0f, 0xa0, 0x91, 0xf9, 0xd2, 0x84, 0xeb, 0x6f,
	0xe7, 0x59, 0x05, 0xc8, 0x26, 0x50, 0x56, 0x4a, 0x39, 0xb6, 0x09, 0xb5, 0x89, 0x1f, 0xf8, 0x93,
	0xd9, 0x44, 0xce, 0x4d, 0x35, 0x17, 0x2f, 0x52, 0x2b, 0xb7, 0xb9, 0x48, 0xe1, 0x15, 0xf0, 0x12,
	0x8f, 0xb2, 0x21, 0xae, 0x80, 0x97, 0xbd, 0x7f, 0x2e, 0xc1, 0xda, 0xd2, 0x9c, 0xff, 0xe0, 0x31,
	0xf8, 0x02, 0xea, 0x02, 0xe3, 0xfc, 0xe0, 0x32, 0x36, 0x57, 0x30, 0x4d, 0xee, 0xa9, 0x34, 0x59,
	0xda, 0x3c, 0x2b, 0x35, 0x95, 0xe1, 0x51, 0x4d, 0xc3, 0xe3, 0xaf, 0xaa, 0xe9, 0x13, 0x8a, 0x1f,
	0x5c, 0xbe, 0x09, 0xfc, 0xe4, 0x56, 0xec, 0xf7, 0xa9, 0x76, 0x3f, 0x2a, 0x17, 0x53, 0x96, 0xec,
	0xc2, 0xf4, 0x27, 0x40, 0x1f, 0x1a, 0xec, 0xb1, 0x1f, 0xbc, 0xb3, 0x31, 0xb1, 0x2b, 0xe8, 0x63,
	0xe8, 0x65, 0xe6, 0xc8, 0x0f, 0xde, 0x59, 0xed, 0x50, 0xfd, 0x44, 0x1c, 0x18, 0xc2, 0x46, 0x8a,
	0x25, 0x1e, 0x4f, 0x1c, 0x7f, 0x4c, 0xee, 0x2b, 0x3f, 0x8d, 0x0b, 0x4c, 0x39, 0x1d, 0xa2, 0x0f,
	0x76, 0x75, 0x00, 0xc6, 0x95, 0x1f, 0x27, 0x61, 0x34, 0xb7, 0xdd, 0x24, 0xa2, 0x6e, 0xaa, 0x3f,
	0xdd, 0x4d, 0x47, 0x3a, 0xf4, 0x13, 0x7a, 0xf6, 0xfd, 0x0a, 0x98, 0xea, 0x42, 0xad, 0x07, 0xaf,
	0x7b, 0xcb, 0xcf, 0xa6, 0x6a, 0xa8, 0xec, 0xc9, 0xf8, 0x97, 0x99, 0x2f, 0xd5, 0x43, 0xf4, 0xad,
	0x5d, 0x7b, 0x1b, 0x56, 0x3d, 0xa0, 0x0c, 0x7b, 0xc8, 0xb3, 0x69, 0x58, 0x64, 0xd3, 0xcf, 0x61,
	0x03, 0xd5, 0x13, 0x2f, 0xb6, 0x67, 0x53, 0xcf, 0x49, 0x24, 0x3f, 0x68, 0xe2, 0x51, 0xaf, 0x09,
	0xdd, 0xb1, 0x17, 0xbf, 0x41, 0x0d, 0xf2, 0x84, 0x3c, 0xc7, 0x6d, 0x2d, 0x72, 0xdc, 0x82, 0x12,
	0xd2, 0x2e, 0x2c, 0x21, 0x1f, 0x41, 0xd9, 0x8d, 0x90, 0x86, 0x34, 0xf7, 0x37, 0x0b, 0x43, 0xd0,
	0x2a, 0xbb, 0x11, 0x7b, 0x0c, 0xe5, 0x49, 0x84, 0x3c, 0xa4, 0x99, 0xa6, 0x58, 0x06, 0xd9, 0x56,
	0x79, 0x12, 0xf5, 0x26, 0x98, 0xfb, 0xaf, 0xb2, 0xcf, 0x57, 0xfe, 0x84, 0x5b, 0xb3, 0x31, 0xbe,
	0x1c, 0xc6, 0x89, 0x13, 0x25, 0xf2, 0x63, 0x2e, 0x35, 0x44, 0x26, 0xf2, 0x40, 0x7d, 0xc3, 0x15,
	0x3f, 0xd9, 0xa7, 0xc0, 0x3c, 0x3f, 0x16, 0x57, 0x68, 0x2a, 0x93, 0xe4, 0x44, 0x9f, 0x71, 0x0d,
	0xa9, 0x11, 0x55, 0xf2, 0x5c, 0xc8, 0x7b, 0xff, 0x5a, 0xc3, 0xa7, 0x06, 0x2d, 0xf4, 0x4f, 0xa7,
	0x18, 0xaf, 0x3f, 0x07, 0x53, 0xfb, 0x9a, 0x69, 0xeb, 0x5d, 0xe2, 0x0c, 0xaa, 0xd6, 0x66, 0xf6,
	0x69, 0xf3, 0x30, 0xeb, 0x96, 0xbd, 0x80, 0x2d, 0xdd, 0x51, 0xfb, 0x40, 0x27, 0x9f, 0x21, 0x36,
	0x32, 0xbf, 0x6c, 0x99, 0x6c, 0x08, 0x8f, 0x05, 0x65, 0xc9, 0xaa, 0x26, 0x8f, 0x5c, 0x1e, 0x24,
	0x8e, 0xe0, 0x42, 0x57, 0x11, 0x8f, 0xaf, 0xc2, 0xb1, 0x27, 0xa1, 0x6b, 0x7b, 0x1a, 0x71, 0x95,
	0x61, 0x67, 0xa9, 0xd9, 0x48, 0x59, 0xb1, 0x2f, 0xe0, 0x6e, 0xae, 0xab, 0xcc, 0x9f, 0xe0, 0x76,
	0x43, 0xf3, 0xcf, 0xbc, 0x06, 0xf0, 0x81, 0xf0, 0x92, 0xe7, 0x5d, 0x38, 0x3c, 0x95, 0xae, 0x87,
	0xd3, 0x88, 0x13, 0xaa, 0x16, 0x0d, 0x2e, 0xa9, 0x97, 0xfa, 0xa0, 0x9b, 0xfa, 0xae, 0xa6, 0xd4,
	0x8b, 0x7c, 0x33, 0x8f, 0x5f, 0x41, 0x2f, 0xf6, 0x83, 0xcb, 0x31, 0x4f, 0xbf, 0x1a, 0x12, 0xe1,
	0xb1, 0x7f, 0xc3, 0xfd, 0xcb, 0xab, 0xc4, 0xc6, 0xed, 0x92, 0x75, 0x6e, 0x9b, 0x2c, 0xe5, 0x7d,
	0x8d, 0x42, 0xe7, 0x5b, 0x34, 0x3b, 0x12, 0x56, 0xec, 0x0b, 0xa8, 0x5f, 0xb8, 0x32, 0x27, 0xeb,
	0x39, 0x40, 0x5c, 0x8e, 0x28, 0xab, 0x76, 0xe1, 0x52, 0x5e, 0x3e, 0x86, 0x56, 0xee, 0x7c, 0xc5,
	0xd5, 0xa0, 0x6e, 0x35, 0xb5, 0x60, 0x61, 0x5f, 0x41, 0xd3, 0x8d, 0xec, 0x14, 0x6c, 0xe1, 0x26,
	0xb0, 0x05, 0x37, 0x3a, 0x57, 0x70, 0xbb, 0x0f, 0x4d, 0xb9, 0xa2, 0xc8, 0x49, 0x28, 0x19, 0x17,
	0xc3, 0x9f, 0x7c, 0x26, 0x19, 0x7b, 0x79, 0x0e, 0xeb, 0xea, 0x13, 0x9d, 0xed, 0x3a, 0x81, 0xe7,
	0x8b, 0x94, 0x8d, 0xcd, 0xd6, 0x4e, 0x65, 0xb7, 0x6a, 0x31, 0xa5, 0xea, 0xa7, 0x1a, 0x71, 0xe8,
	0xda, 0x77, 0x3c, 0xdd, 0xa7, 0x8d, 0x3e, 0x1b, 0xd9, 0x27, 0x3d, 0xcd, 0xeb, 0x29, 0xac, 0x65,
	0x5f, 0xd5, 0x95, 0x43, 0x07, 0x1d, 0x8c, 0xf4, 0xbb, 0xba, 0x32, 0xfe, 0x39, 0x98, 0xf9, 0xcc,
	0xa2, 0xeb, 0x2f, 0x6e, 0x76, 0x77, 0xa7, 0xb2, 0xdb, 0xb0, 0x36, 0xf5, 0xfc, 0x42, 0x2d, 0xee,
	0xef, 0x0b, 0xd8, 0xca, 0x39, 0xba, 0x63, 0x27, 0x8e, 0xc9, 0xcf, 0x40, 0xbf, 0x0d, 0xcd, 0xaf,
	0x2f, 0x94, 0xf2, 0xb9, 0x90, 0xc8, 0xb5, 0xe7, 0xcc, 0x63, 0x19, 0x05, 0x6b, 0xd9, 0x5d, 0xe8,
	0xd0, 0x99, 0xc7, 0x78, 0xe8, 0xbd, 0xbf, 0xad, 0x42, 0x97, 0xb6, 0xb1, 0x7f, 0xc5, 0xdd, 0x77,
	0xef, 0x85, 0x16, 0x7b, 0xb0, 0xa6, 0x7f, 0x42, 0xa7, 0x2f, 0x6d, 0x15, 0xba, 0x28, 0x65, 0xdf,
	0xd0, 0xe9, 0x9b, 0xcc, 0x13, 0x68, 0xff, 0xc6, 0x89, 0x02, 0x71, 0x9d, 0x1a, 0xf3, 0x1f, 0xf8,
	0x58, 0x11, 0x3e, 0x29, 0x3c, 0x12, 0xb2, 0xc5, 0x0e, 0xc9, 0x90, 0x12, 0x47, 0xeb, 0x90, 0x6c,
	0xbf, 0x84, 0x2d, 0xfa, 0x07, 0x8b, 0xfd, 0xd6, 0x19, 0x3b, 0x81, 0xab, 0xc1, 0x2c, 0xa5, 0xcb,
	0x26, 0xa9, 0x5f, 0x92, 0x36, 0x45, 0xdb, 0x57, 0xb0, 0x93, 0xdb, 0xcf, 0x59, 0x20, 0x0a, 0x51,
	0x7e, 0x6e, 0x35, 0x8c, 0xe1, 0x87, 0xda, 0xc6, 0xbe, 0x11, 0x56, 0xdf, 0xea, 0x73, 0xfd, 0x25,
	0x3c, 0xca, 0x39, 0x09, 0x62, 0x36, 0x8d, 0xf8, 0x05, 0x8f, 0x44, 0xa4, 0xfa, 0x21, 0xde, 0xa3,
	0x4b, 0xd6, 0x3d, 0x7d, 0x81, 0x2f, 0xe7, 0x67, 0x68, 0x61, 0x09, 0x03, 0xf6, 0x1a, 0x1e, 0x2f,
	0xad, 0x76, 0xa9, 0x17, 0x7a, 0xb6, 0x7c, 0xb8, 0xb0, 0xfa, 0x7c, 0x47, 0x2f, 0x60, 0x6b, 0x69,
	0x2a, 0xf2, 0x16, 0x44, 0x55, 0x6e, 0x23, 0x3f, 0x09, 0xf9, 0x32, 0xf9, 0x0b, 0x78, 0x50, 0x38,
	0x7e, 0xee, 0xad, 0x73, 0x6b, 0x69, 0x64, 0xe9, 0xfd, 0x11, 0x74, 0x64, 0x62, 0xba, 0xdc, 0x1f,
	0xfb, 0xc1, 0xa5, 0xac, 0x80, 0x6d, 0x92, 0xf6, 0x49, 0x28, 0x8e, 0x29, 0xc5, 0x52, 0xe2, 0x9e,
	0xa9, 0x3d, 0xbd, 0x0a, 0x6d, 0x2a, 0x35, 0x31, 0x51, 0xe9, 0xd7, 0xfb, 0xbb, 0x32, 0x6c, 0x64,
	0xf7, 0x4c, 0xad, 0xb6, 0x10, 0xff, 0x2a, 0x29, 0xfe, 0xa5, 0xff, 0x51, 0xa4, 0x9c, 0xff, 0xa3,
	0x48, 0xfe, 0xa1, 0xed, 0x32, 0x0a, 0x67, 0x53, 0x15, 0x9d, 0x99, 0xfc, 0xb5, 0x10, 0xb3, 0x7d,
	0xd8, 0x4c, 0x1f, 0x8f, 0x6d, 0x57, 0x24, 0x82, 0x16, 0xa5, 0x55, 0x6b, 0x3d, 0x55, 0x62, 0x92,
	0x50, 0x00, 0x7c, 0x08, 0x9d, 0x5c, 0xf4, 0x07, 0x18, 0xa9, 0x75, 0xab, 0xa5, 0x85, 0xbe, 0xb8,
	0x78, 0xd6, 0x27, 0x6e, 0x8e, 0xe8, 0xac, 0x0b, 0xf0, 0x5a, 0x48, 0x39, 0xab, 0x36, 0xb9, 0x06,
	0x4e, 0x6b, 0x4b, 0x70, 0xda, 0xfb, 0xcb, 0x32, 0xd2, 0x65, 0x59, 0x76, 0xe5, 0xbd, 0x91, 0xfd,
	0x31, 0xd4, 0xf0, 0x25, 0x33, 0x9a, 0x4b, 0xd6, 0x89, 0xac, 0x4c, 0x6a, 0x8f, 0xc3, 0x80, 0xd3,
	0xa3, 0x65, 0x34, 0xb7, 0x94, 0x1d, 0xdb, 0x87, 0xfa, 0x44, 0x31, 0xb9, 0x72, 0xc6, 0xe4, 0xd0,
	0x78, 0x14, 0x39, 0x41, 0x2c, 0x22, 0x8c, 0x98, 0x5c, 0x6d, 0x22, 0x29, 0xdc, 0x53, 0xa8, 0x25,
	0x33, 0x9d, 0x82, 0xea, 0xdc, 0x4b, 0xb2, 0x00, 0x6b, 0x35, 0x99, 0xa1, 0xf1, 0x2e, 0x18, 0x48,
	0xa9, 0x68, 0xbb, 0x6d, 0x81, 0x84, 0x72, 0x47, 0x3b, 0x42, 0x4e, 0xe7, 0x7b, 0x28, 0x20, 0x7b,
	0x1f, 0x6a, 0x21, 0x9e, 0x2f, 0xfd, 0xbb, 0x4a, 0xbe, 0xc2, 0x16, 0x05, 0x80, 0xa5, 0x0c, 0x7b,
	0xbf, 0x83, 0x7b, 0x4b, 0xdb, 0x70, 0x1e, 0x38, 0xd3, 0xf8, 0x2a, 0x4c, 0xd8, 0x73, 0xa8, 0xc9,
	0x8b, 0xb6, 0xdc, 0x8e, 0xcd, 0xfc, 0x3c, 0xa5, 0xbd, 0xa5, 0xac, 0xf0, 0x73, 0x87, 0x2f, 0x2f,
	0x3f, 0x15, 0x0b, 0x7f, 0xeb, 0xb1, 0x55, 0xc9, 0xc5, 0xd6, 0xde, 0x13, 0xfc, 0xb3, 0x40, 0xfa,
	0xb0, 0xc7, 0xea, 0xb0, 0x72, 0x74, 0x7a, 0xf2, 0xda, 0xb8, 0xc3, 0x1a, 0x50, 0x3d, 0xff, 0xfa,
	0xd4, 0x1a, 0x19, 0xa5, 0xbd, 0xdf, 0x97, 0xf0, 0x6a, 0xa0, 0xfd, 0x41, 0x4c, 0xd8, 0x1d, 0x9e,
	0x9e, 0x0c, 0x8c, 0x3b, 0xec, 0x11, 0xdc, 0x3b, 0x1b, 0x9c, 0x1c, 0x0e, 0x4f, 0x5e, 0xdb, 0xdf,
	0x0e, 0x47, 0x5f, 0xdb, 0x67, 0x07, 0xd6, 0x68, 0x78, 0x70, 0x64, 0xa3, 0xba, 0xc4, 0xb6, 0xe1,
	0x7e, 0xff, 0xe0, 0xa4, 0x3f, 0x38, 0x1a, 0x1c, 0x16, 0xe8, 0xcb, 0xac, 0x09, 0x35, 0xe9, 0x6e,
	0x54, 0x58, 0x0b, 0xea, 0xca, 0xd8, 0x58, 0x61, 0x00, 0xab, 0x6f, 0x4e, 0x7e, 0x7d, 0xfa, 0xed,
	0x89, 0x51, 0xdd, 0xfb, 0x33, 0x9c, 0x67, 0xfa, 0x05, 0x92, 0x75, 0xa1, 0x79, 0x34, 0x3c, 0x1e,
	0x8e, 0xec, 0x33, 0x6b, 0xd8, 0x17, 0xd3, 0x30, 0xa0, 0x75, 0x7c, 0x60, 0xfd, 0x7a, 0xa0, 0x24,
	0x25, 0xd6, 0x01, 0x78, 0x39, 0x38, 0x57, 0xed, 0xb2, 0x68, 0x1f, 0x1d, 0xa4, 0xed, 0xca, 0x1e,
	0xc7, 0xeb, 0x70, 0x76, 0xb9, 0x13, 0x6b, 0x3a, 0xa1, 0x35, 0xd5, 0x61, 0xe5, 0xf4, 0x6c, 0x70,
	0x62, 0x94, 0xc4, 0x2e, 0xf4, 0x8f, 0x4e, 0xcf, 0x85, 0x7f, 0x17, 0x9a, 0xaf, 0x4e, 0xad, 0xfe,
	0xc0, 0x26, 0x41, 0x45, 0x08, 0xf0, 0xa7, 0x3d, 0x3a, 0x3d, 0x3c, 0xf8, 0xce, 0x58, 0x61, 0xeb,
	0xd0, 0x25, 0xc1, 0x77, 0x83, 0xf3, 0xd1, 0xc0, 0x12, 0xc2, 0xea, 0xde, 0x9f, 0xe2, 0xcc, 0xb3,
	0x97, 0xab, 0x2e, 0x34, 0xcf, 0xcf, 0x06, 0xfd, 0x37, 0x47, 0x07, 0xa3, 0xe1, 0xe9, 0x89, 0x71,
	0x87, 0xb5, 0xa1, 0x71, 0x60, 0xbd, 0x1c, 0x8e, 0xac, 0x83, 0xd7, 0x03, 0x1a, 0xf1, 0xeb, 0xc1,
	0xe1, 0xeb, 0x81, 0x51, 0xde, 0xfb, 0x87, 0x12, 0xfa, 0x66, 0xef, 0x63, 0x00, 0xab, 0x27, 0xa7,
	0xd6, 0xf1, 0xc1, 0x91, 0x71, 0x87, 0x6d, 0xc2, 0xda, 0xe9, 0x99, 0xe8, 0xe2, 0xdc, 0x1e, 0xfc,
	0xf9, 0xa0, 0xff, 0x06, 0x7b, 0x2b, 0xb1, 0x1a, 0x54, 0x4e, 0x47, 0x7d, 0x9a, 0xee, 0xe0, 0xd5,
	0x99, 0x7d, 0x38, 0xb0, 0x86, 0xdf, 0x0c, 0x0e, 0x8d, 0x0a, 0xdb, 0x82, 0xf5, 0xfe, 0xe9, 0xf1,
	0xcb, 0xe1, 0x09, 0x0e, 0x9c, 0x2a, 0x56, 0x18, 0x83, 0xce, 0xe1, 0xe0, 0x68, 0xf8, 0xcd, 0xc0,
	0xfa, 0x4e, 0xae, 0xad, 0xca, 0xee, 0x02, 0x3b, 0x1f, 0x8c, 0x46, 0x47, 0x83, 0xe3, 0xc1, 0xc9,
	0x28, 0xb5, 0x5d, 0x15, 0xa3, 0x9e, 0x1d, 0x1d, 0xf4, 0xf3, 0xe2, 0xda, 0x4b, 0xe3, 0xdf, 0x7e,
	0xdc, 0x2e, 0xfd, 0xe7, 0x8f, 0xdb, 0xa5, 0xff, 0xfe, 0x71, 0xbb, 0xf4, 0xd7, 0xff, 0xb3, 0x7d,
	0xe7, 0xed, 0x2a, 0xfe, 0x1f, 0xf3, 0xf3, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x3b, 0xb9, 0xe2,
	0xed, 0xae, 0x29, 0x00, 0x00,
}
