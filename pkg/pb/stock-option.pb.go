// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stock-option.proto

package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 期权类型
type OptionType int32

const (
	// 看涨
	OptionType_CALL OptionType = 0
	// 看跌
	OptionType_PUT OptionType = 1
)

var OptionType_name = map[int32]string{
	0: "CALL",
	1: "PUT",
}
var OptionType_value = map[string]int32{
	"CALL": 0,
	"PUT":  1,
}

func (x OptionType) String() string {
	return proto.EnumName(OptionType_name, int32(x))
}
func (OptionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorStockOption, []int{0} }

// 执行方式
type StrikeMode int32

const (
	// 欧式
	StrikeMode_CONTINENTAL StrikeMode = 0
	// 美式
	StrikeMode_AMERICAN StrikeMode = 1
	// 百慕大
	StrikeMode_BERMUDA StrikeMode = 2
)

var StrikeMode_name = map[int32]string{
	0: "CONTINENTAL",
	1: "AMERICAN",
	2: "BERMUDA",
}
var StrikeMode_value = map[string]int32{
	"CONTINENTAL": 0,
	"AMERICAN":    1,
	"BERMUDA":     2,
}

func (x StrikeMode) String() string {
	return proto.EnumName(StrikeMode_name, int32(x))
}
func (StrikeMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorStockOption, []int{1} }

// 询价状态
type OptionQuoteStatus int32

const (
	// 已提交
	OptionQuoteStatus_Submitted OptionQuoteStatus = 0
	// 接受
	OptionQuoteStatus_Accepted OptionQuoteStatus = 1
	// 拒绝
	OptionQuoteStatus_Rejected OptionQuoteStatus = 2
)

var OptionQuoteStatus_name = map[int32]string{
	0: "Submitted",
	1: "Accepted",
	2: "Rejected",
}
var OptionQuoteStatus_value = map[string]int32{
	"Submitted": 0,
	"Accepted":  1,
	"Rejected":  2,
}

func (x OptionQuoteStatus) String() string {
	return proto.EnumName(OptionQuoteStatus_name, int32(x))
}
func (OptionQuoteStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorStockOption, []int{2} }

// 请求询价
type ReqOptionQuote struct {
	// 请求编号
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 标的合约
	StrikeSymbol Symbol `protobuf:"bytes,2,opt,name=strike_symbol,json=strikeSymbol" json:"strikeSymbol"`
	// 月价
	Months int32 `protobuf:"varint,3,opt,name=months,proto3" json:"months"`
	// 金额
	Amount float64 `protobuf:"fixed64,4,opt,name=amount,proto3" json:"amount"`
	// 期权类型
	Type OptionType `protobuf:"varint,5,opt,name=type,proto3,enum=pb.OptionType" json:"type"`
	// 执行方式
	Mode StrikeMode `protobuf:"varint,6,opt,name=mode,proto3,enum=pb.StrikeMode" json:"mode"`
	// 询价日期
	Date int32 `protobuf:"varint,7,opt,name=date,proto3" json:"date"`
	// 时间
	Time int64 `protobuf:"varint,8,opt,name=time,proto3" json:"time"`
	// 业务日期
	ActionDate int32 `protobuf:"varint,9,opt,name=action_date,json=actionDate,proto3" json:"actionDate"`
}

func (m *ReqOptionQuote) Reset()                    { *m = ReqOptionQuote{} }
func (m *ReqOptionQuote) String() string            { return proto.CompactTextString(m) }
func (*ReqOptionQuote) ProtoMessage()               {}
func (*ReqOptionQuote) Descriptor() ([]byte, []int) { return fileDescriptorStockOption, []int{0} }

func (m *ReqOptionQuote) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReqOptionQuote) GetStrikeSymbol() Symbol {
	if m != nil {
		return m.StrikeSymbol
	}
	return Symbol{}
}

func (m *ReqOptionQuote) GetMonths() int32 {
	if m != nil {
		return m.Months
	}
	return 0
}

func (m *ReqOptionQuote) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ReqOptionQuote) GetType() OptionType {
	if m != nil {
		return m.Type
	}
	return OptionType_CALL
}

func (m *ReqOptionQuote) GetMode() StrikeMode {
	if m != nil {
		return m.Mode
	}
	return StrikeMode_CONTINENTAL
}

func (m *ReqOptionQuote) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ReqOptionQuote) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ReqOptionQuote) GetActionDate() int32 {
	if m != nil {
		return m.ActionDate
	}
	return 0
}

// 询价结果
type RspOptionQuote struct {
	// 合约
	StrikeSymbol Symbol `protobuf:"bytes,1,opt,name=strike_symbol,json=strikeSymbol" json:"strikeSymbol"`
	// 金额
	Amount float64 `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount"`
	// 权利金率
	RoyaltyRatio float64 `protobuf:"fixed64,3,opt,name=royalty_ratio,json=royaltyRatio,proto3" json:"royaltyRatio"`
	// 权利金
	Royalty float64 `protobuf:"fixed64,4,opt,name=royalty,proto3" json:"royalty"`
}

func (m *RspOptionQuote) Reset()                    { *m = RspOptionQuote{} }
func (m *RspOptionQuote) String() string            { return proto.CompactTextString(m) }
func (*RspOptionQuote) ProtoMessage()               {}
func (*RspOptionQuote) Descriptor() ([]byte, []int) { return fileDescriptorStockOption, []int{1} }

func (m *RspOptionQuote) GetStrikeSymbol() Symbol {
	if m != nil {
		return m.StrikeSymbol
	}
	return Symbol{}
}

func (m *RspOptionQuote) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *RspOptionQuote) GetRoyaltyRatio() float64 {
	if m != nil {
		return m.RoyaltyRatio
	}
	return 0
}

func (m *RspOptionQuote) GetRoyalty() float64 {
	if m != nil {
		return m.Royalty
	}
	return 0
}

func init() {
	proto.RegisterType((*ReqOptionQuote)(nil), "pb.ReqOptionQuote")
	proto.RegisterType((*RspOptionQuote)(nil), "pb.RspOptionQuote")
	proto.RegisterEnum("pb.OptionType", OptionType_name, OptionType_value)
	proto.RegisterEnum("pb.StrikeMode", StrikeMode_name, StrikeMode_value)
	proto.RegisterEnum("pb.OptionQuoteStatus", OptionQuoteStatus_name, OptionQuoteStatus_value)
}
func (m *ReqOptionQuote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqOptionQuote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStockOption(dAtA, i, uint64(m.Id))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStockOption(dAtA, i, uint64(m.StrikeSymbol.Size()))
	n1, err := m.StrikeSymbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Months != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStockOption(dAtA, i, uint64(m.Months))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64StockOption(dAtA, i, uint64(math.Float64bits(float64(m.Amount))))
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStockOption(dAtA, i, uint64(m.Type))
	}
	if m.Mode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStockOption(dAtA, i, uint64(m.Mode))
	}
	if m.Date != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStockOption(dAtA, i, uint64(m.Date))
	}
	if m.Time != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStockOption(dAtA, i, uint64(m.Time))
	}
	if m.ActionDate != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStockOption(dAtA, i, uint64(m.ActionDate))
	}
	return i, nil
}

func (m *RspOptionQuote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspOptionQuote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStockOption(dAtA, i, uint64(m.StrikeSymbol.Size()))
	n2, err := m.StrikeSymbol.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Amount != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64StockOption(dAtA, i, uint64(math.Float64bits(float64(m.Amount))))
	}
	if m.RoyaltyRatio != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64StockOption(dAtA, i, uint64(math.Float64bits(float64(m.RoyaltyRatio))))
	}
	if m.Royalty != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64StockOption(dAtA, i, uint64(math.Float64bits(float64(m.Royalty))))
	}
	return i, nil
}

func encodeFixed64StockOption(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32StockOption(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStockOption(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ReqOptionQuote) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStockOption(uint64(m.Id))
	}
	l = m.StrikeSymbol.Size()
	n += 1 + l + sovStockOption(uint64(l))
	if m.Months != 0 {
		n += 1 + sovStockOption(uint64(m.Months))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovStockOption(uint64(m.Type))
	}
	if m.Mode != 0 {
		n += 1 + sovStockOption(uint64(m.Mode))
	}
	if m.Date != 0 {
		n += 1 + sovStockOption(uint64(m.Date))
	}
	if m.Time != 0 {
		n += 1 + sovStockOption(uint64(m.Time))
	}
	if m.ActionDate != 0 {
		n += 1 + sovStockOption(uint64(m.ActionDate))
	}
	return n
}

func (m *RspOptionQuote) Size() (n int) {
	var l int
	_ = l
	l = m.StrikeSymbol.Size()
	n += 1 + l + sovStockOption(uint64(l))
	if m.Amount != 0 {
		n += 9
	}
	if m.RoyaltyRatio != 0 {
		n += 9
	}
	if m.Royalty != 0 {
		n += 9
	}
	return n
}

func sovStockOption(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStockOption(x uint64) (n int) {
	return sovStockOption(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReqOptionQuote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStockOption
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqOptionQuote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqOptionQuote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrikeSymbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStockOption
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StrikeSymbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Months", wireType)
			}
			m.Months = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Months |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Amount = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (OptionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (StrikeMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionDate", wireType)
			}
			m.ActionDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStockOption(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStockOption
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspOptionQuote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStockOption
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspOptionQuote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspOptionQuote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrikeSymbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStockOption
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StrikeSymbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Amount = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoyaltyRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.RoyaltyRatio = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Royalty", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Royalty = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStockOption(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStockOption
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStockOption(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStockOption
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStockOption
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStockOption
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStockOption
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStockOption(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStockOption = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStockOption   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("stock-option.proto", fileDescriptorStockOption) }

var fileDescriptorStockOption = []byte{
	// 426 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0x7b, 0x9d, 0x34, 0x49, 0x6f, 0x12, 0x63, 0x66, 0x81, 0x46, 0x2c, 0x52, 0x2b, 0x6c,
	0xac, 0x48, 0x04, 0xa9, 0x6c, 0x58, 0x21, 0xb9, 0x69, 0x16, 0x95, 0x9a, 0x14, 0x26, 0xe9, 0x3a,
	0xf2, 0xcf, 0x48, 0x98, 0x76, 0x32, 0x43, 0x7c, 0xb3, 0xf0, 0x5b, 0x20, 0x56, 0x3c, 0x12, 0x4b,
	0x1e, 0x01, 0x85, 0x17, 0x41, 0x33, 0x76, 0x95, 0x22, 0x16, 0xec, 0xe6, 0x3b, 0x73, 0x7c, 0xaf,
	0xcf, 0xd1, 0x20, 0x2b, 0x49, 0x67, 0xf7, 0xaf, 0xb5, 0xa1, 0x42, 0x6f, 0xa7, 0x66, 0xa7, 0x49,
	0x33, 0xcf, 0xa4, 0x2f, 0x07, 0x99, 0x56, 0xea, 0x51, 0x19, 0x7f, 0xf3, 0xd0, 0x17, 0xf2, 0xcb,
	0xad, 0x73, 0x7d, 0xdc, 0x6b, 0x92, 0xcc, 0x47, 0xaf, 0xc8, 0x39, 0x84, 0x10, 0xb5, 0x84, 0x57,
	0xe4, 0xec, 0x0d, 0x0e, 0x4b, 0xda, 0x15, 0xf7, 0x72, 0x53, 0x56, 0x2a, 0xd5, 0x0f, 0xdc, 0x0b,
	0x21, 0xea, 0x5f, 0xe0, 0xd4, 0xa4, 0xd3, 0x95, 0x53, 0xc4, 0xa0, 0x36, 0xd4, 0xc4, 0x5e, 0x60,
	0x47, 0xe9, 0x2d, 0x7d, 0x2a, 0x79, 0x2b, 0x84, 0xe8, 0x54, 0x34, 0x64, 0xf5, 0x44, 0xe9, 0xfd,
	0x96, 0x78, 0x3b, 0x84, 0x08, 0x44, 0x43, 0x6c, 0x8c, 0x6d, 0xaa, 0x8c, 0xe4, 0xa7, 0x21, 0x44,
	0xfe, 0x85, 0x6f, 0xe7, 0xd6, 0xff, 0xb3, 0xae, 0x8c, 0x14, 0xee, 0xce, 0x7a, 0x94, 0xce, 0x25,
	0xef, 0x1c, 0x3d, 0x2b, 0xb7, 0x73, 0xa1, 0x73, 0x29, 0xdc, 0x1d, 0x63, 0xd8, 0xce, 0x13, 0x92,
	0xbc, 0xeb, 0xb6, 0xba, 0xb3, 0xd5, 0xa8, 0x50, 0x92, 0xf7, 0x5c, 0x1c, 0x77, 0x66, 0xe7, 0xd8,
	0x4f, 0x32, 0x3b, 0x7f, 0xe3, 0xec, 0x67, 0xce, 0x8e, 0xb5, 0x74, 0x95, 0x90, 0x1c, 0x7f, 0x07,
	0xf4, 0x45, 0x69, 0x9e, 0x96, 0xf2, 0x4f, 0x09, 0xf0, 0xff, 0x12, 0x9a, 0xb0, 0xde, 0x5f, 0x61,
	0x5f, 0xe1, 0x70, 0xa7, 0xab, 0xe4, 0x81, 0xaa, 0xcd, 0x2e, 0xa1, 0x42, 0xbb, 0x8e, 0x40, 0x0c,
	0x1a, 0x51, 0x58, 0x8d, 0x71, 0xec, 0x36, 0xdc, 0x54, 0xf5, 0x88, 0x93, 0x73, 0xc4, 0x63, 0x37,
	0xac, 0x87, 0xed, 0x59, 0x7c, 0x73, 0x13, 0x9c, 0xb0, 0x2e, 0xb6, 0x3e, 0xdc, 0xad, 0x03, 0x98,
	0xbc, 0x43, 0x3c, 0x16, 0xc3, 0x9e, 0x61, 0x7f, 0x76, 0xbb, 0x5c, 0x5f, 0x2f, 0xe7, 0xcb, 0x75,
	0x6c, 0x7d, 0x03, 0xec, 0xc5, 0x8b, 0xb9, 0xb8, 0x9e, 0xc5, 0xcb, 0x00, 0x58, 0x1f, 0xbb, 0x97,
	0x73, 0xb1, 0xb8, 0xbb, 0x8a, 0x03, 0x6f, 0xf2, 0x1e, 0x9f, 0x3f, 0x49, 0xbc, 0xa2, 0x84, 0xf6,
	0x25, 0x1b, 0xe2, 0xd9, 0x6a, 0x9f, 0xaa, 0x82, 0x48, 0xe6, 0xcd, 0xe7, 0x59, 0x26, 0x8d, 0x25,
	0xb0, 0x24, 0xe4, 0x67, 0x99, 0x59, 0xf2, 0x2e, 0x83, 0x1f, 0x87, 0x11, 0xfc, 0x3c, 0x8c, 0xe0,
	0xd7, 0x61, 0x04, 0x5f, 0x7f, 0x8f, 0x4e, 0xd2, 0x8e, 0x7b, 0x63, 0x6f, 0xff, 0x04, 0x00, 0x00,
	0xff, 0xff, 0x4c, 0xb2, 0x22, 0x68, 0x8b, 0x02, 0x00, 0x00,
}
